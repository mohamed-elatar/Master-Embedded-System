
Message_Queue_FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c8a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00003c8a  00003d1e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003ba  0080009c  0080009c  00003d5a  2**0
                  ALLOC
  3 .stab         000024c0  00000000  00000000  00003d5c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000083a  00000000  00000000  0000621c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000240  00000000  00000000  00006a58  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000045bd  00000000  00000000  00006c98  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000123d  00000000  00000000  0000b255  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001cab  00000000  00000000  0000c492  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e94  00000000  00000000  0000e140  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000018db  00000000  00000000  0000efd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004ec6  00000000  00000000  000108af  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  00015775  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 22 08 	jmp	0x1044	; 0x1044 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e8       	ldi	r30, 0x8A	; 138
      68:	fc e3       	ldi	r31, 0x3C	; 60
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 39       	cpi	r26, 0x9C	; 156
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	ac e9       	ldi	r26, 0x9C	; 156
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 35       	cpi	r26, 0x56	; 86
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 8a 19 	call	0x3314	; 0x3314 <main>
      8a:	0c 94 43 1e 	jmp	0x3c86	; 0x3c86 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_vset_pin_direction>:
/************************************** Driver_DIO ****************************************/

/********* dirction_pin **************/
void DIO_vset_pin_direction(char portname , char pinnumber , char dirction)
{
	switch(portname)
      92:	84 34       	cpi	r24, 0x44	; 68
      94:	09 f4       	brne	.+2      	; 0x98 <DIO_vset_pin_direction+0x6>
      96:	71 c0       	rjmp	.+226    	; 0x17a <DIO_vset_pin_direction+0xe8>
      98:	85 34       	cpi	r24, 0x45	; 69
      9a:	48 f4       	brcc	.+18     	; 0xae <DIO_vset_pin_direction+0x1c>
      9c:	82 34       	cpi	r24, 0x42	; 66
      9e:	99 f1       	breq	.+102    	; 0x106 <DIO_vset_pin_direction+0x74>
      a0:	83 34       	cpi	r24, 0x43	; 67
      a2:	08 f0       	brcs	.+2      	; 0xa6 <DIO_vset_pin_direction+0x14>
      a4:	4d c0       	rjmp	.+154    	; 0x140 <DIO_vset_pin_direction+0xae>
      a6:	81 34       	cpi	r24, 0x41	; 65
      a8:	09 f0       	breq	.+2      	; 0xac <DIO_vset_pin_direction+0x1a>
      aa:	83 c0       	rjmp	.+262    	; 0x1b2 <DIO_vset_pin_direction+0x120>
      ac:	0f c0       	rjmp	.+30     	; 0xcc <DIO_vset_pin_direction+0x3a>
      ae:	82 36       	cpi	r24, 0x62	; 98
      b0:	51 f1       	breq	.+84     	; 0x106 <DIO_vset_pin_direction+0x74>
      b2:	83 36       	cpi	r24, 0x63	; 99
      b4:	20 f4       	brcc	.+8      	; 0xbe <DIO_vset_pin_direction+0x2c>
      b6:	81 36       	cpi	r24, 0x61	; 97
      b8:	09 f0       	breq	.+2      	; 0xbc <DIO_vset_pin_direction+0x2a>
      ba:	7b c0       	rjmp	.+246    	; 0x1b2 <DIO_vset_pin_direction+0x120>
      bc:	07 c0       	rjmp	.+14     	; 0xcc <DIO_vset_pin_direction+0x3a>
      be:	83 36       	cpi	r24, 0x63	; 99
      c0:	09 f4       	brne	.+2      	; 0xc4 <DIO_vset_pin_direction+0x32>
      c2:	3e c0       	rjmp	.+124    	; 0x140 <DIO_vset_pin_direction+0xae>
      c4:	84 36       	cpi	r24, 0x64	; 100
      c6:	09 f0       	breq	.+2      	; 0xca <DIO_vset_pin_direction+0x38>
      c8:	74 c0       	rjmp	.+232    	; 0x1b2 <DIO_vset_pin_direction+0x120>
      ca:	57 c0       	rjmp	.+174    	; 0x17a <DIO_vset_pin_direction+0xe8>
	{
		case 'A':
		case 'a':
		if (dirction == 1)
      cc:	41 30       	cpi	r20, 0x01	; 1
      ce:	69 f4       	brne	.+26     	; 0xea <DIO_vset_pin_direction+0x58>
		{
			SET_BIT(MY_DDRA,pinnumber);
      d0:	2a b3       	in	r18, 0x1a	; 26
      d2:	81 e0       	ldi	r24, 0x01	; 1
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	ac 01       	movw	r20, r24
      d8:	02 c0       	rjmp	.+4      	; 0xde <DIO_vset_pin_direction+0x4c>
      da:	44 0f       	add	r20, r20
      dc:	55 1f       	adc	r21, r21
      de:	6a 95       	dec	r22
      e0:	e2 f7       	brpl	.-8      	; 0xda <DIO_vset_pin_direction+0x48>
      e2:	ba 01       	movw	r22, r20
      e4:	62 2b       	or	r22, r18
      e6:	6a bb       	out	0x1a, r22	; 26
      e8:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_DDRA,pinnumber);
      ea:	2a b3       	in	r18, 0x1a	; 26
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	ac 01       	movw	r20, r24
      f2:	02 c0       	rjmp	.+4      	; 0xf8 <DIO_vset_pin_direction+0x66>
      f4:	44 0f       	add	r20, r20
      f6:	55 1f       	adc	r21, r21
      f8:	6a 95       	dec	r22
      fa:	e2 f7       	brpl	.-8      	; 0xf4 <DIO_vset_pin_direction+0x62>
      fc:	ba 01       	movw	r22, r20
      fe:	60 95       	com	r22
     100:	62 23       	and	r22, r18
     102:	6a bb       	out	0x1a, r22	; 26
     104:	08 95       	ret
		}
		break;

		case 'B':
		case 'b':
		if (dirction == 1)
     106:	41 30       	cpi	r20, 0x01	; 1
     108:	69 f4       	brne	.+26     	; 0x124 <DIO_vset_pin_direction+0x92>
		{
			SET_BIT(MY_DDRB,pinnumber);
     10a:	27 b3       	in	r18, 0x17	; 23
     10c:	81 e0       	ldi	r24, 0x01	; 1
     10e:	90 e0       	ldi	r25, 0x00	; 0
     110:	ac 01       	movw	r20, r24
     112:	02 c0       	rjmp	.+4      	; 0x118 <DIO_vset_pin_direction+0x86>
     114:	44 0f       	add	r20, r20
     116:	55 1f       	adc	r21, r21
     118:	6a 95       	dec	r22
     11a:	e2 f7       	brpl	.-8      	; 0x114 <DIO_vset_pin_direction+0x82>
     11c:	ba 01       	movw	r22, r20
     11e:	62 2b       	or	r22, r18
     120:	67 bb       	out	0x17, r22	; 23
     122:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_DDRB,pinnumber);
     124:	27 b3       	in	r18, 0x17	; 23
     126:	81 e0       	ldi	r24, 0x01	; 1
     128:	90 e0       	ldi	r25, 0x00	; 0
     12a:	ac 01       	movw	r20, r24
     12c:	02 c0       	rjmp	.+4      	; 0x132 <DIO_vset_pin_direction+0xa0>
     12e:	44 0f       	add	r20, r20
     130:	55 1f       	adc	r21, r21
     132:	6a 95       	dec	r22
     134:	e2 f7       	brpl	.-8      	; 0x12e <DIO_vset_pin_direction+0x9c>
     136:	ba 01       	movw	r22, r20
     138:	60 95       	com	r22
     13a:	62 23       	and	r22, r18
     13c:	67 bb       	out	0x17, r22	; 23
     13e:	08 95       	ret
		}
		break;

		case 'C':
		case 'c':
		if (dirction == 1)
     140:	41 30       	cpi	r20, 0x01	; 1
     142:	69 f4       	brne	.+26     	; 0x15e <DIO_vset_pin_direction+0xcc>
		{
			SET_BIT(MY_DDRC,pinnumber);
     144:	24 b3       	in	r18, 0x14	; 20
     146:	81 e0       	ldi	r24, 0x01	; 1
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	ac 01       	movw	r20, r24
     14c:	02 c0       	rjmp	.+4      	; 0x152 <DIO_vset_pin_direction+0xc0>
     14e:	44 0f       	add	r20, r20
     150:	55 1f       	adc	r21, r21
     152:	6a 95       	dec	r22
     154:	e2 f7       	brpl	.-8      	; 0x14e <DIO_vset_pin_direction+0xbc>
     156:	ba 01       	movw	r22, r20
     158:	62 2b       	or	r22, r18
     15a:	64 bb       	out	0x14, r22	; 20
     15c:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_DDRC,pinnumber);
     15e:	24 b3       	in	r18, 0x14	; 20
     160:	81 e0       	ldi	r24, 0x01	; 1
     162:	90 e0       	ldi	r25, 0x00	; 0
     164:	ac 01       	movw	r20, r24
     166:	02 c0       	rjmp	.+4      	; 0x16c <DIO_vset_pin_direction+0xda>
     168:	44 0f       	add	r20, r20
     16a:	55 1f       	adc	r21, r21
     16c:	6a 95       	dec	r22
     16e:	e2 f7       	brpl	.-8      	; 0x168 <DIO_vset_pin_direction+0xd6>
     170:	ba 01       	movw	r22, r20
     172:	60 95       	com	r22
     174:	62 23       	and	r22, r18
     176:	64 bb       	out	0x14, r22	; 20
     178:	08 95       	ret
		}
		break;

		case 'D':
		case 'd':
		if (dirction == 1)
     17a:	41 30       	cpi	r20, 0x01	; 1
     17c:	69 f4       	brne	.+26     	; 0x198 <DIO_vset_pin_direction+0x106>
		{
			SET_BIT(MY_DDRD,pinnumber);
     17e:	21 b3       	in	r18, 0x11	; 17
     180:	81 e0       	ldi	r24, 0x01	; 1
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	ac 01       	movw	r20, r24
     186:	02 c0       	rjmp	.+4      	; 0x18c <DIO_vset_pin_direction+0xfa>
     188:	44 0f       	add	r20, r20
     18a:	55 1f       	adc	r21, r21
     18c:	6a 95       	dec	r22
     18e:	e2 f7       	brpl	.-8      	; 0x188 <DIO_vset_pin_direction+0xf6>
     190:	ba 01       	movw	r22, r20
     192:	62 2b       	or	r22, r18
     194:	61 bb       	out	0x11, r22	; 17
     196:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_DDRD,pinnumber);
     198:	21 b3       	in	r18, 0x11	; 17
     19a:	81 e0       	ldi	r24, 0x01	; 1
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	ac 01       	movw	r20, r24
     1a0:	02 c0       	rjmp	.+4      	; 0x1a6 <DIO_vset_pin_direction+0x114>
     1a2:	44 0f       	add	r20, r20
     1a4:	55 1f       	adc	r21, r21
     1a6:	6a 95       	dec	r22
     1a8:	e2 f7       	brpl	.-8      	; 0x1a2 <DIO_vset_pin_direction+0x110>
     1aa:	ba 01       	movw	r22, r20
     1ac:	60 95       	com	r22
     1ae:	62 23       	and	r22, r18
     1b0:	61 bb       	out	0x11, r22	; 17
     1b2:	08 95       	ret

000001b4 <DIO_vwrite_pin_value>:


/********* write_pin **************/
void DIO_vwrite_pin_value(char portname , char pinnumber , char val)
{
	switch(portname)
     1b4:	84 34       	cpi	r24, 0x44	; 68
     1b6:	09 f4       	brne	.+2      	; 0x1ba <DIO_vwrite_pin_value+0x6>
     1b8:	71 c0       	rjmp	.+226    	; 0x29c <DIO_vwrite_pin_value+0xe8>
     1ba:	85 34       	cpi	r24, 0x45	; 69
     1bc:	48 f4       	brcc	.+18     	; 0x1d0 <DIO_vwrite_pin_value+0x1c>
     1be:	82 34       	cpi	r24, 0x42	; 66
     1c0:	99 f1       	breq	.+102    	; 0x228 <DIO_vwrite_pin_value+0x74>
     1c2:	83 34       	cpi	r24, 0x43	; 67
     1c4:	08 f0       	brcs	.+2      	; 0x1c8 <DIO_vwrite_pin_value+0x14>
     1c6:	4d c0       	rjmp	.+154    	; 0x262 <DIO_vwrite_pin_value+0xae>
     1c8:	81 34       	cpi	r24, 0x41	; 65
     1ca:	09 f0       	breq	.+2      	; 0x1ce <DIO_vwrite_pin_value+0x1a>
     1cc:	83 c0       	rjmp	.+262    	; 0x2d4 <DIO_vwrite_pin_value+0x120>
     1ce:	0f c0       	rjmp	.+30     	; 0x1ee <DIO_vwrite_pin_value+0x3a>
     1d0:	82 36       	cpi	r24, 0x62	; 98
     1d2:	51 f1       	breq	.+84     	; 0x228 <DIO_vwrite_pin_value+0x74>
     1d4:	83 36       	cpi	r24, 0x63	; 99
     1d6:	20 f4       	brcc	.+8      	; 0x1e0 <DIO_vwrite_pin_value+0x2c>
     1d8:	81 36       	cpi	r24, 0x61	; 97
     1da:	09 f0       	breq	.+2      	; 0x1de <DIO_vwrite_pin_value+0x2a>
     1dc:	7b c0       	rjmp	.+246    	; 0x2d4 <DIO_vwrite_pin_value+0x120>
     1de:	07 c0       	rjmp	.+14     	; 0x1ee <DIO_vwrite_pin_value+0x3a>
     1e0:	83 36       	cpi	r24, 0x63	; 99
     1e2:	09 f4       	brne	.+2      	; 0x1e6 <DIO_vwrite_pin_value+0x32>
     1e4:	3e c0       	rjmp	.+124    	; 0x262 <DIO_vwrite_pin_value+0xae>
     1e6:	84 36       	cpi	r24, 0x64	; 100
     1e8:	09 f0       	breq	.+2      	; 0x1ec <DIO_vwrite_pin_value+0x38>
     1ea:	74 c0       	rjmp	.+232    	; 0x2d4 <DIO_vwrite_pin_value+0x120>
     1ec:	57 c0       	rjmp	.+174    	; 0x29c <DIO_vwrite_pin_value+0xe8>
	{
		case 'A':
		case 'a':
		if (val == 1)
     1ee:	41 30       	cpi	r20, 0x01	; 1
     1f0:	69 f4       	brne	.+26     	; 0x20c <DIO_vwrite_pin_value+0x58>
		{
			SET_BIT(MY_PORTA,pinnumber);
     1f2:	2b b3       	in	r18, 0x1b	; 27
     1f4:	81 e0       	ldi	r24, 0x01	; 1
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	ac 01       	movw	r20, r24
     1fa:	02 c0       	rjmp	.+4      	; 0x200 <DIO_vwrite_pin_value+0x4c>
     1fc:	44 0f       	add	r20, r20
     1fe:	55 1f       	adc	r21, r21
     200:	6a 95       	dec	r22
     202:	e2 f7       	brpl	.-8      	; 0x1fc <DIO_vwrite_pin_value+0x48>
     204:	ba 01       	movw	r22, r20
     206:	62 2b       	or	r22, r18
     208:	6b bb       	out	0x1b, r22	; 27
     20a:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_PORTA,pinnumber);
     20c:	2b b3       	in	r18, 0x1b	; 27
     20e:	81 e0       	ldi	r24, 0x01	; 1
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	ac 01       	movw	r20, r24
     214:	02 c0       	rjmp	.+4      	; 0x21a <DIO_vwrite_pin_value+0x66>
     216:	44 0f       	add	r20, r20
     218:	55 1f       	adc	r21, r21
     21a:	6a 95       	dec	r22
     21c:	e2 f7       	brpl	.-8      	; 0x216 <DIO_vwrite_pin_value+0x62>
     21e:	ba 01       	movw	r22, r20
     220:	60 95       	com	r22
     222:	62 23       	and	r22, r18
     224:	6b bb       	out	0x1b, r22	; 27
     226:	08 95       	ret
		}
		break;

		case 'B':
		case 'b':
		if (val == 1)
     228:	41 30       	cpi	r20, 0x01	; 1
     22a:	69 f4       	brne	.+26     	; 0x246 <DIO_vwrite_pin_value+0x92>
		{
			SET_BIT(MY_PORTB,pinnumber);
     22c:	28 b3       	in	r18, 0x18	; 24
     22e:	81 e0       	ldi	r24, 0x01	; 1
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	ac 01       	movw	r20, r24
     234:	02 c0       	rjmp	.+4      	; 0x23a <DIO_vwrite_pin_value+0x86>
     236:	44 0f       	add	r20, r20
     238:	55 1f       	adc	r21, r21
     23a:	6a 95       	dec	r22
     23c:	e2 f7       	brpl	.-8      	; 0x236 <DIO_vwrite_pin_value+0x82>
     23e:	ba 01       	movw	r22, r20
     240:	62 2b       	or	r22, r18
     242:	68 bb       	out	0x18, r22	; 24
     244:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_PORTB,pinnumber);
     246:	28 b3       	in	r18, 0x18	; 24
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	ac 01       	movw	r20, r24
     24e:	02 c0       	rjmp	.+4      	; 0x254 <DIO_vwrite_pin_value+0xa0>
     250:	44 0f       	add	r20, r20
     252:	55 1f       	adc	r21, r21
     254:	6a 95       	dec	r22
     256:	e2 f7       	brpl	.-8      	; 0x250 <DIO_vwrite_pin_value+0x9c>
     258:	ba 01       	movw	r22, r20
     25a:	60 95       	com	r22
     25c:	62 23       	and	r22, r18
     25e:	68 bb       	out	0x18, r22	; 24
     260:	08 95       	ret
		}
		break;

		case 'C':
		case 'c':
		if (val == 1)
     262:	41 30       	cpi	r20, 0x01	; 1
     264:	69 f4       	brne	.+26     	; 0x280 <DIO_vwrite_pin_value+0xcc>
		{
			SET_BIT(MY_PORTC,pinnumber);
     266:	25 b3       	in	r18, 0x15	; 21
     268:	81 e0       	ldi	r24, 0x01	; 1
     26a:	90 e0       	ldi	r25, 0x00	; 0
     26c:	ac 01       	movw	r20, r24
     26e:	02 c0       	rjmp	.+4      	; 0x274 <DIO_vwrite_pin_value+0xc0>
     270:	44 0f       	add	r20, r20
     272:	55 1f       	adc	r21, r21
     274:	6a 95       	dec	r22
     276:	e2 f7       	brpl	.-8      	; 0x270 <DIO_vwrite_pin_value+0xbc>
     278:	ba 01       	movw	r22, r20
     27a:	62 2b       	or	r22, r18
     27c:	65 bb       	out	0x15, r22	; 21
     27e:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_PORTC,pinnumber);
     280:	25 b3       	in	r18, 0x15	; 21
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	ac 01       	movw	r20, r24
     288:	02 c0       	rjmp	.+4      	; 0x28e <DIO_vwrite_pin_value+0xda>
     28a:	44 0f       	add	r20, r20
     28c:	55 1f       	adc	r21, r21
     28e:	6a 95       	dec	r22
     290:	e2 f7       	brpl	.-8      	; 0x28a <DIO_vwrite_pin_value+0xd6>
     292:	ba 01       	movw	r22, r20
     294:	60 95       	com	r22
     296:	62 23       	and	r22, r18
     298:	65 bb       	out	0x15, r22	; 21
     29a:	08 95       	ret
		}
		break;

		case 'D':
		case 'd':
		if (val == 1)
     29c:	41 30       	cpi	r20, 0x01	; 1
     29e:	69 f4       	brne	.+26     	; 0x2ba <DIO_vwrite_pin_value+0x106>
		{
			SET_BIT(MY_PORTD,pinnumber);
     2a0:	22 b3       	in	r18, 0x12	; 18
     2a2:	81 e0       	ldi	r24, 0x01	; 1
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	ac 01       	movw	r20, r24
     2a8:	02 c0       	rjmp	.+4      	; 0x2ae <DIO_vwrite_pin_value+0xfa>
     2aa:	44 0f       	add	r20, r20
     2ac:	55 1f       	adc	r21, r21
     2ae:	6a 95       	dec	r22
     2b0:	e2 f7       	brpl	.-8      	; 0x2aa <DIO_vwrite_pin_value+0xf6>
     2b2:	ba 01       	movw	r22, r20
     2b4:	62 2b       	or	r22, r18
     2b6:	62 bb       	out	0x12, r22	; 18
     2b8:	08 95       	ret
		}
		else
		{
			CLR_BIT(MY_PORTD,pinnumber);
     2ba:	22 b3       	in	r18, 0x12	; 18
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	ac 01       	movw	r20, r24
     2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_vwrite_pin_value+0x114>
     2c4:	44 0f       	add	r20, r20
     2c6:	55 1f       	adc	r21, r21
     2c8:	6a 95       	dec	r22
     2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_vwrite_pin_value+0x110>
     2cc:	ba 01       	movw	r22, r20
     2ce:	60 95       	com	r22
     2d0:	62 23       	and	r22, r18
     2d2:	62 bb       	out	0x12, r22	; 18
     2d4:	08 95       	ret

000002d6 <DIO_vtoggle_pin>:


/********* toggle_pin **************/
void DIO_vtoggle_pin(char portname , char pinnumber)
{
	switch(portname)
     2d6:	84 34       	cpi	r24, 0x44	; 68
     2d8:	09 f4       	brne	.+2      	; 0x2dc <DIO_vtoggle_pin+0x6>
     2da:	3d c0       	rjmp	.+122    	; 0x356 <DIO_vtoggle_pin+0x80>
     2dc:	85 34       	cpi	r24, 0x45	; 69
     2de:	40 f4       	brcc	.+16     	; 0x2f0 <DIO_vtoggle_pin+0x1a>
     2e0:	82 34       	cpi	r24, 0x42	; 66
     2e2:	f9 f0       	breq	.+62     	; 0x322 <DIO_vtoggle_pin+0x4c>
     2e4:	83 34       	cpi	r24, 0x43	; 67
     2e6:	50 f5       	brcc	.+84     	; 0x33c <DIO_vtoggle_pin+0x66>
     2e8:	81 34       	cpi	r24, 0x41	; 65
     2ea:	09 f0       	breq	.+2      	; 0x2ee <DIO_vtoggle_pin+0x18>
     2ec:	40 c0       	rjmp	.+128    	; 0x36e <DIO_vtoggle_pin+0x98>
     2ee:	0c c0       	rjmp	.+24     	; 0x308 <DIO_vtoggle_pin+0x32>
     2f0:	82 36       	cpi	r24, 0x62	; 98
     2f2:	b9 f0       	breq	.+46     	; 0x322 <DIO_vtoggle_pin+0x4c>
     2f4:	83 36       	cpi	r24, 0x63	; 99
     2f6:	18 f4       	brcc	.+6      	; 0x2fe <DIO_vtoggle_pin+0x28>
     2f8:	81 36       	cpi	r24, 0x61	; 97
     2fa:	c9 f5       	brne	.+114    	; 0x36e <DIO_vtoggle_pin+0x98>
     2fc:	05 c0       	rjmp	.+10     	; 0x308 <DIO_vtoggle_pin+0x32>
     2fe:	83 36       	cpi	r24, 0x63	; 99
     300:	e9 f0       	breq	.+58     	; 0x33c <DIO_vtoggle_pin+0x66>
     302:	84 36       	cpi	r24, 0x64	; 100
     304:	a1 f5       	brne	.+104    	; 0x36e <DIO_vtoggle_pin+0x98>
     306:	27 c0       	rjmp	.+78     	; 0x356 <DIO_vtoggle_pin+0x80>
	{
		case 'A':
		case 'a':
		TOG_BIT(MY_PORTA,pinnumber);
     308:	2b b3       	in	r18, 0x1b	; 27
     30a:	81 e0       	ldi	r24, 0x01	; 1
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	ac 01       	movw	r20, r24
     310:	02 c0       	rjmp	.+4      	; 0x316 <DIO_vtoggle_pin+0x40>
     312:	44 0f       	add	r20, r20
     314:	55 1f       	adc	r21, r21
     316:	6a 95       	dec	r22
     318:	e2 f7       	brpl	.-8      	; 0x312 <DIO_vtoggle_pin+0x3c>
     31a:	ba 01       	movw	r22, r20
     31c:	62 27       	eor	r22, r18
     31e:	6b bb       	out	0x1b, r22	; 27
		break;
     320:	08 95       	ret

		case 'B':
		case 'b':
		TOG_BIT(MY_PORTB,pinnumber);
     322:	28 b3       	in	r18, 0x18	; 24
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	ac 01       	movw	r20, r24
     32a:	02 c0       	rjmp	.+4      	; 0x330 <DIO_vtoggle_pin+0x5a>
     32c:	44 0f       	add	r20, r20
     32e:	55 1f       	adc	r21, r21
     330:	6a 95       	dec	r22
     332:	e2 f7       	brpl	.-8      	; 0x32c <DIO_vtoggle_pin+0x56>
     334:	ba 01       	movw	r22, r20
     336:	62 27       	eor	r22, r18
     338:	68 bb       	out	0x18, r22	; 24
		break;
     33a:	08 95       	ret

		case 'C':
		case 'c':
		TOG_BIT(MY_PORTC,pinnumber);
     33c:	25 b3       	in	r18, 0x15	; 21
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	ac 01       	movw	r20, r24
     344:	02 c0       	rjmp	.+4      	; 0x34a <DIO_vtoggle_pin+0x74>
     346:	44 0f       	add	r20, r20
     348:	55 1f       	adc	r21, r21
     34a:	6a 95       	dec	r22
     34c:	e2 f7       	brpl	.-8      	; 0x346 <DIO_vtoggle_pin+0x70>
     34e:	ba 01       	movw	r22, r20
     350:	62 27       	eor	r22, r18
     352:	65 bb       	out	0x15, r22	; 21
		break;
     354:	08 95       	ret

		case 'D':
		case 'd':
		TOG_BIT(MY_PORTD,pinnumber);
     356:	22 b3       	in	r18, 0x12	; 18
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	ac 01       	movw	r20, r24
     35e:	02 c0       	rjmp	.+4      	; 0x364 <DIO_vtoggle_pin+0x8e>
     360:	44 0f       	add	r20, r20
     362:	55 1f       	adc	r21, r21
     364:	6a 95       	dec	r22
     366:	e2 f7       	brpl	.-8      	; 0x360 <DIO_vtoggle_pin+0x8a>
     368:	ba 01       	movw	r22, r20
     36a:	62 27       	eor	r22, r18
     36c:	62 bb       	out	0x12, r22	; 18
     36e:	08 95       	ret

00000370 <DIO_u8read_pin>:

/********* read_pin **************/
unsigned char DIO_u8read_pin (char portname , char pinnumber)
{
	unsigned char ret_value;
	switch (portname)
     370:	84 34       	cpi	r24, 0x44	; 68
     372:	09 f4       	brne	.+2      	; 0x376 <DIO_u8read_pin+0x6>
     374:	51 c0       	rjmp	.+162    	; 0x418 <DIO_u8read_pin+0xa8>
     376:	85 34       	cpi	r24, 0x45	; 69
     378:	40 f4       	brcc	.+16     	; 0x38a <DIO_u8read_pin+0x1a>
     37a:	82 34       	cpi	r24, 0x42	; 66
     37c:	39 f1       	breq	.+78     	; 0x3cc <DIO_u8read_pin+0x5c>
     37e:	83 34       	cpi	r24, 0x43	; 67
     380:	c0 f5       	brcc	.+112    	; 0x3f2 <DIO_u8read_pin+0x82>
     382:	81 34       	cpi	r24, 0x41	; 65
     384:	09 f0       	breq	.+2      	; 0x388 <DIO_u8read_pin+0x18>
     386:	5a c0       	rjmp	.+180    	; 0x43c <DIO_u8read_pin+0xcc>
     388:	0e c0       	rjmp	.+28     	; 0x3a6 <DIO_u8read_pin+0x36>
     38a:	82 36       	cpi	r24, 0x62	; 98
     38c:	f9 f0       	breq	.+62     	; 0x3cc <DIO_u8read_pin+0x5c>
     38e:	83 36       	cpi	r24, 0x63	; 99
     390:	20 f4       	brcc	.+8      	; 0x39a <DIO_u8read_pin+0x2a>
     392:	81 36       	cpi	r24, 0x61	; 97
     394:	09 f0       	breq	.+2      	; 0x398 <DIO_u8read_pin+0x28>
     396:	52 c0       	rjmp	.+164    	; 0x43c <DIO_u8read_pin+0xcc>
     398:	06 c0       	rjmp	.+12     	; 0x3a6 <DIO_u8read_pin+0x36>
     39a:	83 36       	cpi	r24, 0x63	; 99
     39c:	51 f1       	breq	.+84     	; 0x3f2 <DIO_u8read_pin+0x82>
     39e:	84 36       	cpi	r24, 0x64	; 100
     3a0:	09 f0       	breq	.+2      	; 0x3a4 <DIO_u8read_pin+0x34>
     3a2:	4c c0       	rjmp	.+152    	; 0x43c <DIO_u8read_pin+0xcc>
     3a4:	39 c0       	rjmp	.+114    	; 0x418 <DIO_u8read_pin+0xa8>
	{
		case 'A':
		case 'a':
		ret_value = READ_BIT(MY_PINA,pinnumber);
     3a6:	29 b3       	in	r18, 0x19	; 25
     3a8:	81 e0       	ldi	r24, 0x01	; 1
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	06 2e       	mov	r0, r22
     3ae:	02 c0       	rjmp	.+4      	; 0x3b4 <DIO_u8read_pin+0x44>
     3b0:	88 0f       	add	r24, r24
     3b2:	99 1f       	adc	r25, r25
     3b4:	0a 94       	dec	r0
     3b6:	e2 f7       	brpl	.-8      	; 0x3b0 <DIO_u8read_pin+0x40>
     3b8:	30 e0       	ldi	r19, 0x00	; 0
     3ba:	82 23       	and	r24, r18
     3bc:	93 23       	and	r25, r19
     3be:	02 c0       	rjmp	.+4      	; 0x3c4 <DIO_u8read_pin+0x54>
     3c0:	95 95       	asr	r25
     3c2:	87 95       	ror	r24
     3c4:	6a 95       	dec	r22
     3c6:	e2 f7       	brpl	.-8      	; 0x3c0 <DIO_u8read_pin+0x50>
     3c8:	98 2f       	mov	r25, r24
		break;
     3ca:	38 c0       	rjmp	.+112    	; 0x43c <DIO_u8read_pin+0xcc>

		case 'B':
		case 'b':
		ret_value = READ_BIT(MY_PINB,pinnumber);
     3cc:	26 b3       	in	r18, 0x16	; 22
     3ce:	81 e0       	ldi	r24, 0x01	; 1
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	06 2e       	mov	r0, r22
     3d4:	02 c0       	rjmp	.+4      	; 0x3da <DIO_u8read_pin+0x6a>
     3d6:	88 0f       	add	r24, r24
     3d8:	99 1f       	adc	r25, r25
     3da:	0a 94       	dec	r0
     3dc:	e2 f7       	brpl	.-8      	; 0x3d6 <DIO_u8read_pin+0x66>
     3de:	30 e0       	ldi	r19, 0x00	; 0
     3e0:	82 23       	and	r24, r18
     3e2:	93 23       	and	r25, r19
     3e4:	02 c0       	rjmp	.+4      	; 0x3ea <DIO_u8read_pin+0x7a>
     3e6:	95 95       	asr	r25
     3e8:	87 95       	ror	r24
     3ea:	6a 95       	dec	r22
     3ec:	e2 f7       	brpl	.-8      	; 0x3e6 <DIO_u8read_pin+0x76>
     3ee:	98 2f       	mov	r25, r24
		break;
     3f0:	25 c0       	rjmp	.+74     	; 0x43c <DIO_u8read_pin+0xcc>

		case 'C':
		case 'c':
		ret_value = READ_BIT(MY_PINC,pinnumber);
     3f2:	23 b3       	in	r18, 0x13	; 19
     3f4:	81 e0       	ldi	r24, 0x01	; 1
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	06 2e       	mov	r0, r22
     3fa:	02 c0       	rjmp	.+4      	; 0x400 <DIO_u8read_pin+0x90>
     3fc:	88 0f       	add	r24, r24
     3fe:	99 1f       	adc	r25, r25
     400:	0a 94       	dec	r0
     402:	e2 f7       	brpl	.-8      	; 0x3fc <DIO_u8read_pin+0x8c>
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	82 23       	and	r24, r18
     408:	93 23       	and	r25, r19
     40a:	02 c0       	rjmp	.+4      	; 0x410 <DIO_u8read_pin+0xa0>
     40c:	95 95       	asr	r25
     40e:	87 95       	ror	r24
     410:	6a 95       	dec	r22
     412:	e2 f7       	brpl	.-8      	; 0x40c <DIO_u8read_pin+0x9c>
     414:	98 2f       	mov	r25, r24
		break;
     416:	12 c0       	rjmp	.+36     	; 0x43c <DIO_u8read_pin+0xcc>

		case 'D':
		case 'd':
		ret_value = READ_BIT(MY_PIND,pinnumber);
     418:	20 b3       	in	r18, 0x10	; 16
     41a:	81 e0       	ldi	r24, 0x01	; 1
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	06 2e       	mov	r0, r22
     420:	02 c0       	rjmp	.+4      	; 0x426 <DIO_u8read_pin+0xb6>
     422:	88 0f       	add	r24, r24
     424:	99 1f       	adc	r25, r25
     426:	0a 94       	dec	r0
     428:	e2 f7       	brpl	.-8      	; 0x422 <DIO_u8read_pin+0xb2>
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	82 23       	and	r24, r18
     42e:	93 23       	and	r25, r19
     430:	02 c0       	rjmp	.+4      	; 0x436 <DIO_u8read_pin+0xc6>
     432:	95 95       	asr	r25
     434:	87 95       	ror	r24
     436:	6a 95       	dec	r22
     438:	e2 f7       	brpl	.-8      	; 0x432 <DIO_u8read_pin+0xc2>
     43a:	98 2f       	mov	r25, r24
		break;
	}
	return ret_value;
}
     43c:	89 2f       	mov	r24, r25
     43e:	08 95       	ret

00000440 <DIO_vset_port_direction>:


/********* dirction_port **************/
void DIO_vset_port_direction(char portname , char direction)
{
	switch(portname)
     440:	84 34       	cpi	r24, 0x44	; 68
     442:	d9 f0       	breq	.+54     	; 0x47a <DIO_vset_port_direction+0x3a>
     444:	85 34       	cpi	r24, 0x45	; 69
     446:	38 f4       	brcc	.+14     	; 0x456 <DIO_vset_port_direction+0x16>
     448:	82 34       	cpi	r24, 0x42	; 66
     44a:	99 f0       	breq	.+38     	; 0x472 <DIO_vset_port_direction+0x32>
     44c:	83 34       	cpi	r24, 0x43	; 67
     44e:	98 f4       	brcc	.+38     	; 0x476 <DIO_vset_port_direction+0x36>
     450:	81 34       	cpi	r24, 0x41	; 65
     452:	a1 f4       	brne	.+40     	; 0x47c <DIO_vset_port_direction+0x3c>
     454:	0c c0       	rjmp	.+24     	; 0x46e <DIO_vset_port_direction+0x2e>
     456:	82 36       	cpi	r24, 0x62	; 98
     458:	61 f0       	breq	.+24     	; 0x472 <DIO_vset_port_direction+0x32>
     45a:	83 36       	cpi	r24, 0x63	; 99
     45c:	18 f4       	brcc	.+6      	; 0x464 <DIO_vset_port_direction+0x24>
     45e:	81 36       	cpi	r24, 0x61	; 97
     460:	69 f4       	brne	.+26     	; 0x47c <DIO_vset_port_direction+0x3c>
     462:	05 c0       	rjmp	.+10     	; 0x46e <DIO_vset_port_direction+0x2e>
     464:	83 36       	cpi	r24, 0x63	; 99
     466:	39 f0       	breq	.+14     	; 0x476 <DIO_vset_port_direction+0x36>
     468:	84 36       	cpi	r24, 0x64	; 100
     46a:	41 f4       	brne	.+16     	; 0x47c <DIO_vset_port_direction+0x3c>
     46c:	06 c0       	rjmp	.+12     	; 0x47a <DIO_vset_port_direction+0x3a>
	{
		case 'A':
		case 'a':
		MY_DDRA = direction;
     46e:	6a bb       	out	0x1a, r22	; 26
		break;
     470:	08 95       	ret

		case 'B':
		case 'b':
		MY_DDRB = direction;
     472:	67 bb       	out	0x17, r22	; 23
		break;
     474:	08 95       	ret

		case 'C':
		case 'c':
		MY_DDRC = direction;
     476:	64 bb       	out	0x14, r22	; 20
		break;
     478:	08 95       	ret

		case 'D':
		case 'd':
		MY_DDRD = direction;
     47a:	61 bb       	out	0x11, r22	; 17
     47c:	08 95       	ret

0000047e <DIO_vwrite_port_value>:
}

/********* write_port **************/
void DIO_vwrite_port_value(char portname , char value)
{
	switch(portname)
     47e:	84 34       	cpi	r24, 0x44	; 68
     480:	d9 f0       	breq	.+54     	; 0x4b8 <DIO_vwrite_port_value+0x3a>
     482:	85 34       	cpi	r24, 0x45	; 69
     484:	38 f4       	brcc	.+14     	; 0x494 <DIO_vwrite_port_value+0x16>
     486:	82 34       	cpi	r24, 0x42	; 66
     488:	99 f0       	breq	.+38     	; 0x4b0 <DIO_vwrite_port_value+0x32>
     48a:	83 34       	cpi	r24, 0x43	; 67
     48c:	98 f4       	brcc	.+38     	; 0x4b4 <DIO_vwrite_port_value+0x36>
     48e:	81 34       	cpi	r24, 0x41	; 65
     490:	a1 f4       	brne	.+40     	; 0x4ba <DIO_vwrite_port_value+0x3c>
     492:	0c c0       	rjmp	.+24     	; 0x4ac <DIO_vwrite_port_value+0x2e>
     494:	82 36       	cpi	r24, 0x62	; 98
     496:	61 f0       	breq	.+24     	; 0x4b0 <DIO_vwrite_port_value+0x32>
     498:	83 36       	cpi	r24, 0x63	; 99
     49a:	18 f4       	brcc	.+6      	; 0x4a2 <DIO_vwrite_port_value+0x24>
     49c:	81 36       	cpi	r24, 0x61	; 97
     49e:	69 f4       	brne	.+26     	; 0x4ba <DIO_vwrite_port_value+0x3c>
     4a0:	05 c0       	rjmp	.+10     	; 0x4ac <DIO_vwrite_port_value+0x2e>
     4a2:	83 36       	cpi	r24, 0x63	; 99
     4a4:	39 f0       	breq	.+14     	; 0x4b4 <DIO_vwrite_port_value+0x36>
     4a6:	84 36       	cpi	r24, 0x64	; 100
     4a8:	41 f4       	brne	.+16     	; 0x4ba <DIO_vwrite_port_value+0x3c>
     4aa:	06 c0       	rjmp	.+12     	; 0x4b8 <DIO_vwrite_port_value+0x3a>
	{
		case 'A':
		case 'a':
		MY_PORTA = value;
     4ac:	6b bb       	out	0x1b, r22	; 27
		break;
     4ae:	08 95       	ret

		case 'B':
		case 'b':
		MY_PORTB = value;
     4b0:	68 bb       	out	0x18, r22	; 24
		break;
     4b2:	08 95       	ret

		case 'C':
		case 'c':
		MY_PORTC = value;
     4b4:	65 bb       	out	0x15, r22	; 21
		break;
     4b6:	08 95       	ret

		case 'D':
		case 'd':
		MY_PORTD = value;
     4b8:	62 bb       	out	0x12, r22	; 18
     4ba:	08 95       	ret

000004bc <DIO_vtoggle_port>:
}

/********* toggle_port **************/
void DIO_vtoggle_port(char portname)
{
	switch(portname)
     4bc:	84 34       	cpi	r24, 0x44	; 68
     4be:	09 f1       	breq	.+66     	; 0x502 <DIO_vtoggle_port+0x46>
     4c0:	85 34       	cpi	r24, 0x45	; 69
     4c2:	38 f4       	brcc	.+14     	; 0x4d2 <DIO_vtoggle_port+0x16>
     4c4:	82 34       	cpi	r24, 0x42	; 66
     4c6:	a9 f0       	breq	.+42     	; 0x4f2 <DIO_vtoggle_port+0x36>
     4c8:	83 34       	cpi	r24, 0x43	; 67
     4ca:	b8 f4       	brcc	.+46     	; 0x4fa <DIO_vtoggle_port+0x3e>
     4cc:	81 34       	cpi	r24, 0x41	; 65
     4ce:	e1 f4       	brne	.+56     	; 0x508 <DIO_vtoggle_port+0x4c>
     4d0:	0c c0       	rjmp	.+24     	; 0x4ea <DIO_vtoggle_port+0x2e>
     4d2:	82 36       	cpi	r24, 0x62	; 98
     4d4:	71 f0       	breq	.+28     	; 0x4f2 <DIO_vtoggle_port+0x36>
     4d6:	83 36       	cpi	r24, 0x63	; 99
     4d8:	18 f4       	brcc	.+6      	; 0x4e0 <DIO_vtoggle_port+0x24>
     4da:	81 36       	cpi	r24, 0x61	; 97
     4dc:	a9 f4       	brne	.+42     	; 0x508 <DIO_vtoggle_port+0x4c>
     4de:	05 c0       	rjmp	.+10     	; 0x4ea <DIO_vtoggle_port+0x2e>
     4e0:	83 36       	cpi	r24, 0x63	; 99
     4e2:	59 f0       	breq	.+22     	; 0x4fa <DIO_vtoggle_port+0x3e>
     4e4:	84 36       	cpi	r24, 0x64	; 100
     4e6:	81 f4       	brne	.+32     	; 0x508 <DIO_vtoggle_port+0x4c>
     4e8:	0c c0       	rjmp	.+24     	; 0x502 <DIO_vtoggle_port+0x46>
	{
		case 'A':
		case 'a':
		MY_PORTA = ~MY_PORTA;
     4ea:	8b b3       	in	r24, 0x1b	; 27
     4ec:	80 95       	com	r24
     4ee:	8b bb       	out	0x1b, r24	; 27
		break;
     4f0:	08 95       	ret

		case 'B':
		case 'b':
		MY_PORTB = ~MY_PORTB;
     4f2:	88 b3       	in	r24, 0x18	; 24
     4f4:	80 95       	com	r24
     4f6:	88 bb       	out	0x18, r24	; 24
		break;
     4f8:	08 95       	ret

		case 'C':
		case 'c':
		MY_PORTC = ~MY_PORTC;
     4fa:	85 b3       	in	r24, 0x15	; 21
     4fc:	80 95       	com	r24
     4fe:	85 bb       	out	0x15, r24	; 21
		break;
     500:	08 95       	ret

		case 'D':
		case 'd':
		MY_PORTD = ~MY_PORTD;
     502:	82 b3       	in	r24, 0x12	; 18
     504:	80 95       	com	r24
     506:	82 bb       	out	0x12, r24	; 18
     508:	08 95       	ret

0000050a <DIO_u8read_port>:

/********* read_port **************/
unsigned char DIO_u8read_port(char portname)
{
	unsigned char read_value;
	switch(portname)
     50a:	84 34       	cpi	r24, 0x44	; 68
     50c:	d9 f0       	breq	.+54     	; 0x544 <DIO_u8read_port+0x3a>
     50e:	85 34       	cpi	r24, 0x45	; 69
     510:	38 f4       	brcc	.+14     	; 0x520 <DIO_u8read_port+0x16>
     512:	82 34       	cpi	r24, 0x42	; 66
     514:	99 f0       	breq	.+38     	; 0x53c <DIO_u8read_port+0x32>
     516:	83 34       	cpi	r24, 0x43	; 67
     518:	98 f4       	brcc	.+38     	; 0x540 <DIO_u8read_port+0x36>
     51a:	81 34       	cpi	r24, 0x41	; 65
     51c:	a1 f4       	brne	.+40     	; 0x546 <DIO_u8read_port+0x3c>
     51e:	0c c0       	rjmp	.+24     	; 0x538 <DIO_u8read_port+0x2e>
     520:	82 36       	cpi	r24, 0x62	; 98
     522:	61 f0       	breq	.+24     	; 0x53c <DIO_u8read_port+0x32>
     524:	83 36       	cpi	r24, 0x63	; 99
     526:	18 f4       	brcc	.+6      	; 0x52e <DIO_u8read_port+0x24>
     528:	81 36       	cpi	r24, 0x61	; 97
     52a:	69 f4       	brne	.+26     	; 0x546 <DIO_u8read_port+0x3c>
     52c:	05 c0       	rjmp	.+10     	; 0x538 <DIO_u8read_port+0x2e>
     52e:	83 36       	cpi	r24, 0x63	; 99
     530:	39 f0       	breq	.+14     	; 0x540 <DIO_u8read_port+0x36>
     532:	84 36       	cpi	r24, 0x64	; 100
     534:	41 f4       	brne	.+16     	; 0x546 <DIO_u8read_port+0x3c>
     536:	06 c0       	rjmp	.+12     	; 0x544 <DIO_u8read_port+0x3a>
	{
		case 'A':
		case 'a':
		read_value = MY_PINA;
     538:	99 b3       	in	r25, 0x19	; 25
		break;
     53a:	05 c0       	rjmp	.+10     	; 0x546 <DIO_u8read_port+0x3c>

		case 'B':
		case 'b':
		read_value = MY_PINB;
     53c:	96 b3       	in	r25, 0x16	; 22
		break;
     53e:	03 c0       	rjmp	.+6      	; 0x546 <DIO_u8read_port+0x3c>

		case 'C':
		case 'c':
		read_value = MY_PINC;
     540:	93 b3       	in	r25, 0x13	; 19
		break;
     542:	01 c0       	rjmp	.+2      	; 0x546 <DIO_u8read_port+0x3c>

		case 'D':
		case 'd':
		read_value = MY_PINC;
     544:	93 b3       	in	r25, 0x13	; 19
		break;
	}
	return read_value;
}
     546:	89 2f       	mov	r24, r25
     548:	08 95       	ret

0000054a <DIO_vinternal_pull_up_pin>:

/********* internal_pull up **************/
void DIO_vinternal_pull_up_pin(char portname , char pinnumber , char pud_enable)
{
	if (BIT_IS_CLR(MY_SFIOR,PUD))//check PUD(pull up disable pin is 0 (!0 true if) --> BIT_IS_CLR(MY_SFIOR,2)
     54a:	00 b6       	in	r0, 0x30	; 48
     54c:	02 fc       	sbrc	r0, 2
     54e:	90 c0       	rjmp	.+288    	; 0x670 <DIO_vinternal_pull_up_pin+0x126>
	{
		switch(portname)
     550:	84 34       	cpi	r24, 0x44	; 68
     552:	09 f4       	brne	.+2      	; 0x556 <DIO_vinternal_pull_up_pin+0xc>
     554:	71 c0       	rjmp	.+226    	; 0x638 <DIO_vinternal_pull_up_pin+0xee>
     556:	85 34       	cpi	r24, 0x45	; 69
     558:	48 f4       	brcc	.+18     	; 0x56c <DIO_vinternal_pull_up_pin+0x22>
     55a:	82 34       	cpi	r24, 0x42	; 66
     55c:	99 f1       	breq	.+102    	; 0x5c4 <DIO_vinternal_pull_up_pin+0x7a>
     55e:	83 34       	cpi	r24, 0x43	; 67
     560:	08 f0       	brcs	.+2      	; 0x564 <DIO_vinternal_pull_up_pin+0x1a>
     562:	4d c0       	rjmp	.+154    	; 0x5fe <DIO_vinternal_pull_up_pin+0xb4>
     564:	81 34       	cpi	r24, 0x41	; 65
     566:	09 f0       	breq	.+2      	; 0x56a <DIO_vinternal_pull_up_pin+0x20>
     568:	83 c0       	rjmp	.+262    	; 0x670 <DIO_vinternal_pull_up_pin+0x126>
     56a:	0f c0       	rjmp	.+30     	; 0x58a <DIO_vinternal_pull_up_pin+0x40>
     56c:	82 36       	cpi	r24, 0x62	; 98
     56e:	51 f1       	breq	.+84     	; 0x5c4 <DIO_vinternal_pull_up_pin+0x7a>
     570:	83 36       	cpi	r24, 0x63	; 99
     572:	20 f4       	brcc	.+8      	; 0x57c <DIO_vinternal_pull_up_pin+0x32>
     574:	81 36       	cpi	r24, 0x61	; 97
     576:	09 f0       	breq	.+2      	; 0x57a <DIO_vinternal_pull_up_pin+0x30>
     578:	7b c0       	rjmp	.+246    	; 0x670 <DIO_vinternal_pull_up_pin+0x126>
     57a:	07 c0       	rjmp	.+14     	; 0x58a <DIO_vinternal_pull_up_pin+0x40>
     57c:	83 36       	cpi	r24, 0x63	; 99
     57e:	09 f4       	brne	.+2      	; 0x582 <DIO_vinternal_pull_up_pin+0x38>
     580:	3e c0       	rjmp	.+124    	; 0x5fe <DIO_vinternal_pull_up_pin+0xb4>
     582:	84 36       	cpi	r24, 0x64	; 100
     584:	09 f0       	breq	.+2      	; 0x588 <DIO_vinternal_pull_up_pin+0x3e>
     586:	74 c0       	rjmp	.+232    	; 0x670 <DIO_vinternal_pull_up_pin+0x126>
     588:	57 c0       	rjmp	.+174    	; 0x638 <DIO_vinternal_pull_up_pin+0xee>
		{
			case 'A':
			case 'a':
			if (pud_enable == 1)
     58a:	41 30       	cpi	r20, 0x01	; 1
     58c:	69 f4       	brne	.+26     	; 0x5a8 <DIO_vinternal_pull_up_pin+0x5e>
			{
				SET_BIT(MY_PORTA,pinnumber);
     58e:	2b b3       	in	r18, 0x1b	; 27
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	ac 01       	movw	r20, r24
     596:	02 c0       	rjmp	.+4      	; 0x59c <DIO_vinternal_pull_up_pin+0x52>
     598:	44 0f       	add	r20, r20
     59a:	55 1f       	adc	r21, r21
     59c:	6a 95       	dec	r22
     59e:	e2 f7       	brpl	.-8      	; 0x598 <DIO_vinternal_pull_up_pin+0x4e>
     5a0:	ba 01       	movw	r22, r20
     5a2:	62 2b       	or	r22, r18
     5a4:	6b bb       	out	0x1b, r22	; 27
     5a6:	08 95       	ret
			}
			else
			{
				CLR_BIT(MY_PORTA,pinnumber);
     5a8:	2b b3       	in	r18, 0x1b	; 27
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	ac 01       	movw	r20, r24
     5b0:	02 c0       	rjmp	.+4      	; 0x5b6 <DIO_vinternal_pull_up_pin+0x6c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	6a 95       	dec	r22
     5b8:	e2 f7       	brpl	.-8      	; 0x5b2 <DIO_vinternal_pull_up_pin+0x68>
     5ba:	ba 01       	movw	r22, r20
     5bc:	60 95       	com	r22
     5be:	62 23       	and	r22, r18
     5c0:	6b bb       	out	0x1b, r22	; 27
     5c2:	08 95       	ret
			}
			break;

			case 'B':
			case 'b':
			if (pud_enable == 1)
     5c4:	41 30       	cpi	r20, 0x01	; 1
     5c6:	69 f4       	brne	.+26     	; 0x5e2 <DIO_vinternal_pull_up_pin+0x98>
			{
				SET_BIT(MY_PORTB,pinnumber);
     5c8:	28 b3       	in	r18, 0x18	; 24
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	ac 01       	movw	r20, r24
     5d0:	02 c0       	rjmp	.+4      	; 0x5d6 <DIO_vinternal_pull_up_pin+0x8c>
     5d2:	44 0f       	add	r20, r20
     5d4:	55 1f       	adc	r21, r21
     5d6:	6a 95       	dec	r22
     5d8:	e2 f7       	brpl	.-8      	; 0x5d2 <DIO_vinternal_pull_up_pin+0x88>
     5da:	ba 01       	movw	r22, r20
     5dc:	62 2b       	or	r22, r18
     5de:	68 bb       	out	0x18, r22	; 24
     5e0:	08 95       	ret
			}
			else
			{
				CLR_BIT(MY_PORTB,pinnumber);
     5e2:	28 b3       	in	r18, 0x18	; 24
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	90 e0       	ldi	r25, 0x00	; 0
     5e8:	ac 01       	movw	r20, r24
     5ea:	02 c0       	rjmp	.+4      	; 0x5f0 <DIO_vinternal_pull_up_pin+0xa6>
     5ec:	44 0f       	add	r20, r20
     5ee:	55 1f       	adc	r21, r21
     5f0:	6a 95       	dec	r22
     5f2:	e2 f7       	brpl	.-8      	; 0x5ec <DIO_vinternal_pull_up_pin+0xa2>
     5f4:	ba 01       	movw	r22, r20
     5f6:	60 95       	com	r22
     5f8:	62 23       	and	r22, r18
     5fa:	68 bb       	out	0x18, r22	; 24
     5fc:	08 95       	ret
			}
			break;

			case 'C':
			case 'c':
			if (pud_enable == 1)
     5fe:	41 30       	cpi	r20, 0x01	; 1
     600:	69 f4       	brne	.+26     	; 0x61c <DIO_vinternal_pull_up_pin+0xd2>
			{
				SET_BIT(MY_PORTC,pinnumber);
     602:	25 b3       	in	r18, 0x15	; 21
     604:	81 e0       	ldi	r24, 0x01	; 1
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	ac 01       	movw	r20, r24
     60a:	02 c0       	rjmp	.+4      	; 0x610 <DIO_vinternal_pull_up_pin+0xc6>
     60c:	44 0f       	add	r20, r20
     60e:	55 1f       	adc	r21, r21
     610:	6a 95       	dec	r22
     612:	e2 f7       	brpl	.-8      	; 0x60c <DIO_vinternal_pull_up_pin+0xc2>
     614:	ba 01       	movw	r22, r20
     616:	62 2b       	or	r22, r18
     618:	65 bb       	out	0x15, r22	; 21
     61a:	08 95       	ret
			}
			else
			{
				CLR_BIT(MY_PORTC,pinnumber);
     61c:	25 b3       	in	r18, 0x15	; 21
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	ac 01       	movw	r20, r24
     624:	02 c0       	rjmp	.+4      	; 0x62a <DIO_vinternal_pull_up_pin+0xe0>
     626:	44 0f       	add	r20, r20
     628:	55 1f       	adc	r21, r21
     62a:	6a 95       	dec	r22
     62c:	e2 f7       	brpl	.-8      	; 0x626 <DIO_vinternal_pull_up_pin+0xdc>
     62e:	ba 01       	movw	r22, r20
     630:	60 95       	com	r22
     632:	62 23       	and	r22, r18
     634:	65 bb       	out	0x15, r22	; 21
     636:	08 95       	ret
			}
			break;

			case 'D':
			case 'd':
			if (pud_enable == 1)
     638:	41 30       	cpi	r20, 0x01	; 1
     63a:	69 f4       	brne	.+26     	; 0x656 <DIO_vinternal_pull_up_pin+0x10c>
			{
				SET_BIT(MY_PORTD,pinnumber);
     63c:	22 b3       	in	r18, 0x12	; 18
     63e:	81 e0       	ldi	r24, 0x01	; 1
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	ac 01       	movw	r20, r24
     644:	02 c0       	rjmp	.+4      	; 0x64a <DIO_vinternal_pull_up_pin+0x100>
     646:	44 0f       	add	r20, r20
     648:	55 1f       	adc	r21, r21
     64a:	6a 95       	dec	r22
     64c:	e2 f7       	brpl	.-8      	; 0x646 <DIO_vinternal_pull_up_pin+0xfc>
     64e:	ba 01       	movw	r22, r20
     650:	62 2b       	or	r22, r18
     652:	62 bb       	out	0x12, r22	; 18
     654:	08 95       	ret
			}
			else
			{
				CLR_BIT(MY_PORTD,pinnumber);
     656:	22 b3       	in	r18, 0x12	; 18
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	ac 01       	movw	r20, r24
     65e:	02 c0       	rjmp	.+4      	; 0x664 <DIO_vinternal_pull_up_pin+0x11a>
     660:	44 0f       	add	r20, r20
     662:	55 1f       	adc	r21, r21
     664:	6a 95       	dec	r22
     666:	e2 f7       	brpl	.-8      	; 0x660 <DIO_vinternal_pull_up_pin+0x116>
     668:	ba 01       	movw	r22, r20
     66a:	60 95       	com	r22
     66c:	62 23       	and	r22, r18
     66e:	62 bb       	out	0x12, r22	; 18
     670:	08 95       	ret

00000672 <DIO_vlow_nibble_write>:
}


/************** low nibble **************/
void DIO_vlow_nibble_write (char portname , char val)
{
     672:	0f 93       	push	r16
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	c8 2f       	mov	r28, r24
     67a:	06 2f       	mov	r16, r22
	DIO_vwrite_pin_value(portname,0,READ_BIT(val,0));
     67c:	46 2f       	mov	r20, r22
     67e:	41 70       	andi	r20, 0x01	; 1
     680:	60 e0       	ldi	r22, 0x00	; 0
     682:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname,1,READ_BIT(val,1));
     686:	10 e0       	ldi	r17, 0x00	; 0
     688:	a8 01       	movw	r20, r16
     68a:	42 70       	andi	r20, 0x02	; 2
     68c:	50 70       	andi	r21, 0x00	; 0
     68e:	55 95       	asr	r21
     690:	47 95       	ror	r20
     692:	8c 2f       	mov	r24, r28
     694:	61 e0       	ldi	r22, 0x01	; 1
     696:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname,2,READ_BIT(val,2));
     69a:	a8 01       	movw	r20, r16
     69c:	44 70       	andi	r20, 0x04	; 4
     69e:	50 70       	andi	r21, 0x00	; 0
     6a0:	55 95       	asr	r21
     6a2:	47 95       	ror	r20
     6a4:	55 95       	asr	r21
     6a6:	47 95       	ror	r20
     6a8:	8c 2f       	mov	r24, r28
     6aa:	62 e0       	ldi	r22, 0x02	; 2
     6ac:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname,3,READ_BIT(val,3));
     6b0:	08 70       	andi	r16, 0x08	; 8
     6b2:	10 70       	andi	r17, 0x00	; 0
     6b4:	a8 01       	movw	r20, r16
     6b6:	55 95       	asr	r21
     6b8:	47 95       	ror	r20
     6ba:	55 95       	asr	r21
     6bc:	47 95       	ror	r20
     6be:	55 95       	asr	r21
     6c0:	47 95       	ror	r20
     6c2:	8c 2f       	mov	r24, r28
     6c4:	63 e0       	ldi	r22, 0x03	; 3
     6c6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
		MY_PORTD &= 0xf0;
		MY_PORTD |= val;
		break;
	}
	*/
}
     6ca:	cf 91       	pop	r28
     6cc:	1f 91       	pop	r17
     6ce:	0f 91       	pop	r16
     6d0:	08 95       	ret

000006d2 <DIO_vhigh_nibble_write>:

/************** high nibble **************/
void DIO_vhigh_nibble_write (char portname , char val) //val of BCD need least four bit  0x0__
{
     6d2:	0f 93       	push	r16
     6d4:	1f 93       	push	r17
     6d6:	cf 93       	push	r28
     6d8:	c8 2f       	mov	r28, r24
     6da:	06 2f       	mov	r16, r22
	DIO_vwrite_pin_value(portname,4,READ_BIT(val,0));
     6dc:	46 2f       	mov	r20, r22
     6de:	41 70       	andi	r20, 0x01	; 1
     6e0:	64 e0       	ldi	r22, 0x04	; 4
     6e2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname,5,READ_BIT(val,1));
     6e6:	10 e0       	ldi	r17, 0x00	; 0
     6e8:	a8 01       	movw	r20, r16
     6ea:	42 70       	andi	r20, 0x02	; 2
     6ec:	50 70       	andi	r21, 0x00	; 0
     6ee:	55 95       	asr	r21
     6f0:	47 95       	ror	r20
     6f2:	8c 2f       	mov	r24, r28
     6f4:	65 e0       	ldi	r22, 0x05	; 5
     6f6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname,6,READ_BIT(val,2));
     6fa:	a8 01       	movw	r20, r16
     6fc:	44 70       	andi	r20, 0x04	; 4
     6fe:	50 70       	andi	r21, 0x00	; 0
     700:	55 95       	asr	r21
     702:	47 95       	ror	r20
     704:	55 95       	asr	r21
     706:	47 95       	ror	r20
     708:	8c 2f       	mov	r24, r28
     70a:	66 e0       	ldi	r22, 0x06	; 6
     70c:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname,7,READ_BIT(val,3));
     710:	08 70       	andi	r16, 0x08	; 8
     712:	10 70       	andi	r17, 0x00	; 0
     714:	a8 01       	movw	r20, r16
     716:	55 95       	asr	r21
     718:	47 95       	ror	r20
     71a:	55 95       	asr	r21
     71c:	47 95       	ror	r20
     71e:	55 95       	asr	r21
     720:	47 95       	ror	r20
     722:	8c 2f       	mov	r24, r28
     724:	67 e0       	ldi	r22, 0x07	; 7
     726:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
		MY_PORTD &= 0xf0;
		MY_PORTD |= val;
		break;
	}
	*/
}
     72a:	cf 91       	pop	r28
     72c:	1f 91       	pop	r17
     72e:	0f 91       	pop	r16
     730:	08 95       	ret

00000732 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     732:	44 23       	and	r20, r20
     734:	41 f4       	brne	.+16     	; 0x746 <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     736:	68 23       	and	r22, r24
     738:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
     73a:	81 e0       	ldi	r24, 0x01	; 1
     73c:	61 15       	cp	r22, r1
     73e:	71 05       	cpc	r23, r1
     740:	51 f4       	brne	.+20     	; 0x756 <prvTestWaitCondition+0x24>
     742:	80 e0       	ldi	r24, 0x00	; 0
     744:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     746:	9b 01       	movw	r18, r22
     748:	28 23       	and	r18, r24
     74a:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	62 17       	cp	r22, r18
     750:	73 07       	cpc	r23, r19
     752:	09 f0       	breq	.+2      	; 0x756 <prvTestWaitCondition+0x24>
     754:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     756:	08 95       	ret

00000758 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     75c:	8b e0       	ldi	r24, 0x0B	; 11
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	0e 94 42 05 	call	0xa84	; 0xa84 <pvPortMalloc>
     764:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     766:	00 97       	sbiw	r24, 0x00	; 0
     768:	31 f0       	breq	.+12     	; 0x776 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     76a:	fc 01       	movw	r30, r24
     76c:	11 92       	st	Z+, r1
     76e:	11 92       	st	Z+, r1
     770:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     772:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     776:	8c 2f       	mov	r24, r28
     778:	9d 2f       	mov	r25, r29
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	08 95       	ret

00000780 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     780:	af 92       	push	r10
     782:	bf 92       	push	r11
     784:	cf 92       	push	r12
     786:	df 92       	push	r13
     788:	ef 92       	push	r14
     78a:	ff 92       	push	r15
     78c:	0f 93       	push	r16
     78e:	1f 93       	push	r17
     790:	cf 93       	push	r28
     792:	df 93       	push	r29
     794:	5c 01       	movw	r10, r24
     796:	6b 01       	movw	r12, r22
     798:	e4 2e       	mov	r14, r20
     79a:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     79c:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     7a0:	f5 01       	movw	r30, r10
     7a2:	c0 81       	ld	r28, Z
     7a4:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     7a6:	ce 01       	movw	r24, r28
     7a8:	b6 01       	movw	r22, r12
     7aa:	4f 2d       	mov	r20, r15
     7ac:	0e 94 99 03 	call	0x732	; 0x732 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     7b0:	88 23       	and	r24, r24
     7b2:	51 f0       	breq	.+20     	; 0x7c8 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     7b4:	ee 20       	and	r14, r14
     7b6:	01 f1       	breq	.+64     	; 0x7f8 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7b8:	c0 94       	com	r12
     7ba:	d0 94       	com	r13
     7bc:	cc 22       	and	r12, r28
     7be:	dd 22       	and	r13, r29
     7c0:	f5 01       	movw	r30, r10
     7c2:	d1 82       	std	Z+1, r13	; 0x01
     7c4:	c0 82       	st	Z, r12
     7c6:	18 c0       	rjmp	.+48     	; 0x7f8 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     7c8:	01 15       	cp	r16, r1
     7ca:	11 05       	cpc	r17, r1
     7cc:	a9 f0       	breq	.+42     	; 0x7f8 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     7ce:	ee 20       	and	r14, r14
     7d0:	19 f4       	brne	.+6      	; 0x7d8 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     7d2:	60 e0       	ldi	r22, 0x00	; 0
     7d4:	70 e0       	ldi	r23, 0x00	; 0
     7d6:	02 c0       	rjmp	.+4      	; 0x7dc <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     7d8:	60 e0       	ldi	r22, 0x00	; 0
     7da:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     7dc:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     7de:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     7e0:	6c 29       	or	r22, r12
     7e2:	7d 29       	or	r23, r13
     7e4:	c5 01       	movw	r24, r10
     7e6:	02 96       	adiw	r24, 0x02	; 2
     7e8:	a8 01       	movw	r20, r16
     7ea:	0e 94 42 12 	call	0x2484	; 0x2484 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     7ee:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     7f2:	88 23       	and	r24, r24
     7f4:	39 f4       	brne	.+14     	; 0x804 <xEventGroupWaitBits+0x84>
     7f6:	04 c0       	rjmp	.+8      	; 0x800 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     7f8:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
     7fc:	ce 01       	movw	r24, r28
     7fe:	21 c0       	rjmp	.+66     	; 0x842 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     800:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     804:	0e 94 c8 13 	call	0x2790	; 0x2790 <uxTaskResetEventItemValue>
     808:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     80a:	91 fd       	sbrc	r25, 1
     80c:	18 c0       	rjmp	.+48     	; 0x83e <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     814:	f5 01       	movw	r30, r10
     816:	c0 81       	ld	r28, Z
     818:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     81a:	ce 01       	movw	r24, r28
     81c:	b6 01       	movw	r22, r12
     81e:	4f 2d       	mov	r20, r15
     820:	0e 94 99 03 	call	0x732	; 0x732 <prvTestWaitCondition>
     824:	88 23       	and	r24, r24
     826:	49 f0       	breq	.+18     	; 0x83a <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     828:	ee 20       	and	r14, r14
     82a:	39 f0       	breq	.+14     	; 0x83a <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     82c:	c0 94       	com	r12
     82e:	d0 94       	com	r13
     830:	cc 22       	and	r12, r28
     832:	dd 22       	and	r13, r29
     834:	f5 01       	movw	r30, r10
     836:	d1 82       	std	Z+1, r13	; 0x01
     838:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     83a:	0f 90       	pop	r0
     83c:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     83e:	ce 01       	movw	r24, r28
     840:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     842:	df 91       	pop	r29
     844:	cf 91       	pop	r28
     846:	1f 91       	pop	r17
     848:	0f 91       	pop	r16
     84a:	ff 90       	pop	r15
     84c:	ef 90       	pop	r14
     84e:	df 90       	pop	r13
     850:	cf 90       	pop	r12
     852:	bf 90       	pop	r11
     854:	af 90       	pop	r10
     856:	08 95       	ret

00000858 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     858:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     85a:	0f b6       	in	r0, 0x3f	; 63
     85c:	f8 94       	cli
     85e:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     860:	80 81       	ld	r24, Z
     862:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     864:	60 95       	com	r22
     866:	70 95       	com	r23
     868:	68 23       	and	r22, r24
     86a:	79 23       	and	r23, r25
     86c:	71 83       	std	Z+1, r23	; 0x01
     86e:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     870:	0f 90       	pop	r0
     872:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     874:	08 95       	ret

00000876 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     876:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     878:	80 81       	ld	r24, Z
     87a:	91 81       	ldd	r25, Z+1	; 0x01
     87c:	08 95       	ret

0000087e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     87e:	af 92       	push	r10
     880:	bf 92       	push	r11
     882:	cf 92       	push	r12
     884:	df 92       	push	r13
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	0f 93       	push	r16
     88c:	1f 93       	push	r17
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	8c 01       	movw	r16, r24
     894:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     896:	0f 2e       	mov	r0, r31
     898:	f5 e0       	ldi	r31, 0x05	; 5
     89a:	cf 2e       	mov	r12, r31
     89c:	dd 24       	eor	r13, r13
     89e:	f0 2d       	mov	r31, r0
     8a0:	c8 0e       	add	r12, r24
     8a2:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     8a4:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     8a8:	d8 01       	movw	r26, r16
     8aa:	17 96       	adiw	r26, 0x07	; 7
     8ac:	ed 91       	ld	r30, X+
     8ae:	fc 91       	ld	r31, X
     8b0:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     8b2:	8d 91       	ld	r24, X+
     8b4:	9c 91       	ld	r25, X
     8b6:	11 97       	sbiw	r26, 0x01	; 1
     8b8:	8c 2b       	or	r24, r28
     8ba:	9d 2b       	or	r25, r29
     8bc:	11 96       	adiw	r26, 0x01	; 1
     8be:	9c 93       	st	X, r25
     8c0:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     8c2:	ce 16       	cp	r12, r30
     8c4:	df 06       	cpc	r13, r31
     8c6:	c1 f1       	breq	.+112    	; 0x938 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     8c8:	aa 24       	eor	r10, r10
     8ca:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     8cc:	ff 24       	eor	r15, r15
     8ce:	f3 94       	inc	r15
     8d0:	ee 24       	eor	r14, r14
     8d2:	01 c0       	rjmp	.+2      	; 0x8d6 <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     8d4:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     8d6:	c2 81       	ldd	r28, Z+2	; 0x02
     8d8:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     8da:	80 81       	ld	r24, Z
     8dc:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     8de:	bc 01       	movw	r22, r24
     8e0:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     8e2:	9c 01       	movw	r18, r24
     8e4:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     8e6:	92 fd       	sbrc	r25, 2
     8e8:	0b c0       	rjmp	.+22     	; 0x900 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     8ea:	d8 01       	movw	r26, r16
     8ec:	8d 91       	ld	r24, X+
     8ee:	9c 91       	ld	r25, X
     8f0:	11 97       	sbiw	r26, 0x01	; 1
     8f2:	82 23       	and	r24, r18
     8f4:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     8f6:	4f 2d       	mov	r20, r15
     8f8:	00 97       	sbiw	r24, 0x00	; 0
     8fa:	69 f4       	brne	.+26     	; 0x916 <xEventGroupSetBits+0x98>
     8fc:	4e 2d       	mov	r20, r14
     8fe:	0b c0       	rjmp	.+22     	; 0x916 <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     900:	d8 01       	movw	r26, r16
     902:	8d 91       	ld	r24, X+
     904:	9c 91       	ld	r25, X
     906:	11 97       	sbiw	r26, 0x01	; 1
     908:	82 23       	and	r24, r18
     90a:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     90c:	4f 2d       	mov	r20, r15
     90e:	28 17       	cp	r18, r24
     910:	39 07       	cpc	r19, r25
     912:	09 f0       	breq	.+2      	; 0x916 <xEventGroupSetBits+0x98>
     914:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     916:	44 23       	and	r20, r20
     918:	59 f0       	breq	.+22     	; 0x930 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     91a:	70 ff       	sbrs	r23, 0
     91c:	02 c0       	rjmp	.+4      	; 0x922 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     91e:	a2 2a       	or	r10, r18
     920:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     922:	d8 01       	movw	r26, r16
     924:	6d 91       	ld	r22, X+
     926:	7c 91       	ld	r23, X
     928:	72 60       	ori	r23, 0x02	; 2
     92a:	cf 01       	movw	r24, r30
     92c:	0e 94 a6 12 	call	0x254c	; 0x254c <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     930:	cc 16       	cp	r12, r28
     932:	dd 06       	cpc	r13, r29
     934:	79 f6       	brne	.-98     	; 0x8d4 <xEventGroupSetBits+0x56>
     936:	02 c0       	rjmp	.+4      	; 0x93c <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     938:	aa 24       	eor	r10, r10
     93a:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     93c:	c5 01       	movw	r24, r10
     93e:	80 95       	com	r24
     940:	90 95       	com	r25
     942:	f8 01       	movw	r30, r16
     944:	a0 80       	ld	r10, Z
     946:	b1 80       	ldd	r11, Z+1	; 0x01
     948:	a8 22       	and	r10, r24
     94a:	b9 22       	and	r11, r25
     94c:	b1 82       	std	Z+1, r11	; 0x01
     94e:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     950:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     954:	d8 01       	movw	r26, r16
     956:	8c 91       	ld	r24, X
     958:	11 96       	adiw	r26, 0x01	; 1
     95a:	9c 91       	ld	r25, X
     95c:	11 97       	sbiw	r26, 0x01	; 1
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	ff 90       	pop	r15
     968:	ef 90       	pop	r14
     96a:	df 90       	pop	r13
     96c:	cf 90       	pop	r12
     96e:	bf 90       	pop	r11
     970:	af 90       	pop	r10
     972:	08 95       	ret

00000974 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     974:	af 92       	push	r10
     976:	bf 92       	push	r11
     978:	cf 92       	push	r12
     97a:	df 92       	push	r13
     97c:	ef 92       	push	r14
     97e:	ff 92       	push	r15
     980:	0f 93       	push	r16
     982:	1f 93       	push	r17
     984:	cf 93       	push	r28
     986:	df 93       	push	r29
     988:	6c 01       	movw	r12, r24
     98a:	eb 01       	movw	r28, r22
     98c:	7a 01       	movw	r14, r20
     98e:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     990:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     994:	f6 01       	movw	r30, r12
     996:	00 81       	ld	r16, Z
     998:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     99a:	c6 01       	movw	r24, r12
     99c:	be 01       	movw	r22, r28
     99e:	0e 94 3f 04 	call	0x87e	; 0x87e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     9a2:	c0 2b       	or	r28, r16
     9a4:	d1 2b       	or	r29, r17
     9a6:	c7 01       	movw	r24, r14
     9a8:	8c 23       	and	r24, r28
     9aa:	9d 23       	and	r25, r29
     9ac:	8e 15       	cp	r24, r14
     9ae:	9f 05       	cpc	r25, r15
     9b0:	51 f4       	brne	.+20     	; 0x9c6 <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9b2:	80 95       	com	r24
     9b4:	90 95       	com	r25
     9b6:	f6 01       	movw	r30, r12
     9b8:	20 81       	ld	r18, Z
     9ba:	31 81       	ldd	r19, Z+1	; 0x01
     9bc:	82 23       	and	r24, r18
     9be:	93 23       	and	r25, r19
     9c0:	91 83       	std	Z+1, r25	; 0x01
     9c2:	80 83       	st	Z, r24
     9c4:	12 c0       	rjmp	.+36     	; 0x9ea <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     9c6:	a1 14       	cp	r10, r1
     9c8:	b1 04       	cpc	r11, r1
     9ca:	61 f0       	breq	.+24     	; 0x9e4 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     9cc:	b7 01       	movw	r22, r14
     9ce:	75 60       	ori	r23, 0x05	; 5
     9d0:	c6 01       	movw	r24, r12
     9d2:	02 96       	adiw	r24, 0x02	; 2
     9d4:	a5 01       	movw	r20, r10
     9d6:	0e 94 42 12 	call	0x2484	; 0x2484 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     9da:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     9de:	88 23       	and	r24, r24
     9e0:	49 f4       	brne	.+18     	; 0x9f4 <xEventGroupSync+0x80>
     9e2:	06 c0       	rjmp	.+12     	; 0x9f0 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     9e4:	f6 01       	movw	r30, r12
     9e6:	c0 81       	ld	r28, Z
     9e8:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     9ea:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
     9ee:	1c c0       	rjmp	.+56     	; 0xa28 <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     9f0:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     9f4:	0e 94 c8 13 	call	0x2790	; 0x2790 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     9f8:	91 fd       	sbrc	r25, 1
     9fa:	14 c0       	rjmp	.+40     	; 0xa24 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     9fc:	0f b6       	in	r0, 0x3f	; 63
     9fe:	f8 94       	cli
     a00:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     a02:	f6 01       	movw	r30, r12
     a04:	80 81       	ld	r24, Z
     a06:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     a08:	97 01       	movw	r18, r14
     a0a:	28 23       	and	r18, r24
     a0c:	39 23       	and	r19, r25
     a0e:	2e 15       	cp	r18, r14
     a10:	3f 05       	cpc	r19, r15
     a12:	31 f4       	brne	.+12     	; 0xa20 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a14:	20 95       	com	r18
     a16:	30 95       	com	r19
     a18:	28 23       	and	r18, r24
     a1a:	39 23       	and	r19, r25
     a1c:	31 83       	std	Z+1, r19	; 0x01
     a1e:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     a20:	0f 90       	pop	r0
     a22:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a24:	ec 01       	movw	r28, r24
     a26:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     a28:	8c 2f       	mov	r24, r28
     a2a:	9d 2f       	mov	r25, r29
     a2c:	df 91       	pop	r29
     a2e:	cf 91       	pop	r28
     a30:	1f 91       	pop	r17
     a32:	0f 91       	pop	r16
     a34:	ff 90       	pop	r15
     a36:	ef 90       	pop	r14
     a38:	df 90       	pop	r13
     a3a:	cf 90       	pop	r12
     a3c:	bf 90       	pop	r11
     a3e:	af 90       	pop	r10
     a40:	08 95       	ret

00000a42 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     a42:	cf 93       	push	r28
     a44:	df 93       	push	r29
     a46:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     a48:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     a4c:	8a 81       	ldd	r24, Y+2	; 0x02
     a4e:	88 23       	and	r24, r24
     a50:	49 f0       	breq	.+18     	; 0xa64 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     a52:	8f 81       	ldd	r24, Y+7	; 0x07
     a54:	98 85       	ldd	r25, Y+8	; 0x08
     a56:	60 e0       	ldi	r22, 0x00	; 0
     a58:	72 e0       	ldi	r23, 0x02	; 2
     a5a:	0e 94 a6 12 	call	0x254c	; 0x254c <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     a5e:	8a 81       	ldd	r24, Y+2	; 0x02
     a60:	88 23       	and	r24, r24
     a62:	b9 f7       	brne	.-18     	; 0xa52 <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     a64:	ce 01       	movw	r24, r28
     a66:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     a6a:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
}
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     a74:	ba 01       	movw	r22, r20
     a76:	0e 94 3f 04 	call	0x87e	; 0x87e <xEventGroupSetBits>
}
     a7a:	08 95       	ret

00000a7c <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     a7c:	ba 01       	movw	r22, r20
     a7e:	0e 94 2c 04 	call	0x858	; 0x858 <xEventGroupClearBits>
}
     a82:	08 95       	ret

00000a84 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     a8e:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     a92:	80 91 9c 00 	lds	r24, 0x009C
     a96:	88 23       	and	r24, r24
     a98:	f9 f4       	brne	.+62     	; 0xad8 <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     a9a:	86 ea       	ldi	r24, 0xA6	; 166
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	90 93 9e 00 	sts	0x009E, r25
     aa2:	80 93 9d 00 	sts	0x009D, r24
	xStart.xBlockSize = ( size_t ) 0;
     aa6:	10 92 a0 00 	sts	0x00A0, r1
     aaa:	10 92 9f 00 	sts	0x009F, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     aae:	8f e1       	ldi	r24, 0x1F	; 31
     ab0:	93 e0       	ldi	r25, 0x03	; 3
     ab2:	90 93 a4 00 	sts	0x00A4, r25
     ab6:	80 93 a3 00 	sts	0x00A3, r24
	xEnd.pxNextFreeBlock = NULL;
     aba:	e3 ea       	ldi	r30, 0xA3	; 163
     abc:	f0 e0       	ldi	r31, 0x00	; 0
     abe:	12 92       	st	-Z, r1
     ac0:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     ac2:	90 93 a9 00 	sts	0x00A9, r25
     ac6:	80 93 a8 00 	sts	0x00A8, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     aca:	f0 93 a7 00 	sts	0x00A7, r31
     ace:	e0 93 a6 00 	sts	0x00A6, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	80 93 9c 00 	sts	0x009C, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     ad8:	20 97       	sbiw	r28, 0x00	; 0
     ada:	09 f4       	brne	.+2      	; 0xade <pvPortMalloc+0x5a>
     adc:	62 c0       	rjmp	.+196    	; 0xba2 <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     ade:	9e 01       	movw	r18, r28
     ae0:	2c 5f       	subi	r18, 0xFC	; 252
     ae2:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     ae4:	23 96       	adiw	r28, 0x03	; 3
     ae6:	83 e0       	ldi	r24, 0x03	; 3
     ae8:	ce 31       	cpi	r28, 0x1E	; 30
     aea:	d8 07       	cpc	r29, r24
     aec:	08 f0       	brcs	.+2      	; 0xaf0 <pvPortMalloc+0x6c>
     aee:	5c c0       	rjmp	.+184    	; 0xba8 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     af0:	e0 91 9d 00 	lds	r30, 0x009D
     af4:	f0 91 9e 00 	lds	r31, 0x009E

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     af8:	ad e9       	ldi	r26, 0x9D	; 157
     afa:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <pvPortMalloc+0x7e>
     afe:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     b00:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     b02:	82 81       	ldd	r24, Z+2	; 0x02
     b04:	93 81       	ldd	r25, Z+3	; 0x03
     b06:	82 17       	cp	r24, r18
     b08:	93 07       	cpc	r25, r19
     b0a:	20 f4       	brcc	.+8      	; 0xb14 <pvPortMalloc+0x90>
     b0c:	80 81       	ld	r24, Z
     b0e:	91 81       	ldd	r25, Z+1	; 0x01
     b10:	00 97       	sbiw	r24, 0x00	; 0
     b12:	a9 f7       	brne	.-22     	; 0xafe <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     b14:	c0 e0       	ldi	r28, 0x00	; 0
     b16:	e1 3a       	cpi	r30, 0xA1	; 161
     b18:	fc 07       	cpc	r31, r28
     b1a:	09 f4       	brne	.+2      	; 0xb1e <pvPortMalloc+0x9a>
     b1c:	48 c0       	rjmp	.+144    	; 0xbae <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     b1e:	8d 91       	ld	r24, X+
     b20:	9c 91       	ld	r25, X
     b22:	11 97       	sbiw	r26, 0x01	; 1
     b24:	8c 01       	movw	r16, r24
     b26:	0c 5f       	subi	r16, 0xFC	; 252
     b28:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     b2a:	80 81       	ld	r24, Z
     b2c:	91 81       	ldd	r25, Z+1	; 0x01
     b2e:	11 96       	adiw	r26, 0x01	; 1
     b30:	9c 93       	st	X, r25
     b32:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     b34:	82 81       	ldd	r24, Z+2	; 0x02
     b36:	93 81       	ldd	r25, Z+3	; 0x03
     b38:	82 1b       	sub	r24, r18
     b3a:	93 0b       	sbc	r25, r19
     b3c:	89 30       	cpi	r24, 0x09	; 9
     b3e:	91 05       	cpc	r25, r1
     b40:	18 f1       	brcs	.+70     	; 0xb88 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     b42:	af 01       	movw	r20, r30
     b44:	42 0f       	add	r20, r18
     b46:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     b48:	da 01       	movw	r26, r20
     b4a:	13 96       	adiw	r26, 0x03	; 3
     b4c:	9c 93       	st	X, r25
     b4e:	8e 93       	st	-X, r24
     b50:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     b52:	33 83       	std	Z+3, r19	; 0x03
     b54:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     b56:	12 96       	adiw	r26, 0x02	; 2
     b58:	2d 91       	ld	r18, X+
     b5a:	3c 91       	ld	r19, X
     b5c:	13 97       	sbiw	r26, 0x03	; 3
     b5e:	6d e9       	ldi	r22, 0x9D	; 157
     b60:	70 e0       	ldi	r23, 0x00	; 0
     b62:	01 c0       	rjmp	.+2      	; 0xb66 <pvPortMalloc+0xe2>
     b64:	bd 01       	movw	r22, r26
     b66:	eb 01       	movw	r28, r22
     b68:	a8 81       	ld	r26, Y
     b6a:	b9 81       	ldd	r27, Y+1	; 0x01
     b6c:	12 96       	adiw	r26, 0x02	; 2
     b6e:	8d 91       	ld	r24, X+
     b70:	9c 91       	ld	r25, X
     b72:	13 97       	sbiw	r26, 0x03	; 3
     b74:	82 17       	cp	r24, r18
     b76:	93 07       	cpc	r25, r19
     b78:	a8 f3       	brcs	.-22     	; 0xb64 <pvPortMalloc+0xe0>
     b7a:	ea 01       	movw	r28, r20
     b7c:	b9 83       	std	Y+1, r27	; 0x01
     b7e:	a8 83       	st	Y, r26
     b80:	db 01       	movw	r26, r22
     b82:	11 96       	adiw	r26, 0x01	; 1
     b84:	5c 93       	st	X, r21
     b86:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     b88:	80 91 60 00 	lds	r24, 0x0060
     b8c:	90 91 61 00 	lds	r25, 0x0061
     b90:	22 81       	ldd	r18, Z+2	; 0x02
     b92:	33 81       	ldd	r19, Z+3	; 0x03
     b94:	82 1b       	sub	r24, r18
     b96:	93 0b       	sbc	r25, r19
     b98:	90 93 61 00 	sts	0x0061, r25
     b9c:	80 93 60 00 	sts	0x0060, r24
     ba0:	08 c0       	rjmp	.+16     	; 0xbb2 <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     ba2:	00 e0       	ldi	r16, 0x00	; 0
     ba4:	10 e0       	ldi	r17, 0x00	; 0
     ba6:	05 c0       	rjmp	.+10     	; 0xbb2 <pvPortMalloc+0x12e>
     ba8:	00 e0       	ldi	r16, 0x00	; 0
     baa:	10 e0       	ldi	r17, 0x00	; 0
     bac:	02 c0       	rjmp	.+4      	; 0xbb2 <pvPortMalloc+0x12e>
     bae:	00 e0       	ldi	r16, 0x00	; 0
     bb0:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     bb2:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     bb6:	80 2f       	mov	r24, r16
     bb8:	91 2f       	mov	r25, r17
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	1f 91       	pop	r17
     bc0:	0f 91       	pop	r16
     bc2:	08 95       	ret

00000bc4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     bc4:	0f 93       	push	r16
     bc6:	1f 93       	push	r17
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     bce:	00 97       	sbiw	r24, 0x00	; 0
     bd0:	39 f1       	breq	.+78     	; 0xc20 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     bd2:	8c 01       	movw	r16, r24
     bd4:	04 50       	subi	r16, 0x04	; 4
     bd6:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     bd8:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     bdc:	f8 01       	movw	r30, r16
     bde:	22 81       	ldd	r18, Z+2	; 0x02
     be0:	33 81       	ldd	r19, Z+3	; 0x03
     be2:	ad e9       	ldi	r26, 0x9D	; 157
     be4:	b0 e0       	ldi	r27, 0x00	; 0
     be6:	01 c0       	rjmp	.+2      	; 0xbea <vPortFree+0x26>
     be8:	df 01       	movw	r26, r30
     bea:	ed 91       	ld	r30, X+
     bec:	fc 91       	ld	r31, X
     bee:	11 97       	sbiw	r26, 0x01	; 1
     bf0:	82 81       	ldd	r24, Z+2	; 0x02
     bf2:	93 81       	ldd	r25, Z+3	; 0x03
     bf4:	82 17       	cp	r24, r18
     bf6:	93 07       	cpc	r25, r19
     bf8:	b8 f3       	brcs	.-18     	; 0xbe8 <vPortFree+0x24>
     bfa:	24 97       	sbiw	r28, 0x04	; 4
     bfc:	f9 83       	std	Y+1, r31	; 0x01
     bfe:	e8 83       	st	Y, r30
     c00:	0d 93       	st	X+, r16
     c02:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     c04:	80 91 60 00 	lds	r24, 0x0060
     c08:	90 91 61 00 	lds	r25, 0x0061
     c0c:	2a 81       	ldd	r18, Y+2	; 0x02
     c0e:	3b 81       	ldd	r19, Y+3	; 0x03
     c10:	82 0f       	add	r24, r18
     c12:	93 1f       	adc	r25, r19
     c14:	90 93 61 00 	sts	0x0061, r25
     c18:	80 93 60 00 	sts	0x0060, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     c1c:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
	}
}
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	08 95       	ret

00000c2a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     c2a:	80 91 60 00 	lds	r24, 0x0060
     c2e:	90 91 61 00 	lds	r25, 0x0061
     c32:	08 95       	ret

00000c34 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     c34:	08 95       	ret

00000c36 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     c36:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c38:	03 96       	adiw	r24, 0x03	; 3
     c3a:	92 83       	std	Z+2, r25	; 0x02
     c3c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c3e:	2f ef       	ldi	r18, 0xFF	; 255
     c40:	3f ef       	ldi	r19, 0xFF	; 255
     c42:	34 83       	std	Z+4, r19	; 0x04
     c44:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c46:	96 83       	std	Z+6, r25	; 0x06
     c48:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c4a:	90 87       	std	Z+8, r25	; 0x08
     c4c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     c4e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     c50:	08 95       	ret

00000c52 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c52:	fc 01       	movw	r30, r24
     c54:	11 86       	std	Z+9, r1	; 0x09
     c56:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     c58:	08 95       	ret

00000c5a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     c60:	dc 01       	movw	r26, r24
     c62:	11 96       	adiw	r26, 0x01	; 1
     c64:	cd 91       	ld	r28, X+
     c66:	dc 91       	ld	r29, X
     c68:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     c6a:	d3 83       	std	Z+3, r29	; 0x03
     c6c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c6e:	2c 81       	ldd	r18, Y+4	; 0x04
     c70:	3d 81       	ldd	r19, Y+5	; 0x05
     c72:	35 83       	std	Z+5, r19	; 0x05
     c74:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c76:	ac 81       	ldd	r26, Y+4	; 0x04
     c78:	bd 81       	ldd	r27, Y+5	; 0x05
     c7a:	13 96       	adiw	r26, 0x03	; 3
     c7c:	7c 93       	st	X, r23
     c7e:	6e 93       	st	-X, r22
     c80:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     c82:	7d 83       	std	Y+5, r23	; 0x05
     c84:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c86:	91 87       	std	Z+9, r25	; 0x09
     c88:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     c8a:	fc 01       	movw	r30, r24
     c8c:	20 81       	ld	r18, Z
     c8e:	2f 5f       	subi	r18, 0xFF	; 255
     c90:	20 83       	st	Z, r18
}
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	08 95       	ret

00000c98 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c98:	cf 93       	push	r28
     c9a:	df 93       	push	r29
     c9c:	ac 01       	movw	r20, r24
     c9e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     ca0:	28 81       	ld	r18, Y
     ca2:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ca4:	8f ef       	ldi	r24, 0xFF	; 255
     ca6:	2f 3f       	cpi	r18, 0xFF	; 255
     ca8:	38 07       	cpc	r19, r24
     caa:	21 f4       	brne	.+8      	; 0xcb4 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     cac:	fa 01       	movw	r30, r20
     cae:	a7 81       	ldd	r26, Z+7	; 0x07
     cb0:	b0 85       	ldd	r27, Z+8	; 0x08
     cb2:	0d c0       	rjmp	.+26     	; 0xcce <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     cb4:	da 01       	movw	r26, r20
     cb6:	13 96       	adiw	r26, 0x03	; 3
     cb8:	01 c0       	rjmp	.+2      	; 0xcbc <vListInsert+0x24>
     cba:	df 01       	movw	r26, r30
     cbc:	12 96       	adiw	r26, 0x02	; 2
     cbe:	ed 91       	ld	r30, X+
     cc0:	fc 91       	ld	r31, X
     cc2:	13 97       	sbiw	r26, 0x03	; 3
     cc4:	80 81       	ld	r24, Z
     cc6:	91 81       	ldd	r25, Z+1	; 0x01
     cc8:	28 17       	cp	r18, r24
     cca:	39 07       	cpc	r19, r25
     ccc:	b0 f7       	brcc	.-20     	; 0xcba <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     cce:	12 96       	adiw	r26, 0x02	; 2
     cd0:	ed 91       	ld	r30, X+
     cd2:	fc 91       	ld	r31, X
     cd4:	13 97       	sbiw	r26, 0x03	; 3
     cd6:	fb 83       	std	Y+3, r31	; 0x03
     cd8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     cda:	d5 83       	std	Z+5, r29	; 0x05
     cdc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     cde:	bd 83       	std	Y+5, r27	; 0x05
     ce0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ce2:	13 96       	adiw	r26, 0x03	; 3
     ce4:	dc 93       	st	X, r29
     ce6:	ce 93       	st	-X, r28
     ce8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     cea:	59 87       	std	Y+9, r21	; 0x09
     cec:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     cee:	fa 01       	movw	r30, r20
     cf0:	80 81       	ld	r24, Z
     cf2:	8f 5f       	subi	r24, 0xFF	; 255
     cf4:	80 83       	st	Z, r24
}
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	08 95       	ret

00000cfc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     cfc:	cf 93       	push	r28
     cfe:	df 93       	push	r29
     d00:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     d02:	c0 85       	ldd	r28, Z+8	; 0x08
     d04:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     d06:	a2 81       	ldd	r26, Z+2	; 0x02
     d08:	b3 81       	ldd	r27, Z+3	; 0x03
     d0a:	84 81       	ldd	r24, Z+4	; 0x04
     d0c:	95 81       	ldd	r25, Z+5	; 0x05
     d0e:	15 96       	adiw	r26, 0x05	; 5
     d10:	9c 93       	st	X, r25
     d12:	8e 93       	st	-X, r24
     d14:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     d16:	a4 81       	ldd	r26, Z+4	; 0x04
     d18:	b5 81       	ldd	r27, Z+5	; 0x05
     d1a:	82 81       	ldd	r24, Z+2	; 0x02
     d1c:	93 81       	ldd	r25, Z+3	; 0x03
     d1e:	13 96       	adiw	r26, 0x03	; 3
     d20:	9c 93       	st	X, r25
     d22:	8e 93       	st	-X, r24
     d24:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     d26:	a9 81       	ldd	r26, Y+1	; 0x01
     d28:	ba 81       	ldd	r27, Y+2	; 0x02
     d2a:	ae 17       	cp	r26, r30
     d2c:	bf 07       	cpc	r27, r31
     d2e:	31 f4       	brne	.+12     	; 0xd3c <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     d30:	14 96       	adiw	r26, 0x04	; 4
     d32:	8d 91       	ld	r24, X+
     d34:	9c 91       	ld	r25, X
     d36:	15 97       	sbiw	r26, 0x05	; 5
     d38:	9a 83       	std	Y+2, r25	; 0x02
     d3a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     d3c:	11 86       	std	Z+9, r1	; 0x09
     d3e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     d40:	88 81       	ld	r24, Y
     d42:	81 50       	subi	r24, 0x01	; 1
     d44:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     d46:	df 91       	pop	r29
     d48:	cf 91       	pop	r28
     d4a:	08 95       	ret

00000d4c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     d4c:	21 e1       	ldi	r18, 0x11	; 17
     d4e:	fc 01       	movw	r30, r24
     d50:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     d52:	31 97       	sbiw	r30, 0x01	; 1
     d54:	32 e2       	ldi	r19, 0x22	; 34
     d56:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     d58:	fc 01       	movw	r30, r24
     d5a:	32 97       	sbiw	r30, 0x02	; 2
     d5c:	a3 e3       	ldi	r26, 0x33	; 51
     d5e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d60:	fc 01       	movw	r30, r24
     d62:	33 97       	sbiw	r30, 0x03	; 3
     d64:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d66:	fc 01       	movw	r30, r24
     d68:	34 97       	sbiw	r30, 0x04	; 4
     d6a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     d6c:	fc 01       	movw	r30, r24
     d6e:	35 97       	sbiw	r30, 0x05	; 5
     d70:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     d72:	fc 01       	movw	r30, r24
     d74:	36 97       	sbiw	r30, 0x06	; 6
     d76:	60 e8       	ldi	r22, 0x80	; 128
     d78:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     d7a:	fc 01       	movw	r30, r24
     d7c:	37 97       	sbiw	r30, 0x07	; 7
     d7e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     d80:	fc 01       	movw	r30, r24
     d82:	38 97       	sbiw	r30, 0x08	; 8
     d84:	62 e0       	ldi	r22, 0x02	; 2
     d86:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     d88:	fc 01       	movw	r30, r24
     d8a:	39 97       	sbiw	r30, 0x09	; 9
     d8c:	63 e0       	ldi	r22, 0x03	; 3
     d8e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     d90:	fc 01       	movw	r30, r24
     d92:	3a 97       	sbiw	r30, 0x0a	; 10
     d94:	64 e0       	ldi	r22, 0x04	; 4
     d96:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     d98:	fc 01       	movw	r30, r24
     d9a:	3b 97       	sbiw	r30, 0x0b	; 11
     d9c:	65 e0       	ldi	r22, 0x05	; 5
     d9e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     da0:	fc 01       	movw	r30, r24
     da2:	3c 97       	sbiw	r30, 0x0c	; 12
     da4:	66 e0       	ldi	r22, 0x06	; 6
     da6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     da8:	fc 01       	movw	r30, r24
     daa:	3d 97       	sbiw	r30, 0x0d	; 13
     dac:	67 e0       	ldi	r22, 0x07	; 7
     dae:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     db0:	fc 01       	movw	r30, r24
     db2:	3e 97       	sbiw	r30, 0x0e	; 14
     db4:	68 e0       	ldi	r22, 0x08	; 8
     db6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     db8:	fc 01       	movw	r30, r24
     dba:	3f 97       	sbiw	r30, 0x0f	; 15
     dbc:	69 e0       	ldi	r22, 0x09	; 9
     dbe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     dc0:	fc 01       	movw	r30, r24
     dc2:	70 97       	sbiw	r30, 0x10	; 16
     dc4:	60 e1       	ldi	r22, 0x10	; 16
     dc6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     dc8:	fc 01       	movw	r30, r24
     dca:	71 97       	sbiw	r30, 0x11	; 17
     dcc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     dce:	fc 01       	movw	r30, r24
     dd0:	72 97       	sbiw	r30, 0x12	; 18
     dd2:	22 e1       	ldi	r18, 0x12	; 18
     dd4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     dd6:	fc 01       	movw	r30, r24
     dd8:	73 97       	sbiw	r30, 0x13	; 19
     dda:	23 e1       	ldi	r18, 0x13	; 19
     ddc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     dde:	fc 01       	movw	r30, r24
     de0:	74 97       	sbiw	r30, 0x14	; 20
     de2:	24 e1       	ldi	r18, 0x14	; 20
     de4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     de6:	fc 01       	movw	r30, r24
     de8:	75 97       	sbiw	r30, 0x15	; 21
     dea:	25 e1       	ldi	r18, 0x15	; 21
     dec:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     dee:	fc 01       	movw	r30, r24
     df0:	76 97       	sbiw	r30, 0x16	; 22
     df2:	26 e1       	ldi	r18, 0x16	; 22
     df4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     df6:	fc 01       	movw	r30, r24
     df8:	77 97       	sbiw	r30, 0x17	; 23
     dfa:	27 e1       	ldi	r18, 0x17	; 23
     dfc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     dfe:	fc 01       	movw	r30, r24
     e00:	78 97       	sbiw	r30, 0x18	; 24
     e02:	28 e1       	ldi	r18, 0x18	; 24
     e04:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     e06:	fc 01       	movw	r30, r24
     e08:	79 97       	sbiw	r30, 0x19	; 25
     e0a:	29 e1       	ldi	r18, 0x19	; 25
     e0c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     e0e:	fc 01       	movw	r30, r24
     e10:	7a 97       	sbiw	r30, 0x1a	; 26
     e12:	20 e2       	ldi	r18, 0x20	; 32
     e14:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     e16:	fc 01       	movw	r30, r24
     e18:	7b 97       	sbiw	r30, 0x1b	; 27
     e1a:	21 e2       	ldi	r18, 0x21	; 33
     e1c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     e1e:	fc 01       	movw	r30, r24
     e20:	7c 97       	sbiw	r30, 0x1c	; 28
     e22:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     e24:	fc 01       	movw	r30, r24
     e26:	7d 97       	sbiw	r30, 0x1d	; 29
     e28:	23 e2       	ldi	r18, 0x23	; 35
     e2a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     e2c:	fc 01       	movw	r30, r24
     e2e:	7e 97       	sbiw	r30, 0x1e	; 30
     e30:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     e32:	fc 01       	movw	r30, r24
     e34:	7f 97       	sbiw	r30, 0x1f	; 31
     e36:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     e38:	fc 01       	movw	r30, r24
     e3a:	b0 97       	sbiw	r30, 0x20	; 32
     e3c:	26 e2       	ldi	r18, 0x26	; 38
     e3e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     e40:	fc 01       	movw	r30, r24
     e42:	b1 97       	sbiw	r30, 0x21	; 33
     e44:	27 e2       	ldi	r18, 0x27	; 39
     e46:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     e48:	fc 01       	movw	r30, r24
     e4a:	b2 97       	sbiw	r30, 0x22	; 34
     e4c:	28 e2       	ldi	r18, 0x28	; 40
     e4e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     e50:	fc 01       	movw	r30, r24
     e52:	b3 97       	sbiw	r30, 0x23	; 35
     e54:	29 e2       	ldi	r18, 0x29	; 41
     e56:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     e58:	fc 01       	movw	r30, r24
     e5a:	b4 97       	sbiw	r30, 0x24	; 36
     e5c:	20 e3       	ldi	r18, 0x30	; 48
     e5e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     e60:	fc 01       	movw	r30, r24
     e62:	b5 97       	sbiw	r30, 0x25	; 37
     e64:	21 e3       	ldi	r18, 0x31	; 49
     e66:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e68:	86 97       	sbiw	r24, 0x26	; 38
}
     e6a:	08 95       	ret

00000e6c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     e6c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     e6e:	8c e7       	ldi	r24, 0x7C	; 124
     e70:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     e72:	8b e0       	ldi	r24, 0x0B	; 11
     e74:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     e76:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     e78:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     e7a:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     e7c:	a0 91 c5 03 	lds	r26, 0x03C5
     e80:	b0 91 c6 03 	lds	r27, 0x03C6
     e84:	cd 91       	ld	r28, X+
     e86:	cd bf       	out	0x3d, r28	; 61
     e88:	dd 91       	ld	r29, X+
     e8a:	de bf       	out	0x3e, r29	; 62
     e8c:	ff 91       	pop	r31
     e8e:	ef 91       	pop	r30
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	bf 91       	pop	r27
     e96:	af 91       	pop	r26
     e98:	9f 91       	pop	r25
     e9a:	8f 91       	pop	r24
     e9c:	7f 91       	pop	r23
     e9e:	6f 91       	pop	r22
     ea0:	5f 91       	pop	r21
     ea2:	4f 91       	pop	r20
     ea4:	3f 91       	pop	r19
     ea6:	2f 91       	pop	r18
     ea8:	1f 91       	pop	r17
     eaa:	0f 91       	pop	r16
     eac:	ff 90       	pop	r15
     eae:	ef 90       	pop	r14
     eb0:	df 90       	pop	r13
     eb2:	cf 90       	pop	r12
     eb4:	bf 90       	pop	r11
     eb6:	af 90       	pop	r10
     eb8:	9f 90       	pop	r9
     eba:	8f 90       	pop	r8
     ebc:	7f 90       	pop	r7
     ebe:	6f 90       	pop	r6
     ec0:	5f 90       	pop	r5
     ec2:	4f 90       	pop	r4
     ec4:	3f 90       	pop	r3
     ec6:	2f 90       	pop	r2
     ec8:	1f 90       	pop	r1
     eca:	0f 90       	pop	r0
     ecc:	0f be       	out	0x3f, r0	; 63
     ece:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     ed0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     ed2:	81 e0       	ldi	r24, 0x01	; 1
     ed4:	08 95       	ret

00000ed6 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     ed6:	08 95       	ret

00000ed8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ed8:	0f 92       	push	r0
     eda:	0f b6       	in	r0, 0x3f	; 63
     edc:	f8 94       	cli
     ede:	0f 92       	push	r0
     ee0:	1f 92       	push	r1
     ee2:	11 24       	eor	r1, r1
     ee4:	2f 92       	push	r2
     ee6:	3f 92       	push	r3
     ee8:	4f 92       	push	r4
     eea:	5f 92       	push	r5
     eec:	6f 92       	push	r6
     eee:	7f 92       	push	r7
     ef0:	8f 92       	push	r8
     ef2:	9f 92       	push	r9
     ef4:	af 92       	push	r10
     ef6:	bf 92       	push	r11
     ef8:	cf 92       	push	r12
     efa:	df 92       	push	r13
     efc:	ef 92       	push	r14
     efe:	ff 92       	push	r15
     f00:	0f 93       	push	r16
     f02:	1f 93       	push	r17
     f04:	2f 93       	push	r18
     f06:	3f 93       	push	r19
     f08:	4f 93       	push	r20
     f0a:	5f 93       	push	r21
     f0c:	6f 93       	push	r22
     f0e:	7f 93       	push	r23
     f10:	8f 93       	push	r24
     f12:	9f 93       	push	r25
     f14:	af 93       	push	r26
     f16:	bf 93       	push	r27
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
     f1c:	ef 93       	push	r30
     f1e:	ff 93       	push	r31
     f20:	a0 91 c5 03 	lds	r26, 0x03C5
     f24:	b0 91 c6 03 	lds	r27, 0x03C6
     f28:	0d b6       	in	r0, 0x3d	; 61
     f2a:	0d 92       	st	X+, r0
     f2c:	0e b6       	in	r0, 0x3e	; 62
     f2e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f30:	0e 94 85 11 	call	0x230a	; 0x230a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f34:	a0 91 c5 03 	lds	r26, 0x03C5
     f38:	b0 91 c6 03 	lds	r27, 0x03C6
     f3c:	cd 91       	ld	r28, X+
     f3e:	cd bf       	out	0x3d, r28	; 61
     f40:	dd 91       	ld	r29, X+
     f42:	de bf       	out	0x3e, r29	; 62
     f44:	ff 91       	pop	r31
     f46:	ef 91       	pop	r30
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	bf 91       	pop	r27
     f4e:	af 91       	pop	r26
     f50:	9f 91       	pop	r25
     f52:	8f 91       	pop	r24
     f54:	7f 91       	pop	r23
     f56:	6f 91       	pop	r22
     f58:	5f 91       	pop	r21
     f5a:	4f 91       	pop	r20
     f5c:	3f 91       	pop	r19
     f5e:	2f 91       	pop	r18
     f60:	1f 91       	pop	r17
     f62:	0f 91       	pop	r16
     f64:	ff 90       	pop	r15
     f66:	ef 90       	pop	r14
     f68:	df 90       	pop	r13
     f6a:	cf 90       	pop	r12
     f6c:	bf 90       	pop	r11
     f6e:	af 90       	pop	r10
     f70:	9f 90       	pop	r9
     f72:	8f 90       	pop	r8
     f74:	7f 90       	pop	r7
     f76:	6f 90       	pop	r6
     f78:	5f 90       	pop	r5
     f7a:	4f 90       	pop	r4
     f7c:	3f 90       	pop	r3
     f7e:	2f 90       	pop	r2
     f80:	1f 90       	pop	r1
     f82:	0f 90       	pop	r0
     f84:	0f be       	out	0x3f, r0	; 63
     f86:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f88:	08 95       	ret

00000f8a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f8a:	0f 92       	push	r0
     f8c:	0f b6       	in	r0, 0x3f	; 63
     f8e:	f8 94       	cli
     f90:	0f 92       	push	r0
     f92:	1f 92       	push	r1
     f94:	11 24       	eor	r1, r1
     f96:	2f 92       	push	r2
     f98:	3f 92       	push	r3
     f9a:	4f 92       	push	r4
     f9c:	5f 92       	push	r5
     f9e:	6f 92       	push	r6
     fa0:	7f 92       	push	r7
     fa2:	8f 92       	push	r8
     fa4:	9f 92       	push	r9
     fa6:	af 92       	push	r10
     fa8:	bf 92       	push	r11
     faa:	cf 92       	push	r12
     fac:	df 92       	push	r13
     fae:	ef 92       	push	r14
     fb0:	ff 92       	push	r15
     fb2:	0f 93       	push	r16
     fb4:	1f 93       	push	r17
     fb6:	2f 93       	push	r18
     fb8:	3f 93       	push	r19
     fba:	4f 93       	push	r20
     fbc:	5f 93       	push	r21
     fbe:	6f 93       	push	r22
     fc0:	7f 93       	push	r23
     fc2:	8f 93       	push	r24
     fc4:	9f 93       	push	r25
     fc6:	af 93       	push	r26
     fc8:	bf 93       	push	r27
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	ef 93       	push	r30
     fd0:	ff 93       	push	r31
     fd2:	a0 91 c5 03 	lds	r26, 0x03C5
     fd6:	b0 91 c6 03 	lds	r27, 0x03C6
     fda:	0d b6       	in	r0, 0x3d	; 61
     fdc:	0d 92       	st	X+, r0
     fde:	0e b6       	in	r0, 0x3e	; 62
     fe0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     fe2:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <xTaskIncrementTick>
     fe6:	88 23       	and	r24, r24
     fe8:	11 f0       	breq	.+4      	; 0xfee <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     fea:	0e 94 85 11 	call	0x230a	; 0x230a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     fee:	a0 91 c5 03 	lds	r26, 0x03C5
     ff2:	b0 91 c6 03 	lds	r27, 0x03C6
     ff6:	cd 91       	ld	r28, X+
     ff8:	cd bf       	out	0x3d, r28	; 61
     ffa:	dd 91       	ld	r29, X+
     ffc:	de bf       	out	0x3e, r29	; 62
     ffe:	ff 91       	pop	r31
    1000:	ef 91       	pop	r30
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	bf 91       	pop	r27
    1008:	af 91       	pop	r26
    100a:	9f 91       	pop	r25
    100c:	8f 91       	pop	r24
    100e:	7f 91       	pop	r23
    1010:	6f 91       	pop	r22
    1012:	5f 91       	pop	r21
    1014:	4f 91       	pop	r20
    1016:	3f 91       	pop	r19
    1018:	2f 91       	pop	r18
    101a:	1f 91       	pop	r17
    101c:	0f 91       	pop	r16
    101e:	ff 90       	pop	r15
    1020:	ef 90       	pop	r14
    1022:	df 90       	pop	r13
    1024:	cf 90       	pop	r12
    1026:	bf 90       	pop	r11
    1028:	af 90       	pop	r10
    102a:	9f 90       	pop	r9
    102c:	8f 90       	pop	r8
    102e:	7f 90       	pop	r7
    1030:	6f 90       	pop	r6
    1032:	5f 90       	pop	r5
    1034:	4f 90       	pop	r4
    1036:	3f 90       	pop	r3
    1038:	2f 90       	pop	r2
    103a:	1f 90       	pop	r1
    103c:	0f 90       	pop	r0
    103e:	0f be       	out	0x3f, r0	; 63
    1040:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1042:	08 95       	ret

00001044 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1044:	0e 94 c5 07 	call	0xf8a	; 0xf8a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1048:	18 95       	reti

0000104a <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    104a:	0f b6       	in	r0, 0x3f	; 63
    104c:	f8 94       	cli
    104e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1050:	fc 01       	movw	r30, r24
    1052:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1054:	0f 90       	pop	r0
    1056:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	91 11       	cpse	r25, r1
    105c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    105e:	08 95       	ret

00001060 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1060:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1062:	44 8d       	ldd	r20, Z+28	; 0x1c
    1064:	44 23       	and	r20, r20
    1066:	c1 f0       	breq	.+48     	; 0x1098 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1068:	26 81       	ldd	r18, Z+6	; 0x06
    106a:	37 81       	ldd	r19, Z+7	; 0x07
    106c:	24 0f       	add	r18, r20
    106e:	31 1d       	adc	r19, r1
    1070:	37 83       	std	Z+7, r19	; 0x07
    1072:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1074:	a2 81       	ldd	r26, Z+2	; 0x02
    1076:	b3 81       	ldd	r27, Z+3	; 0x03
    1078:	2a 17       	cp	r18, r26
    107a:	3b 07       	cpc	r19, r27
    107c:	20 f0       	brcs	.+8      	; 0x1086 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    107e:	20 81       	ld	r18, Z
    1080:	31 81       	ldd	r19, Z+1	; 0x01
    1082:	37 83       	std	Z+7, r19	; 0x07
    1084:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1086:	36 81       	ldd	r19, Z+6	; 0x06
    1088:	27 81       	ldd	r18, Z+7	; 0x07
    108a:	86 2f       	mov	r24, r22
    108c:	97 2f       	mov	r25, r23
    108e:	63 2f       	mov	r22, r19
    1090:	72 2f       	mov	r23, r18
    1092:	50 e0       	ldi	r21, 0x00	; 0
    1094:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <memcpy>
    1098:	08 95       	ret

0000109a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    109a:	ef 92       	push	r14
    109c:	ff 92       	push	r15
    109e:	0f 93       	push	r16
    10a0:	1f 93       	push	r17
    10a2:	cf 93       	push	r28
    10a4:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    10a6:	0f b6       	in	r0, 0x3f	; 63
    10a8:	f8 94       	cli
    10aa:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    10ac:	fc 01       	movw	r30, r24
    10ae:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    10b0:	1c 16       	cp	r1, r28
    10b2:	cc f4       	brge	.+50     	; 0x10e6 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10b4:	81 89       	ldd	r24, Z+17	; 0x11
    10b6:	88 23       	and	r24, r24
    10b8:	31 f4       	brne	.+12     	; 0x10c6 <prvUnlockQueue+0x2c>
    10ba:	15 c0       	rjmp	.+42     	; 0x10e6 <prvUnlockQueue+0x4c>
    10bc:	f8 01       	movw	r30, r16
    10be:	81 89       	ldd	r24, Z+17	; 0x11
    10c0:	88 23       	and	r24, r24
    10c2:	41 f4       	brne	.+16     	; 0x10d4 <prvUnlockQueue+0x3a>
    10c4:	10 c0       	rjmp	.+32     	; 0x10e6 <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10c6:	0f 2e       	mov	r0, r31
    10c8:	f1 e1       	ldi	r31, 0x11	; 17
    10ca:	ef 2e       	mov	r14, r31
    10cc:	ff 24       	eor	r15, r15
    10ce:	f0 2d       	mov	r31, r0
    10d0:	e0 0e       	add	r14, r16
    10d2:	f1 1e       	adc	r15, r17
    10d4:	c7 01       	movw	r24, r14
    10d6:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    10da:	88 23       	and	r24, r24
    10dc:	11 f0       	breq	.+4      	; 0x10e2 <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    10de:	0e 94 20 13 	call	0x2640	; 0x2640 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    10e2:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    10e4:	59 f7       	brne	.-42     	; 0x10bc <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    10e6:	8f ef       	ldi	r24, 0xFF	; 255
    10e8:	f8 01       	movw	r30, r16
    10ea:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    10ec:	0f 90       	pop	r0
    10ee:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    10f0:	0f b6       	in	r0, 0x3f	; 63
    10f2:	f8 94       	cli
    10f4:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    10f6:	f8 01       	movw	r30, r16
    10f8:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    10fa:	1c 16       	cp	r1, r28
    10fc:	c4 f4       	brge	.+48     	; 0x112e <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10fe:	80 85       	ldd	r24, Z+8	; 0x08
    1100:	88 23       	and	r24, r24
    1102:	31 f4       	brne	.+12     	; 0x1110 <prvUnlockQueue+0x76>
    1104:	14 c0       	rjmp	.+40     	; 0x112e <prvUnlockQueue+0x94>
    1106:	f8 01       	movw	r30, r16
    1108:	80 85       	ldd	r24, Z+8	; 0x08
    110a:	88 23       	and	r24, r24
    110c:	39 f4       	brne	.+14     	; 0x111c <prvUnlockQueue+0x82>
    110e:	0f c0       	rjmp	.+30     	; 0x112e <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1110:	ee 24       	eor	r14, r14
    1112:	ff 24       	eor	r15, r15
    1114:	68 94       	set
    1116:	e3 f8       	bld	r14, 3
    1118:	e0 0e       	add	r14, r16
    111a:	f1 1e       	adc	r15, r17
    111c:	c7 01       	movw	r24, r14
    111e:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    1122:	88 23       	and	r24, r24
    1124:	11 f0       	breq	.+4      	; 0x112a <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
    1126:	0e 94 20 13 	call	0x2640	; 0x2640 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    112a:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    112c:	61 f7       	brne	.-40     	; 0x1106 <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    112e:	8f ef       	ldi	r24, 0xFF	; 255
    1130:	f8 01       	movw	r30, r16
    1132:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1134:	0f 90       	pop	r0
    1136:	0f be       	out	0x3f, r0	; 63
}
    1138:	cf 91       	pop	r28
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	ff 90       	pop	r15
    1140:	ef 90       	pop	r14
    1142:	08 95       	ret

00001144 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1144:	0f 93       	push	r16
    1146:	1f 93       	push	r17
    1148:	cf 93       	push	r28
    114a:	df 93       	push	r29
    114c:	ec 01       	movw	r28, r24
    114e:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1150:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1152:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1154:	44 23       	and	r20, r20
    1156:	61 f4       	brne	.+24     	; 0x1170 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1158:	88 81       	ld	r24, Y
    115a:	99 81       	ldd	r25, Y+1	; 0x01
    115c:	00 97       	sbiw	r24, 0x00	; 0
    115e:	09 f0       	breq	.+2      	; 0x1162 <prvCopyDataToQueue+0x1e>
    1160:	42 c0       	rjmp	.+132    	; 0x11e6 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1162:	8a 81       	ldd	r24, Y+2	; 0x02
    1164:	9b 81       	ldd	r25, Y+3	; 0x03
    1166:	0e 94 87 13 	call	0x270e	; 0x270e <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    116a:	1b 82       	std	Y+3, r1	; 0x03
    116c:	1a 82       	std	Y+2, r1	; 0x02
    116e:	42 c0       	rjmp	.+132    	; 0x11f4 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1170:	11 23       	and	r17, r17
    1172:	b9 f4       	brne	.+46     	; 0x11a2 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1174:	8c 81       	ldd	r24, Y+4	; 0x04
    1176:	9d 81       	ldd	r25, Y+5	; 0x05
    1178:	50 e0       	ldi	r21, 0x00	; 0
    117a:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    117e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1180:	8c 81       	ldd	r24, Y+4	; 0x04
    1182:	9d 81       	ldd	r25, Y+5	; 0x05
    1184:	82 0f       	add	r24, r18
    1186:	91 1d       	adc	r25, r1
    1188:	9d 83       	std	Y+5, r25	; 0x05
    118a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    118c:	2a 81       	ldd	r18, Y+2	; 0x02
    118e:	3b 81       	ldd	r19, Y+3	; 0x03
    1190:	82 17       	cp	r24, r18
    1192:	93 07       	cpc	r25, r19
    1194:	50 f1       	brcs	.+84     	; 0x11ea <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1196:	88 81       	ld	r24, Y
    1198:	99 81       	ldd	r25, Y+1	; 0x01
    119a:	9d 83       	std	Y+5, r25	; 0x05
    119c:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	29 c0       	rjmp	.+82     	; 0x11f4 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11a2:	8e 81       	ldd	r24, Y+6	; 0x06
    11a4:	9f 81       	ldd	r25, Y+7	; 0x07
    11a6:	50 e0       	ldi	r21, 0x00	; 0
    11a8:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    11ac:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11ae:	50 e0       	ldi	r21, 0x00	; 0
    11b0:	50 95       	com	r21
    11b2:	41 95       	neg	r20
    11b4:	5f 4f       	sbci	r21, 0xFF	; 255
    11b6:	8e 81       	ldd	r24, Y+6	; 0x06
    11b8:	9f 81       	ldd	r25, Y+7	; 0x07
    11ba:	84 0f       	add	r24, r20
    11bc:	95 1f       	adc	r25, r21
    11be:	9f 83       	std	Y+7, r25	; 0x07
    11c0:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11c2:	28 81       	ld	r18, Y
    11c4:	39 81       	ldd	r19, Y+1	; 0x01
    11c6:	82 17       	cp	r24, r18
    11c8:	93 07       	cpc	r25, r19
    11ca:	30 f4       	brcc	.+12     	; 0x11d8 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    11cc:	8a 81       	ldd	r24, Y+2	; 0x02
    11ce:	9b 81       	ldd	r25, Y+3	; 0x03
    11d0:	84 0f       	add	r24, r20
    11d2:	95 1f       	adc	r25, r21
    11d4:	9f 83       	std	Y+7, r25	; 0x07
    11d6:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    11d8:	12 30       	cpi	r17, 0x02	; 2
    11da:	49 f4       	brne	.+18     	; 0x11ee <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    11dc:	00 23       	and	r16, r16
    11de:	49 f0       	breq	.+18     	; 0x11f2 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    11e0:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	07 c0       	rjmp	.+14     	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11e6:	80 e0       	ldi	r24, 0x00	; 0
    11e8:	05 c0       	rjmp	.+10     	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	03 c0       	rjmp	.+6      	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	01 c0       	rjmp	.+2      	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11f2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    11f4:	0f 5f       	subi	r16, 0xFF	; 255
    11f6:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	1f 91       	pop	r17
    11fe:	0f 91       	pop	r16
    1200:	08 95       	ret

00001202 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1202:	cf 93       	push	r28
    1204:	df 93       	push	r29
    1206:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    120e:	48 81       	ld	r20, Y
    1210:	59 81       	ldd	r21, Y+1	; 0x01
    1212:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1214:	30 e0       	ldi	r19, 0x00	; 0
    1216:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	2e 9f       	mul	r18, r30
    121c:	c0 01       	movw	r24, r0
    121e:	2f 9f       	mul	r18, r31
    1220:	90 0d       	add	r25, r0
    1222:	3e 9f       	mul	r19, r30
    1224:	90 0d       	add	r25, r0
    1226:	11 24       	eor	r1, r1
    1228:	84 0f       	add	r24, r20
    122a:	95 1f       	adc	r25, r21
    122c:	9b 83       	std	Y+3, r25	; 0x03
    122e:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1230:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1232:	5d 83       	std	Y+5, r21	; 0x05
    1234:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1236:	c9 01       	movw	r24, r18
    1238:	01 97       	sbiw	r24, 0x01	; 1
    123a:	e8 9f       	mul	r30, r24
    123c:	90 01       	movw	r18, r0
    123e:	e9 9f       	mul	r30, r25
    1240:	30 0d       	add	r19, r0
    1242:	f8 9f       	mul	r31, r24
    1244:	30 0d       	add	r19, r0
    1246:	11 24       	eor	r1, r1
    1248:	24 0f       	add	r18, r20
    124a:	35 1f       	adc	r19, r21
    124c:	3f 83       	std	Y+7, r19	; 0x07
    124e:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1250:	8f ef       	ldi	r24, 0xFF	; 255
    1252:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1254:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1256:	66 23       	and	r22, r22
    1258:	61 f4       	brne	.+24     	; 0x1272 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    125a:	88 85       	ldd	r24, Y+8	; 0x08
    125c:	88 23       	and	r24, r24
    125e:	89 f0       	breq	.+34     	; 0x1282 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1260:	ce 01       	movw	r24, r28
    1262:	08 96       	adiw	r24, 0x08	; 8
    1264:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    1268:	88 23       	and	r24, r24
    126a:	59 f0       	breq	.+22     	; 0x1282 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    126c:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    1270:	08 c0       	rjmp	.+16     	; 0x1282 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1272:	ce 01       	movw	r24, r28
    1274:	08 96       	adiw	r24, 0x08	; 8
    1276:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    127a:	ce 01       	movw	r24, r28
    127c:	41 96       	adiw	r24, 0x11	; 17
    127e:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1282:	0f 90       	pop	r0
    1284:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1286:	81 e0       	ldi	r24, 0x01	; 1
    1288:	df 91       	pop	r29
    128a:	cf 91       	pop	r28
    128c:	08 95       	ret

0000128e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    128e:	0f 93       	push	r16
    1290:	1f 93       	push	r17
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	08 2f       	mov	r16, r24
    1298:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    129a:	66 23       	and	r22, r22
    129c:	21 f0       	breq	.+8      	; 0x12a6 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    129e:	68 9f       	mul	r22, r24
    12a0:	c0 01       	movw	r24, r0
    12a2:	11 24       	eor	r1, r1
    12a4:	02 c0       	rjmp	.+4      	; 0x12aa <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    12aa:	4f 96       	adiw	r24, 0x1f	; 31
    12ac:	0e 94 42 05 	call	0xa84	; 0xa84 <pvPortMalloc>
    12b0:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    12b2:	00 97       	sbiw	r24, 0x00	; 0
    12b4:	71 f0       	breq	.+28     	; 0x12d2 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    12b6:	11 23       	and	r17, r17
    12b8:	19 f4       	brne	.+6      	; 0x12c0 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    12ba:	99 83       	std	Y+1, r25	; 0x01
    12bc:	88 83       	st	Y, r24
    12be:	03 c0       	rjmp	.+6      	; 0x12c6 <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    12c0:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    12c2:	99 83       	std	Y+1, r25	; 0x01
    12c4:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    12c6:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    12c8:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    12ca:	ce 01       	movw	r24, r28
    12cc:	61 e0       	ldi	r22, 0x01	; 1
    12ce:	0e 94 01 09 	call	0x1202	; 0x1202 <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    12d2:	8c 2f       	mov	r24, r28
    12d4:	9d 2f       	mov	r25, r29
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	1f 91       	pop	r17
    12dc:	0f 91       	pop	r16
    12de:	08 95       	ret

000012e0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    12e0:	8f 92       	push	r8
    12e2:	9f 92       	push	r9
    12e4:	bf 92       	push	r11
    12e6:	cf 92       	push	r12
    12e8:	df 92       	push	r13
    12ea:	ef 92       	push	r14
    12ec:	ff 92       	push	r15
    12ee:	0f 93       	push	r16
    12f0:	1f 93       	push	r17
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	00 d0       	rcall	.+0      	; 0x12f8 <xQueueGenericSend+0x18>
    12f8:	00 d0       	rcall	.+0      	; 0x12fa <xQueueGenericSend+0x1a>
    12fa:	0f 92       	push	r0
    12fc:	cd b7       	in	r28, 0x3d	; 61
    12fe:	de b7       	in	r29, 0x3e	; 62
    1300:	8c 01       	movw	r16, r24
    1302:	4b 01       	movw	r8, r22
    1304:	5d 83       	std	Y+5, r21	; 0x05
    1306:	4c 83       	std	Y+4, r20	; 0x04
    1308:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    130a:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    130c:	bb 24       	eor	r11, r11
    130e:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1310:	cc 24       	eor	r12, r12
    1312:	dd 24       	eor	r13, r13
    1314:	68 94       	set
    1316:	c3 f8       	bld	r12, 3
    1318:	c8 0e       	add	r12, r24
    131a:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    131c:	0f b6       	in	r0, 0x3f	; 63
    131e:	f8 94       	cli
    1320:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1322:	f8 01       	movw	r30, r16
    1324:	92 8d       	ldd	r25, Z+26	; 0x1a
    1326:	83 8d       	ldd	r24, Z+27	; 0x1b
    1328:	98 17       	cp	r25, r24
    132a:	18 f0       	brcs	.+6      	; 0x1332 <xQueueGenericSend+0x52>
    132c:	f2 e0       	ldi	r31, 0x02	; 2
    132e:	ef 16       	cp	r14, r31
    1330:	d1 f4       	brne	.+52     	; 0x1366 <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1332:	c8 01       	movw	r24, r16
    1334:	b4 01       	movw	r22, r8
    1336:	4e 2d       	mov	r20, r14
    1338:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    133c:	f8 01       	movw	r30, r16
    133e:	91 89       	ldd	r25, Z+17	; 0x11
    1340:	99 23       	and	r25, r25
    1342:	49 f0       	breq	.+18     	; 0x1356 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1344:	c8 01       	movw	r24, r16
    1346:	41 96       	adiw	r24, 0x11	; 17
    1348:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    134c:	88 23       	and	r24, r24
    134e:	39 f0       	breq	.+14     	; 0x135e <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1350:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    1354:	04 c0       	rjmp	.+8      	; 0x135e <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1356:	88 23       	and	r24, r24
    1358:	11 f0       	breq	.+4      	; 0x135e <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    135a:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    135e:	0f 90       	pop	r0
    1360:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	52 c0       	rjmp	.+164    	; 0x140a <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1366:	8c 81       	ldd	r24, Y+4	; 0x04
    1368:	9d 81       	ldd	r25, Y+5	; 0x05
    136a:	00 97       	sbiw	r24, 0x00	; 0
    136c:	21 f4       	brne	.+8      	; 0x1376 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    136e:	0f 90       	pop	r0
    1370:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	4a c0       	rjmp	.+148    	; 0x140a <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    1376:	ff 20       	and	r15, r15
    1378:	29 f4       	brne	.+10     	; 0x1384 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    137a:	ce 01       	movw	r24, r28
    137c:	01 96       	adiw	r24, 0x01	; 1
    137e:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1382:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1384:	0f 90       	pop	r0
    1386:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1388:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    138c:	0f b6       	in	r0, 0x3f	; 63
    138e:	f8 94       	cli
    1390:	0f 92       	push	r0
    1392:	f8 01       	movw	r30, r16
    1394:	85 8d       	ldd	r24, Z+29	; 0x1d
    1396:	8f 3f       	cpi	r24, 0xFF	; 255
    1398:	09 f4       	brne	.+2      	; 0x139c <xQueueGenericSend+0xbc>
    139a:	15 8e       	std	Z+29, r1	; 0x1d
    139c:	f8 01       	movw	r30, r16
    139e:	86 8d       	ldd	r24, Z+30	; 0x1e
    13a0:	8f 3f       	cpi	r24, 0xFF	; 255
    13a2:	09 f4       	brne	.+2      	; 0x13a6 <xQueueGenericSend+0xc6>
    13a4:	16 8e       	std	Z+30, r1	; 0x1e
    13a6:	0f 90       	pop	r0
    13a8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13aa:	ce 01       	movw	r24, r28
    13ac:	01 96       	adiw	r24, 0x01	; 1
    13ae:	be 01       	movw	r22, r28
    13b0:	6c 5f       	subi	r22, 0xFC	; 252
    13b2:	7f 4f       	sbci	r23, 0xFF	; 255
    13b4:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <xTaskCheckForTimeOut>
    13b8:	88 23       	and	r24, r24
    13ba:	09 f5       	brne	.+66     	; 0x13fe <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    13bc:	0f b6       	in	r0, 0x3f	; 63
    13be:	f8 94       	cli
    13c0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    13c2:	f8 01       	movw	r30, r16
    13c4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    13c6:	0f 90       	pop	r0
    13c8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13ca:	f8 01       	movw	r30, r16
    13cc:	83 8d       	ldd	r24, Z+27	; 0x1b
    13ce:	98 17       	cp	r25, r24
    13d0:	81 f4       	brne	.+32     	; 0x13f2 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13d2:	6c 81       	ldd	r22, Y+4	; 0x04
    13d4:	7d 81       	ldd	r23, Y+5	; 0x05
    13d6:	c6 01       	movw	r24, r12
    13d8:	0e 94 30 12 	call	0x2460	; 0x2460 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    13dc:	c8 01       	movw	r24, r16
    13de:	0e 94 4d 08 	call	0x109a	; 0x109a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    13e2:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
    13e6:	88 23       	and	r24, r24
    13e8:	09 f0       	breq	.+2      	; 0x13ec <xQueueGenericSend+0x10c>
    13ea:	98 cf       	rjmp	.-208    	; 0x131c <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    13ec:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    13f0:	95 cf       	rjmp	.-214    	; 0x131c <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13f2:	c8 01       	movw	r24, r16
    13f4:	0e 94 4d 08 	call	0x109a	; 0x109a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13f8:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
    13fc:	8f cf       	rjmp	.-226    	; 0x131c <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    13fe:	c8 01       	movw	r24, r16
    1400:	0e 94 4d 08 	call	0x109a	; 0x109a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1404:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1408:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    140a:	0f 90       	pop	r0
    140c:	0f 90       	pop	r0
    140e:	0f 90       	pop	r0
    1410:	0f 90       	pop	r0
    1412:	0f 90       	pop	r0
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	1f 91       	pop	r17
    141a:	0f 91       	pop	r16
    141c:	ff 90       	pop	r15
    141e:	ef 90       	pop	r14
    1420:	df 90       	pop	r13
    1422:	cf 90       	pop	r12
    1424:	bf 90       	pop	r11
    1426:	9f 90       	pop	r9
    1428:	8f 90       	pop	r8
    142a:	08 95       	ret

0000142c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    142c:	cf 93       	push	r28
    142e:	df 93       	push	r29
    1430:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	60 e0       	ldi	r22, 0x00	; 0
    1436:	0e 94 47 09 	call	0x128e	; 0x128e <xQueueGenericCreate>
    143a:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    143c:	00 97       	sbiw	r24, 0x00	; 0
    143e:	61 f0       	breq	.+24     	; 0x1458 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1440:	1b 82       	std	Y+3, r1	; 0x03
    1442:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1444:	19 82       	std	Y+1, r1	; 0x01
    1446:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1448:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    144a:	60 e0       	ldi	r22, 0x00	; 0
    144c:	70 e0       	ldi	r23, 0x00	; 0
    144e:	40 e0       	ldi	r20, 0x00	; 0
    1450:	50 e0       	ldi	r21, 0x00	; 0
    1452:	20 e0       	ldi	r18, 0x00	; 0
    1454:	0e 94 70 09 	call	0x12e0	; 0x12e0 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    1458:	8c 2f       	mov	r24, r28
    145a:	9d 2f       	mov	r25, r29
    145c:	df 91       	pop	r29
    145e:	cf 91       	pop	r28
    1460:	08 95       	ret

00001462 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1462:	ef 92       	push	r14
    1464:	ff 92       	push	r15
    1466:	0f 93       	push	r16
    1468:	1f 93       	push	r17
    146a:	cf 93       	push	r28
    146c:	8c 01       	movw	r16, r24
    146e:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1470:	fc 01       	movw	r30, r24
    1472:	92 8d       	ldd	r25, Z+26	; 0x1a
    1474:	83 8d       	ldd	r24, Z+27	; 0x1b
    1476:	98 17       	cp	r25, r24
    1478:	10 f0       	brcs	.+4      	; 0x147e <xQueueGenericSendFromISR+0x1c>
    147a:	22 30       	cpi	r18, 0x02	; 2
    147c:	f1 f4       	brne	.+60     	; 0x14ba <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    147e:	f8 01       	movw	r30, r16
    1480:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1482:	c8 01       	movw	r24, r16
    1484:	42 2f       	mov	r20, r18
    1486:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    148a:	cf 3f       	cpi	r28, 0xFF	; 255
    148c:	89 f4       	brne	.+34     	; 0x14b0 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    148e:	f8 01       	movw	r30, r16
    1490:	81 89       	ldd	r24, Z+17	; 0x11
    1492:	88 23       	and	r24, r24
    1494:	a1 f0       	breq	.+40     	; 0x14be <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1496:	c8 01       	movw	r24, r16
    1498:	41 96       	adiw	r24, 0x11	; 17
    149a:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    149e:	88 23       	and	r24, r24
    14a0:	81 f0       	breq	.+32     	; 0x14c2 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14a2:	e1 14       	cp	r14, r1
    14a4:	f1 04       	cpc	r15, r1
    14a6:	79 f0       	breq	.+30     	; 0x14c6 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14a8:	81 e0       	ldi	r24, 0x01	; 1
    14aa:	f7 01       	movw	r30, r14
    14ac:	80 83       	st	Z, r24
    14ae:	0c c0       	rjmp	.+24     	; 0x14c8 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    14b0:	cf 5f       	subi	r28, 0xFF	; 255
    14b2:	f8 01       	movw	r30, r16
    14b4:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	07 c0       	rjmp	.+14     	; 0x14c8 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14ba:	80 e0       	ldi	r24, 0x00	; 0
    14bc:	05 c0       	rjmp	.+10     	; 0x14c8 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	03 c0       	rjmp	.+6      	; 0x14c8 <xQueueGenericSendFromISR+0x66>
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	01 c0       	rjmp	.+2      	; 0x14c8 <xQueueGenericSendFromISR+0x66>
    14c6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14c8:	cf 91       	pop	r28
    14ca:	1f 91       	pop	r17
    14cc:	0f 91       	pop	r16
    14ce:	ff 90       	pop	r15
    14d0:	ef 90       	pop	r14
    14d2:	08 95       	ret

000014d4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    14d4:	cf 93       	push	r28
    14d6:	df 93       	push	r29
    14d8:	fc 01       	movw	r30, r24
    14da:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14dc:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    14de:	93 8d       	ldd	r25, Z+27	; 0x1b
    14e0:	89 17       	cp	r24, r25
    14e2:	b8 f4       	brcc	.+46     	; 0x1512 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    14e4:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    14e6:	8f 5f       	subi	r24, 0xFF	; 255
    14e8:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14ea:	9f 3f       	cpi	r25, 0xFF	; 255
    14ec:	71 f4       	brne	.+28     	; 0x150a <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14ee:	81 89       	ldd	r24, Z+17	; 0x11
    14f0:	88 23       	and	r24, r24
    14f2:	89 f0       	breq	.+34     	; 0x1516 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14f4:	cf 01       	movw	r24, r30
    14f6:	41 96       	adiw	r24, 0x11	; 17
    14f8:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    14fc:	88 23       	and	r24, r24
    14fe:	69 f0       	breq	.+26     	; 0x151a <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1500:	20 97       	sbiw	r28, 0x00	; 0
    1502:	69 f0       	breq	.+26     	; 0x151e <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	88 83       	st	Y, r24
    1508:	0b c0       	rjmp	.+22     	; 0x1520 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    150a:	9f 5f       	subi	r25, 0xFF	; 255
    150c:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	07 c0       	rjmp	.+14     	; 0x1520 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	05 c0       	rjmp	.+10     	; 0x1520 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	03 c0       	rjmp	.+6      	; 0x1520 <xQueueGiveFromISR+0x4c>
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	01 c0       	rjmp	.+2      	; 0x1520 <xQueueGiveFromISR+0x4c>
    151e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	08 95       	ret

00001526 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1526:	8f 92       	push	r8
    1528:	9f 92       	push	r9
    152a:	af 92       	push	r10
    152c:	bf 92       	push	r11
    152e:	cf 92       	push	r12
    1530:	df 92       	push	r13
    1532:	ef 92       	push	r14
    1534:	ff 92       	push	r15
    1536:	0f 93       	push	r16
    1538:	1f 93       	push	r17
    153a:	cf 93       	push	r28
    153c:	df 93       	push	r29
    153e:	00 d0       	rcall	.+0      	; 0x1540 <xQueueGenericReceive+0x1a>
    1540:	00 d0       	rcall	.+0      	; 0x1542 <xQueueGenericReceive+0x1c>
    1542:	0f 92       	push	r0
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
    1548:	7c 01       	movw	r14, r24
    154a:	4b 01       	movw	r8, r22
    154c:	5d 83       	std	Y+5, r21	; 0x05
    154e:	4c 83       	std	Y+4, r20	; 0x04
    1550:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1552:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1554:	dd 24       	eor	r13, r13
    1556:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1558:	0f 2e       	mov	r0, r31
    155a:	f1 e1       	ldi	r31, 0x11	; 17
    155c:	af 2e       	mov	r10, r31
    155e:	bb 24       	eor	r11, r11
    1560:	f0 2d       	mov	r31, r0
    1562:	a8 0e       	add	r10, r24
    1564:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	f8 94       	cli
    156a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    156c:	f7 01       	movw	r30, r14
    156e:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1570:	11 23       	and	r17, r17
    1572:	99 f1       	breq	.+102    	; 0x15da <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1574:	a6 80       	ldd	r10, Z+6	; 0x06
    1576:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1578:	c7 01       	movw	r24, r14
    157a:	b4 01       	movw	r22, r8
    157c:	0e 94 30 08 	call	0x1060	; 0x1060 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1580:	cc 20       	and	r12, r12
    1582:	c9 f4       	brne	.+50     	; 0x15b6 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1584:	11 50       	subi	r17, 0x01	; 1
    1586:	f7 01       	movw	r30, r14
    1588:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    158a:	80 81       	ld	r24, Z
    158c:	91 81       	ldd	r25, Z+1	; 0x01
    158e:	00 97       	sbiw	r24, 0x00	; 0
    1590:	29 f4       	brne	.+10     	; 0x159c <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1592:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <pvTaskIncrementMutexHeldCount>
    1596:	f7 01       	movw	r30, r14
    1598:	93 83       	std	Z+3, r25	; 0x03
    159a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    159c:	f7 01       	movw	r30, r14
    159e:	80 85       	ldd	r24, Z+8	; 0x08
    15a0:	88 23       	and	r24, r24
    15a2:	b9 f0       	breq	.+46     	; 0x15d2 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15a4:	c7 01       	movw	r24, r14
    15a6:	08 96       	adiw	r24, 0x08	; 8
    15a8:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    15ac:	88 23       	and	r24, r24
    15ae:	89 f0       	breq	.+34     	; 0x15d2 <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
    15b0:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    15b4:	0e c0       	rjmp	.+28     	; 0x15d2 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    15b6:	f7 01       	movw	r30, r14
    15b8:	b7 82       	std	Z+7, r11	; 0x07
    15ba:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15bc:	81 89       	ldd	r24, Z+17	; 0x11
    15be:	88 23       	and	r24, r24
    15c0:	41 f0       	breq	.+16     	; 0x15d2 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15c2:	c7 01       	movw	r24, r14
    15c4:	41 96       	adiw	r24, 0x11	; 17
    15c6:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    15ca:	88 23       	and	r24, r24
    15cc:	11 f0       	breq	.+4      	; 0x15d2 <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    15ce:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15d6:	81 e0       	ldi	r24, 0x01	; 1
    15d8:	61 c0       	rjmp	.+194    	; 0x169c <xQueueGenericReceive+0x176>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15da:	8c 81       	ldd	r24, Y+4	; 0x04
    15dc:	9d 81       	ldd	r25, Y+5	; 0x05
    15de:	00 97       	sbiw	r24, 0x00	; 0
    15e0:	21 f4       	brne	.+8      	; 0x15ea <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15e2:	0f 90       	pop	r0
    15e4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    15e6:	80 e0       	ldi	r24, 0x00	; 0
    15e8:	59 c0       	rjmp	.+178    	; 0x169c <xQueueGenericReceive+0x176>
				}
				else if( xEntryTimeSet == pdFALSE )
    15ea:	00 23       	and	r16, r16
    15ec:	29 f4       	brne	.+10     	; 0x15f8 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15ee:	ce 01       	movw	r24, r28
    15f0:	01 96       	adiw	r24, 0x01	; 1
    15f2:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15f6:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15f8:	0f 90       	pop	r0
    15fa:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15fc:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	0f 92       	push	r0
    1606:	f7 01       	movw	r30, r14
    1608:	85 8d       	ldd	r24, Z+29	; 0x1d
    160a:	8f 3f       	cpi	r24, 0xFF	; 255
    160c:	09 f4       	brne	.+2      	; 0x1610 <xQueueGenericReceive+0xea>
    160e:	15 8e       	std	Z+29, r1	; 0x1d
    1610:	f7 01       	movw	r30, r14
    1612:	86 8d       	ldd	r24, Z+30	; 0x1e
    1614:	8f 3f       	cpi	r24, 0xFF	; 255
    1616:	09 f4       	brne	.+2      	; 0x161a <xQueueGenericReceive+0xf4>
    1618:	16 8e       	std	Z+30, r1	; 0x1e
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    161e:	ce 01       	movw	r24, r28
    1620:	01 96       	adiw	r24, 0x01	; 1
    1622:	be 01       	movw	r22, r28
    1624:	6c 5f       	subi	r22, 0xFC	; 252
    1626:	7f 4f       	sbci	r23, 0xFF	; 255
    1628:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <xTaskCheckForTimeOut>
    162c:	88 23       	and	r24, r24
    162e:	51 f5       	brne	.+84     	; 0x1684 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1630:	c7 01       	movw	r24, r14
    1632:	0e 94 25 08 	call	0x104a	; 0x104a <prvIsQueueEmpty>
    1636:	88 23       	and	r24, r24
    1638:	f9 f0       	breq	.+62     	; 0x1678 <xQueueGenericReceive+0x152>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    163a:	f7 01       	movw	r30, r14
    163c:	80 81       	ld	r24, Z
    163e:	91 81       	ldd	r25, Z+1	; 0x01
    1640:	00 97       	sbiw	r24, 0x00	; 0
    1642:	51 f4       	brne	.+20     	; 0x1658 <xQueueGenericReceive+0x132>
					{
						taskENTER_CRITICAL();
    1644:	0f b6       	in	r0, 0x3f	; 63
    1646:	f8 94       	cli
    1648:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    164a:	f7 01       	movw	r30, r14
    164c:	82 81       	ldd	r24, Z+2	; 0x02
    164e:	93 81       	ldd	r25, Z+3	; 0x03
    1650:	0e 94 29 13 	call	0x2652	; 0x2652 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1654:	0f 90       	pop	r0
    1656:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1658:	6c 81       	ldd	r22, Y+4	; 0x04
    165a:	7d 81       	ldd	r23, Y+5	; 0x05
    165c:	c5 01       	movw	r24, r10
    165e:	0e 94 30 12 	call	0x2460	; 0x2460 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1662:	c7 01       	movw	r24, r14
    1664:	0e 94 4d 08 	call	0x109a	; 0x109a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1668:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
    166c:	88 23       	and	r24, r24
    166e:	09 f0       	breq	.+2      	; 0x1672 <xQueueGenericReceive+0x14c>
    1670:	7a cf       	rjmp	.-268    	; 0x1566 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    1672:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    1676:	77 cf       	rjmp	.-274    	; 0x1566 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1678:	c7 01       	movw	r24, r14
    167a:	0e 94 4d 08 	call	0x109a	; 0x109a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    167e:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
    1682:	71 cf       	rjmp	.-286    	; 0x1566 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1684:	c7 01       	movw	r24, r14
    1686:	0e 94 4d 08 	call	0x109a	; 0x109a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    168a:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    168e:	c7 01       	movw	r24, r14
    1690:	0e 94 25 08 	call	0x104a	; 0x104a <prvIsQueueEmpty>
    1694:	88 23       	and	r24, r24
    1696:	09 f4       	brne	.+2      	; 0x169a <xQueueGenericReceive+0x174>
    1698:	66 cf       	rjmp	.-308    	; 0x1566 <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    169a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    169c:	0f 90       	pop	r0
    169e:	0f 90       	pop	r0
    16a0:	0f 90       	pop	r0
    16a2:	0f 90       	pop	r0
    16a4:	0f 90       	pop	r0
    16a6:	df 91       	pop	r29
    16a8:	cf 91       	pop	r28
    16aa:	1f 91       	pop	r17
    16ac:	0f 91       	pop	r16
    16ae:	ff 90       	pop	r15
    16b0:	ef 90       	pop	r14
    16b2:	df 90       	pop	r13
    16b4:	cf 90       	pop	r12
    16b6:	bf 90       	pop	r11
    16b8:	af 90       	pop	r10
    16ba:	9f 90       	pop	r9
    16bc:	8f 90       	pop	r8
    16be:	08 95       	ret

000016c0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    16c0:	ef 92       	push	r14
    16c2:	ff 92       	push	r15
    16c4:	0f 93       	push	r16
    16c6:	1f 93       	push	r17
    16c8:	cf 93       	push	r28
    16ca:	df 93       	push	r29
    16cc:	8c 01       	movw	r16, r24
    16ce:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16d0:	fc 01       	movw	r30, r24
    16d2:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    16d4:	cc 23       	and	r28, r28
    16d6:	e9 f0       	breq	.+58     	; 0x1712 <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    16d8:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    16da:	0e 94 30 08 	call	0x1060	; 0x1060 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    16de:	c1 50       	subi	r28, 0x01	; 1
    16e0:	f8 01       	movw	r30, r16
    16e2:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    16e4:	df 3f       	cpi	r29, 0xFF	; 255
    16e6:	81 f4       	brne	.+32     	; 0x1708 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16e8:	80 85       	ldd	r24, Z+8	; 0x08
    16ea:	88 23       	and	r24, r24
    16ec:	a1 f0       	breq	.+40     	; 0x1716 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16ee:	c8 01       	movw	r24, r16
    16f0:	08 96       	adiw	r24, 0x08	; 8
    16f2:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <xTaskRemoveFromEventList>
    16f6:	88 23       	and	r24, r24
    16f8:	81 f0       	breq	.+32     	; 0x171a <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    16fa:	e1 14       	cp	r14, r1
    16fc:	f1 04       	cpc	r15, r1
    16fe:	79 f0       	breq	.+30     	; 0x171e <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1700:	81 e0       	ldi	r24, 0x01	; 1
    1702:	f7 01       	movw	r30, r14
    1704:	80 83       	st	Z, r24
    1706:	0c c0       	rjmp	.+24     	; 0x1720 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1708:	df 5f       	subi	r29, 0xFF	; 255
    170a:	f8 01       	movw	r30, r16
    170c:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	07 c0       	rjmp	.+14     	; 0x1720 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    1712:	80 e0       	ldi	r24, 0x00	; 0
    1714:	05 c0       	rjmp	.+10     	; 0x1720 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	03 c0       	rjmp	.+6      	; 0x1720 <xQueueReceiveFromISR+0x60>
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	01 c0       	rjmp	.+2      	; 0x1720 <xQueueReceiveFromISR+0x60>
    171e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1720:	df 91       	pop	r29
    1722:	cf 91       	pop	r28
    1724:	1f 91       	pop	r17
    1726:	0f 91       	pop	r16
    1728:	ff 90       	pop	r15
    172a:	ef 90       	pop	r14
    172c:	08 95       	ret

0000172e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    172e:	0f 93       	push	r16
    1730:	1f 93       	push	r17
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
    1736:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1738:	8a 8d       	ldd	r24, Y+26	; 0x1a
    173a:	88 23       	and	r24, r24
    173c:	49 f0       	breq	.+18     	; 0x1750 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    173e:	0e 81       	ldd	r16, Y+6	; 0x06
    1740:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1742:	ce 01       	movw	r24, r28
    1744:	0e 94 30 08 	call	0x1060	; 0x1060 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1748:	1f 83       	std	Y+7, r17	; 0x07
    174a:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    174c:	81 e0       	ldi	r24, 0x01	; 1
    174e:	01 c0       	rjmp	.+2      	; 0x1752 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1750:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1752:	df 91       	pop	r29
    1754:	cf 91       	pop	r28
    1756:	1f 91       	pop	r17
    1758:	0f 91       	pop	r16
    175a:	08 95       	ret

0000175c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    175c:	0f b6       	in	r0, 0x3f	; 63
    175e:	f8 94       	cli
    1760:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1762:	fc 01       	movw	r30, r24
    1764:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1766:	0f 90       	pop	r0
    1768:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    176a:	08 95       	ret

0000176c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    176c:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    176e:	0f b6       	in	r0, 0x3f	; 63
    1770:	f8 94       	cli
    1772:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1774:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1776:	0f 90       	pop	r0
    1778:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    177a:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    177c:	89 1b       	sub	r24, r25
    177e:	08 95       	ret

00001780 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1780:	fc 01       	movw	r30, r24
    1782:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1784:	08 95       	ret

00001786 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1786:	fc 01       	movw	r30, r24
    1788:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    178a:	81 e0       	ldi	r24, 0x01	; 1
    178c:	91 11       	cpse	r25, r1
    178e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1790:	08 95       	ret

00001792 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1792:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1794:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1796:	81 e0       	ldi	r24, 0x01	; 1
    1798:	93 8d       	ldd	r25, Z+27	; 0x1b
    179a:	29 13       	cpse	r18, r25
    179c:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    179e:	08 95       	ret

000017a0 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    17a0:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    17a2:	80 91 34 04 	lds	r24, 0x0434
    17a6:	90 91 35 04 	lds	r25, 0x0435
    17aa:	00 97       	sbiw	r24, 0x00	; 0
    17ac:	51 f0       	breq	.+20     	; 0x17c2 <vQueueAddToRegistry+0x22>
    17ae:	e8 e3       	ldi	r30, 0x38	; 56
    17b0:	f4 e0       	ldi	r31, 0x04	; 4
    17b2:	21 e0       	ldi	r18, 0x01	; 1
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	a9 01       	movw	r20, r18
    17b8:	80 81       	ld	r24, Z
    17ba:	91 81       	ldd	r25, Z+1	; 0x01
    17bc:	00 97       	sbiw	r24, 0x00	; 0
    17be:	79 f4       	brne	.+30     	; 0x17de <vQueueAddToRegistry+0x3e>
    17c0:	02 c0       	rjmp	.+4      	; 0x17c6 <vQueueAddToRegistry+0x26>
    17c2:	40 e0       	ldi	r20, 0x00	; 0
    17c4:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    17c6:	fa 01       	movw	r30, r20
    17c8:	ee 0f       	add	r30, r30
    17ca:	ff 1f       	adc	r31, r31
    17cc:	ee 0f       	add	r30, r30
    17ce:	ff 1f       	adc	r31, r31
    17d0:	ec 5c       	subi	r30, 0xCC	; 204
    17d2:	fb 4f       	sbci	r31, 0xFB	; 251
    17d4:	71 83       	std	Z+1, r23	; 0x01
    17d6:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    17d8:	b3 83       	std	Z+3, r27	; 0x03
    17da:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    17dc:	08 95       	ret
    17de:	2f 5f       	subi	r18, 0xFF	; 255
    17e0:	3f 4f       	sbci	r19, 0xFF	; 255
    17e2:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    17e4:	28 30       	cpi	r18, 0x08	; 8
    17e6:	31 05       	cpc	r19, r1
    17e8:	31 f7       	brne	.-52     	; 0x17b6 <vQueueAddToRegistry+0x16>
    17ea:	08 95       	ret

000017ec <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    17ec:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    17ee:	80 91 36 04 	lds	r24, 0x0436
    17f2:	90 91 37 04 	lds	r25, 0x0437
    17f6:	84 17       	cp	r24, r20
    17f8:	95 07       	cpc	r25, r21
    17fa:	59 f0       	breq	.+22     	; 0x1812 <pcQueueGetName+0x26>
    17fc:	ea e3       	ldi	r30, 0x3A	; 58
    17fe:	f4 e0       	ldi	r31, 0x04	; 4
    1800:	21 e0       	ldi	r18, 0x01	; 1
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	b9 01       	movw	r22, r18
    1806:	80 81       	ld	r24, Z
    1808:	91 81       	ldd	r25, Z+1	; 0x01
    180a:	84 17       	cp	r24, r20
    180c:	95 07       	cpc	r25, r21
    180e:	69 f4       	brne	.+26     	; 0x182a <pcQueueGetName+0x3e>
    1810:	02 c0       	rjmp	.+4      	; 0x1816 <pcQueueGetName+0x2a>
    1812:	60 e0       	ldi	r22, 0x00	; 0
    1814:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    1816:	fb 01       	movw	r30, r22
    1818:	ee 0f       	add	r30, r30
    181a:	ff 1f       	adc	r31, r31
    181c:	ee 0f       	add	r30, r30
    181e:	ff 1f       	adc	r31, r31
    1820:	ec 5c       	subi	r30, 0xCC	; 204
    1822:	fb 4f       	sbci	r31, 0xFB	; 251
    1824:	80 81       	ld	r24, Z
    1826:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    1828:	08 95       	ret
    182a:	2f 5f       	subi	r18, 0xFF	; 255
    182c:	3f 4f       	sbci	r19, 0xFF	; 255
    182e:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1830:	28 30       	cpi	r18, 0x08	; 8
    1832:	31 05       	cpc	r19, r1
    1834:	39 f7       	brne	.-50     	; 0x1804 <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    1836:	80 e0       	ldi	r24, 0x00	; 0
    1838:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    183a:	08 95       	ret

0000183c <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    183c:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    183e:	80 91 36 04 	lds	r24, 0x0436
    1842:	90 91 37 04 	lds	r25, 0x0437
    1846:	84 17       	cp	r24, r20
    1848:	95 07       	cpc	r25, r21
    184a:	59 f0       	breq	.+22     	; 0x1862 <vQueueUnregisterQueue+0x26>
    184c:	ea e3       	ldi	r30, 0x3A	; 58
    184e:	f4 e0       	ldi	r31, 0x04	; 4
    1850:	21 e0       	ldi	r18, 0x01	; 1
    1852:	30 e0       	ldi	r19, 0x00	; 0
    1854:	b9 01       	movw	r22, r18
    1856:	80 81       	ld	r24, Z
    1858:	91 81       	ldd	r25, Z+1	; 0x01
    185a:	84 17       	cp	r24, r20
    185c:	95 07       	cpc	r25, r21
    185e:	79 f4       	brne	.+30     	; 0x187e <vQueueUnregisterQueue+0x42>
    1860:	02 c0       	rjmp	.+4      	; 0x1866 <vQueueUnregisterQueue+0x2a>
    1862:	60 e0       	ldi	r22, 0x00	; 0
    1864:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    1866:	fb 01       	movw	r30, r22
    1868:	ee 0f       	add	r30, r30
    186a:	ff 1f       	adc	r31, r31
    186c:	ee 0f       	add	r30, r30
    186e:	ff 1f       	adc	r31, r31
    1870:	ec 5c       	subi	r30, 0xCC	; 204
    1872:	fb 4f       	sbci	r31, 0xFB	; 251
    1874:	11 82       	std	Z+1, r1	; 0x01
    1876:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    1878:	13 82       	std	Z+3, r1	; 0x03
    187a:	12 82       	std	Z+2, r1	; 0x02
				break;
    187c:	08 95       	ret
    187e:	2f 5f       	subi	r18, 0xFF	; 255
    1880:	3f 4f       	sbci	r19, 0xFF	; 255
    1882:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1884:	28 30       	cpi	r18, 0x08	; 8
    1886:	31 05       	cpc	r19, r1
    1888:	29 f7       	brne	.-54     	; 0x1854 <vQueueUnregisterQueue+0x18>
    188a:	08 95       	ret

0000188c <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
    1890:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    1892:	0e 94 1e 0c 	call	0x183c	; 0x183c <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1896:	ce 01       	movw	r24, r28
    1898:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    189c:	df 91       	pop	r29
    189e:	cf 91       	pop	r28
    18a0:	08 95       	ret

000018a2 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    18a2:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    18a4:	82 85       	ldd	r24, Z+10	; 0x0a
    18a6:	93 85       	ldd	r25, Z+11	; 0x0b
    18a8:	24 e0       	ldi	r18, 0x04	; 4
    18aa:	89 32       	cpi	r24, 0x29	; 41
    18ac:	92 07       	cpc	r25, r18
    18ae:	61 f4       	brne	.+24     	; 0x18c8 <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    18b0:	24 89       	ldd	r18, Z+20	; 0x14
    18b2:	35 89       	ldd	r19, Z+21	; 0x15
    18b4:	84 e0       	ldi	r24, 0x04	; 4
    18b6:	27 31       	cpi	r18, 0x17	; 23
    18b8:	38 07       	cpc	r19, r24
    18ba:	41 f0       	breq	.+16     	; 0x18cc <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	21 15       	cp	r18, r1
    18c0:	31 05       	cpc	r19, r1
    18c2:	29 f0       	breq	.+10     	; 0x18ce <prvTaskIsTaskSuspended+0x2c>
    18c4:	80 e0       	ldi	r24, 0x00	; 0
    18c6:	08 95       	ret
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	08 95       	ret
    18cc:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    18ce:	08 95       	ret

000018d0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    18d0:	e0 91 d5 03 	lds	r30, 0x03D5
    18d4:	f0 91 d6 03 	lds	r31, 0x03D6
    18d8:	80 81       	ld	r24, Z
    18da:	88 23       	and	r24, r24
    18dc:	39 f4       	brne	.+14     	; 0x18ec <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    18de:	8f ef       	ldi	r24, 0xFF	; 255
    18e0:	9f ef       	ldi	r25, 0xFF	; 255
    18e2:	90 93 c9 03 	sts	0x03C9, r25
    18e6:	80 93 c8 03 	sts	0x03C8, r24
    18ea:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    18ec:	e0 91 d5 03 	lds	r30, 0x03D5
    18f0:	f0 91 d6 03 	lds	r31, 0x03D6
    18f4:	05 80       	ldd	r0, Z+5	; 0x05
    18f6:	f6 81       	ldd	r31, Z+6	; 0x06
    18f8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    18fa:	06 80       	ldd	r0, Z+6	; 0x06
    18fc:	f7 81       	ldd	r31, Z+7	; 0x07
    18fe:	e0 2d       	mov	r30, r0
    1900:	82 81       	ldd	r24, Z+2	; 0x02
    1902:	93 81       	ldd	r25, Z+3	; 0x03
    1904:	90 93 c9 03 	sts	0x03C9, r25
    1908:	80 93 c8 03 	sts	0x03C8, r24
    190c:	08 95       	ret

0000190e <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    190e:	ef 92       	push	r14
    1910:	ff 92       	push	r15
    1912:	1f 93       	push	r17
    1914:	cf 93       	push	r28
    1916:	df 93       	push	r29
    1918:	ec 01       	movw	r28, r24
    191a:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    191c:	e0 90 cf 03 	lds	r14, 0x03CF
    1920:	f0 90 d0 03 	lds	r15, 0x03D0
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1924:	80 91 c5 03 	lds	r24, 0x03C5
    1928:	90 91 c6 03 	lds	r25, 0x03C6
    192c:	02 96       	adiw	r24, 0x02	; 2
    192e:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1932:	8f ef       	ldi	r24, 0xFF	; 255
    1934:	cf 3f       	cpi	r28, 0xFF	; 255
    1936:	d8 07       	cpc	r29, r24
    1938:	69 f4       	brne	.+26     	; 0x1954 <prvAddCurrentTaskToDelayedList+0x46>
    193a:	11 23       	and	r17, r17
    193c:	59 f0       	breq	.+22     	; 0x1954 <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    193e:	60 91 c5 03 	lds	r22, 0x03C5
    1942:	70 91 c6 03 	lds	r23, 0x03C6
    1946:	6e 5f       	subi	r22, 0xFE	; 254
    1948:	7f 4f       	sbci	r23, 0xFF	; 255
    194a:	89 e2       	ldi	r24, 0x29	; 41
    194c:	94 e0       	ldi	r25, 0x04	; 4
    194e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
    1952:	2f c0       	rjmp	.+94     	; 0x19b2 <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1954:	ce 0d       	add	r28, r14
    1956:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1958:	e0 91 c5 03 	lds	r30, 0x03C5
    195c:	f0 91 c6 03 	lds	r31, 0x03C6
    1960:	d3 83       	std	Z+3, r29	; 0x03
    1962:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    1964:	ce 15       	cp	r28, r14
    1966:	df 05       	cpc	r29, r15
    1968:	68 f4       	brcc	.+26     	; 0x1984 <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    196a:	80 91 d3 03 	lds	r24, 0x03D3
    196e:	90 91 d4 03 	lds	r25, 0x03D4
    1972:	60 91 c5 03 	lds	r22, 0x03C5
    1976:	70 91 c6 03 	lds	r23, 0x03C6
    197a:	6e 5f       	subi	r22, 0xFE	; 254
    197c:	7f 4f       	sbci	r23, 0xFF	; 255
    197e:	0e 94 4c 06 	call	0xc98	; 0xc98 <vListInsert>
    1982:	17 c0       	rjmp	.+46     	; 0x19b2 <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1984:	80 91 d5 03 	lds	r24, 0x03D5
    1988:	90 91 d6 03 	lds	r25, 0x03D6
    198c:	60 91 c5 03 	lds	r22, 0x03C5
    1990:	70 91 c6 03 	lds	r23, 0x03C6
    1994:	6e 5f       	subi	r22, 0xFE	; 254
    1996:	7f 4f       	sbci	r23, 0xFF	; 255
    1998:	0e 94 4c 06 	call	0xc98	; 0xc98 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    199c:	80 91 c8 03 	lds	r24, 0x03C8
    19a0:	90 91 c9 03 	lds	r25, 0x03C9
    19a4:	c8 17       	cp	r28, r24
    19a6:	d9 07       	cpc	r29, r25
    19a8:	20 f4       	brcc	.+8      	; 0x19b2 <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    19aa:	d0 93 c9 03 	sts	0x03C9, r29
    19ae:	c0 93 c8 03 	sts	0x03C8, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    19b2:	df 91       	pop	r29
    19b4:	cf 91       	pop	r28
    19b6:	1f 91       	pop	r17
    19b8:	ff 90       	pop	r15
    19ba:	ef 90       	pop	r14
    19bc:	08 95       	ret

000019be <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    19be:	cf 93       	push	r28
    19c0:	df 93       	push	r29
    19c2:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    19c4:	8f 89       	ldd	r24, Y+23	; 0x17
    19c6:	98 8d       	ldd	r25, Y+24	; 0x18
    19c8:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vPortFree>
			vPortFree( pxTCB );
    19cc:	ce 01       	movw	r24, r28
    19ce:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	08 95       	ret

000019d8 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    19d8:	2f 92       	push	r2
    19da:	3f 92       	push	r3
    19dc:	4f 92       	push	r4
    19de:	5f 92       	push	r5
    19e0:	6f 92       	push	r6
    19e2:	7f 92       	push	r7
    19e4:	8f 92       	push	r8
    19e6:	9f 92       	push	r9
    19e8:	af 92       	push	r10
    19ea:	bf 92       	push	r11
    19ec:	df 92       	push	r13
    19ee:	ef 92       	push	r14
    19f0:	ff 92       	push	r15
    19f2:	0f 93       	push	r16
    19f4:	1f 93       	push	r17
    19f6:	cf 93       	push	r28
    19f8:	df 93       	push	r29
    19fa:	3c 01       	movw	r6, r24
    19fc:	5b 01       	movw	r10, r22
    19fe:	ea 01       	movw	r28, r20
    1a00:	29 01       	movw	r4, r18
    1a02:	d0 2e       	mov	r13, r16
    1a04:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a06:	ca 01       	movw	r24, r20
    1a08:	0e 94 42 05 	call	0xa84	; 0xa84 <pvPortMalloc>
    1a0c:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	09 f4       	brne	.+2      	; 0x1a14 <xTaskCreate+0x3c>
    1a12:	ed c0       	rjmp	.+474    	; 0x1bee <xTaskCreate+0x216>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1a14:	8a e2       	ldi	r24, 0x2A	; 42
    1a16:	90 e0       	ldi	r25, 0x00	; 0
    1a18:	0e 94 42 05 	call	0xa84	; 0xa84 <pvPortMalloc>
    1a1c:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    1a1e:	00 97       	sbiw	r24, 0x00	; 0
    1a20:	81 f0       	breq	.+32     	; 0x1a42 <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1a22:	fc 01       	movw	r30, r24
    1a24:	f0 8e       	std	Z+24, r15	; 0x18
    1a26:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1a28:	21 97       	sbiw	r28, 0x01	; 1
    1a2a:	17 01       	movw	r2, r14
    1a2c:	2c 0e       	add	r2, r28
    1a2e:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1a30:	f5 01       	movw	r30, r10
    1a32:	80 81       	ld	r24, Z
    1a34:	f8 01       	movw	r30, r16
    1a36:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1a38:	f5 01       	movw	r30, r10
    1a3a:	80 81       	ld	r24, Z
    1a3c:	88 23       	and	r24, r24
    1a3e:	31 f4       	brne	.+12     	; 0x1a4c <xTaskCreate+0x74>
    1a40:	13 c0       	rjmp	.+38     	; 0x1a68 <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1a42:	c7 01       	movw	r24, r14
    1a44:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a48:	8f ef       	ldi	r24, 0xFF	; 255
    1a4a:	d6 c0       	rjmp	.+428    	; 0x1bf8 <xTaskCreate+0x220>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1a4c:	e8 01       	movw	r28, r16
    1a4e:	6a 96       	adiw	r28, 0x1a	; 26
    1a50:	d5 01       	movw	r26, r10
    1a52:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1a54:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1a56:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1a58:	9d 91       	ld	r25, X+
    1a5a:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1a5c:	90 81       	ld	r25, Z
    1a5e:	99 23       	and	r25, r25
    1a60:	19 f0       	breq	.+6      	; 0x1a68 <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1a62:	8f 5f       	subi	r24, 0xFF	; 255
    1a64:	8a 30       	cpi	r24, 0x0A	; 10
    1a66:	b9 f7       	brne	.-18     	; 0x1a56 <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1a68:	f8 01       	movw	r30, r16
    1a6a:	12 a2       	lds	r17, 0x92
    1a6c:	cd 2d       	mov	r28, r13
    1a6e:	c5 30       	cpi	r28, 0x05	; 5
    1a70:	08 f0       	brcs	.+2      	; 0x1a74 <xTaskCreate+0x9c>
    1a72:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1a74:	f8 01       	movw	r30, r16
    1a76:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    1a78:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    1a7a:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1a7c:	ee 24       	eor	r14, r14
    1a7e:	ff 24       	eor	r15, r15
    1a80:	68 94       	set
    1a82:	e1 f8       	bld	r14, 1
    1a84:	e0 0e       	add	r14, r16
    1a86:	f1 1e       	adc	r15, r17
    1a88:	c7 01       	movw	r24, r14
    1a8a:	0e 94 29 06 	call	0xc52	; 0xc52 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1a8e:	c8 01       	movw	r24, r16
    1a90:	0c 96       	adiw	r24, 0x0c	; 12
    1a92:	0e 94 29 06 	call	0xc52	; 0xc52 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1a96:	f8 01       	movw	r30, r16
    1a98:	11 87       	std	Z+9, r17	; 0x09
    1a9a:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a9c:	85 e0       	ldi	r24, 0x05	; 5
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	8c 1b       	sub	r24, r28
    1aa2:	91 09       	sbc	r25, r1
    1aa4:	95 87       	std	Z+13, r25	; 0x0d
    1aa6:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1aa8:	13 8b       	std	Z+19, r17	; 0x13
    1aaa:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1aac:	15 a2       	lds	r17, 0x95
    1aae:	16 a2       	lds	r17, 0x96
    1ab0:	17 a2       	lds	r17, 0x97
    1ab2:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1ab4:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1ab6:	c1 01       	movw	r24, r2
    1ab8:	b3 01       	movw	r22, r6
    1aba:	a2 01       	movw	r20, r4
    1abc:	0e 94 a6 06 	call	0xd4c	; 0xd4c <pxPortInitialiseStack>
    1ac0:	f8 01       	movw	r30, r16
    1ac2:	91 83       	std	Z+1, r25	; 0x01
    1ac4:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1ac6:	81 14       	cp	r8, r1
    1ac8:	91 04       	cpc	r9, r1
    1aca:	19 f0       	breq	.+6      	; 0x1ad2 <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1acc:	f4 01       	movw	r30, r8
    1ace:	11 83       	std	Z+1, r17	; 0x01
    1ad0:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1ad2:	0f b6       	in	r0, 0x3f	; 63
    1ad4:	f8 94       	cli
    1ad6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1ad8:	80 91 d1 03 	lds	r24, 0x03D1
    1adc:	8f 5f       	subi	r24, 0xFF	; 255
    1ade:	80 93 d1 03 	sts	0x03D1, r24
		if( pxCurrentTCB == NULL )
    1ae2:	80 91 c5 03 	lds	r24, 0x03C5
    1ae6:	90 91 c6 03 	lds	r25, 0x03C6
    1aea:	00 97       	sbiw	r24, 0x00	; 0
    1aec:	09 f0       	breq	.+2      	; 0x1af0 <xTaskCreate+0x118>
    1aee:	3f c0       	rjmp	.+126    	; 0x1b6e <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1af0:	10 93 c6 03 	sts	0x03C6, r17
    1af4:	00 93 c5 03 	sts	0x03C5, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1af8:	80 91 d1 03 	lds	r24, 0x03D1
    1afc:	81 30       	cpi	r24, 0x01	; 1
    1afe:	09 f0       	breq	.+2      	; 0x1b02 <xTaskCreate+0x12a>
    1b00:	47 c0       	rjmp	.+142    	; 0x1b90 <xTaskCreate+0x1b8>
    1b02:	c0 e0       	ldi	r28, 0x00	; 0
    1b04:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1b06:	ce 01       	movw	r24, r28
    1b08:	88 0f       	add	r24, r24
    1b0a:	99 1f       	adc	r25, r25
    1b0c:	88 0f       	add	r24, r24
    1b0e:	99 1f       	adc	r25, r25
    1b10:	88 0f       	add	r24, r24
    1b12:	99 1f       	adc	r25, r25
    1b14:	8c 0f       	add	r24, r28
    1b16:	9d 1f       	adc	r25, r29
    1b18:	88 52       	subi	r24, 0x28	; 40
    1b1a:	9c 4f       	sbci	r25, 0xFC	; 252
    1b1c:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
    1b20:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1b22:	c5 30       	cpi	r28, 0x05	; 5
    1b24:	d1 05       	cpc	r29, r1
    1b26:	79 f7       	brne	.-34     	; 0x1b06 <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1b28:	c5 e0       	ldi	r28, 0x05	; 5
    1b2a:	d4 e0       	ldi	r29, 0x04	; 4
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1b32:	0f 2e       	mov	r0, r31
    1b34:	fe e0       	ldi	r31, 0x0E	; 14
    1b36:	af 2e       	mov	r10, r31
    1b38:	f4 e0       	ldi	r31, 0x04	; 4
    1b3a:	bf 2e       	mov	r11, r31
    1b3c:	f0 2d       	mov	r31, r0
    1b3e:	c5 01       	movw	r24, r10
    1b40:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1b44:	87 e1       	ldi	r24, 0x17	; 23
    1b46:	94 e0       	ldi	r25, 0x04	; 4
    1b48:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1b4c:	80 e2       	ldi	r24, 0x20	; 32
    1b4e:	94 e0       	ldi	r25, 0x04	; 4
    1b50:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1b54:	89 e2       	ldi	r24, 0x29	; 41
    1b56:	94 e0       	ldi	r25, 0x04	; 4
    1b58:	0e 94 1b 06 	call	0xc36	; 0xc36 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1b5c:	d0 93 d6 03 	sts	0x03D6, r29
    1b60:	c0 93 d5 03 	sts	0x03D5, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1b64:	b0 92 d4 03 	sts	0x03D4, r11
    1b68:	a0 92 d3 03 	sts	0x03D3, r10
    1b6c:	11 c0       	rjmp	.+34     	; 0x1b90 <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1b6e:	80 91 cd 03 	lds	r24, 0x03CD
    1b72:	88 23       	and	r24, r24
    1b74:	69 f4       	brne	.+26     	; 0x1b90 <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1b76:	e0 91 c5 03 	lds	r30, 0x03C5
    1b7a:	f0 91 c6 03 	lds	r31, 0x03C6
    1b7e:	96 89       	ldd	r25, Z+22	; 0x16
    1b80:	f8 01       	movw	r30, r16
    1b82:	86 89       	ldd	r24, Z+22	; 0x16
    1b84:	89 17       	cp	r24, r25
    1b86:	20 f0       	brcs	.+8      	; 0x1b90 <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    1b88:	10 93 c6 03 	sts	0x03C6, r17
    1b8c:	00 93 c5 03 	sts	0x03C5, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1b90:	80 91 d7 03 	lds	r24, 0x03D7
    1b94:	8f 5f       	subi	r24, 0xFF	; 255
    1b96:	80 93 d7 03 	sts	0x03D7, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1b9a:	f8 01       	movw	r30, r16
    1b9c:	86 89       	ldd	r24, Z+22	; 0x16
    1b9e:	90 91 ce 03 	lds	r25, 0x03CE
    1ba2:	98 17       	cp	r25, r24
    1ba4:	10 f4       	brcc	.+4      	; 0x1baa <xTaskCreate+0x1d2>
    1ba6:	80 93 ce 03 	sts	0x03CE, r24
    1baa:	90 e0       	ldi	r25, 0x00	; 0
    1bac:	9c 01       	movw	r18, r24
    1bae:	22 0f       	add	r18, r18
    1bb0:	33 1f       	adc	r19, r19
    1bb2:	22 0f       	add	r18, r18
    1bb4:	33 1f       	adc	r19, r19
    1bb6:	22 0f       	add	r18, r18
    1bb8:	33 1f       	adc	r19, r19
    1bba:	82 0f       	add	r24, r18
    1bbc:	93 1f       	adc	r25, r19
    1bbe:	88 52       	subi	r24, 0x28	; 40
    1bc0:	9c 4f       	sbci	r25, 0xFC	; 252
    1bc2:	b7 01       	movw	r22, r14
    1bc4:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1bc8:	0f 90       	pop	r0
    1bca:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1bcc:	80 91 cd 03 	lds	r24, 0x03CD
    1bd0:	88 23       	and	r24, r24
    1bd2:	79 f0       	breq	.+30     	; 0x1bf2 <xTaskCreate+0x21a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1bd4:	e0 91 c5 03 	lds	r30, 0x03C5
    1bd8:	f0 91 c6 03 	lds	r31, 0x03C6
    1bdc:	96 89       	ldd	r25, Z+22	; 0x16
    1bde:	f8 01       	movw	r30, r16
    1be0:	86 89       	ldd	r24, Z+22	; 0x16
    1be2:	98 17       	cp	r25, r24
    1be4:	40 f4       	brcc	.+16     	; 0x1bf6 <xTaskCreate+0x21e>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1be6:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1bea:	81 e0       	ldi	r24, 0x01	; 1
    1bec:	05 c0       	rjmp	.+10     	; 0x1bf8 <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1bee:	8f ef       	ldi	r24, 0xFF	; 255
    1bf0:	03 c0       	rjmp	.+6      	; 0x1bf8 <xTaskCreate+0x220>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
    1bf4:	01 c0       	rjmp	.+2      	; 0x1bf8 <xTaskCreate+0x220>
    1bf6:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1bf8:	df 91       	pop	r29
    1bfa:	cf 91       	pop	r28
    1bfc:	1f 91       	pop	r17
    1bfe:	0f 91       	pop	r16
    1c00:	ff 90       	pop	r15
    1c02:	ef 90       	pop	r14
    1c04:	df 90       	pop	r13
    1c06:	bf 90       	pop	r11
    1c08:	af 90       	pop	r10
    1c0a:	9f 90       	pop	r9
    1c0c:	8f 90       	pop	r8
    1c0e:	7f 90       	pop	r7
    1c10:	6f 90       	pop	r6
    1c12:	5f 90       	pop	r5
    1c14:	4f 90       	pop	r4
    1c16:	3f 90       	pop	r3
    1c18:	2f 90       	pop	r2
    1c1a:	08 95       	ret

00001c1c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1c1c:	0f 93       	push	r16
    1c1e:	1f 93       	push	r17
    1c20:	cf 93       	push	r28
    1c22:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1c2a:	00 97       	sbiw	r24, 0x00	; 0
    1c2c:	29 f4       	brne	.+10     	; 0x1c38 <vTaskDelete+0x1c>
    1c2e:	c0 91 c5 03 	lds	r28, 0x03C5
    1c32:	d0 91 c6 03 	lds	r29, 0x03C6
    1c36:	01 c0       	rjmp	.+2      	; 0x1c3a <vTaskDelete+0x1e>
    1c38:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1c3a:	8e 01       	movw	r16, r28
    1c3c:	0e 5f       	subi	r16, 0xFE	; 254
    1c3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c40:	c8 01       	movw	r24, r16
    1c42:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1c46:	8c 89       	ldd	r24, Y+20	; 0x14
    1c48:	9d 89       	ldd	r25, Y+21	; 0x15
    1c4a:	00 97       	sbiw	r24, 0x00	; 0
    1c4c:	21 f0       	breq	.+8      	; 0x1c56 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1c4e:	ce 01       	movw	r24, r28
    1c50:	0c 96       	adiw	r24, 0x0c	; 12
    1c52:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1c56:	80 91 d7 03 	lds	r24, 0x03D7
    1c5a:	8f 5f       	subi	r24, 0xFF	; 255
    1c5c:	80 93 d7 03 	sts	0x03D7, r24

			if( pxTCB == pxCurrentTCB )
    1c60:	80 91 c5 03 	lds	r24, 0x03C5
    1c64:	90 91 c6 03 	lds	r25, 0x03C6
    1c68:	c8 17       	cp	r28, r24
    1c6a:	d9 07       	cpc	r29, r25
    1c6c:	59 f4       	brne	.+22     	; 0x1c84 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1c6e:	80 e2       	ldi	r24, 0x20	; 32
    1c70:	94 e0       	ldi	r25, 0x04	; 4
    1c72:	b8 01       	movw	r22, r16
    1c74:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1c78:	80 91 d2 03 	lds	r24, 0x03D2
    1c7c:	8f 5f       	subi	r24, 0xFF	; 255
    1c7e:	80 93 d2 03 	sts	0x03D2, r24
    1c82:	0a c0       	rjmp	.+20     	; 0x1c98 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1c84:	80 91 d1 03 	lds	r24, 0x03D1
    1c88:	81 50       	subi	r24, 0x01	; 1
    1c8a:	80 93 d1 03 	sts	0x03D1, r24
				prvDeleteTCB( pxTCB );
    1c8e:	ce 01       	movw	r24, r28
    1c90:	0e 94 df 0c 	call	0x19be	; 0x19be <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1c94:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1c98:	0f 90       	pop	r0
    1c9a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1c9c:	80 91 cd 03 	lds	r24, 0x03CD
    1ca0:	88 23       	and	r24, r24
    1ca2:	49 f0       	breq	.+18     	; 0x1cb6 <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    1ca4:	80 91 c5 03 	lds	r24, 0x03C5
    1ca8:	90 91 c6 03 	lds	r25, 0x03C6
    1cac:	c8 17       	cp	r28, r24
    1cae:	d9 07       	cpc	r29, r25
    1cb0:	11 f4       	brne	.+4      	; 0x1cb6 <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1cb2:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	1f 91       	pop	r17
    1cbc:	0f 91       	pop	r16
    1cbe:	08 95       	ret

00001cc0 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1cc0:	0f b6       	in	r0, 0x3f	; 63
    1cc2:	f8 94       	cli
    1cc4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1cc6:	00 97       	sbiw	r24, 0x00	; 0
    1cc8:	29 f4       	brne	.+10     	; 0x1cd4 <uxTaskPriorityGet+0x14>
    1cca:	e0 91 c5 03 	lds	r30, 0x03C5
    1cce:	f0 91 c6 03 	lds	r31, 0x03C6
    1cd2:	01 c0       	rjmp	.+2      	; 0x1cd6 <uxTaskPriorityGet+0x16>
    1cd4:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1cd6:	0f 90       	pop	r0
    1cd8:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1cda:	86 89       	ldd	r24, Z+22	; 0x16
    1cdc:	08 95       	ret

00001cde <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1cde:	00 97       	sbiw	r24, 0x00	; 0
    1ce0:	29 f4       	brne	.+10     	; 0x1cec <uxTaskPriorityGetFromISR+0xe>
    1ce2:	e0 91 c5 03 	lds	r30, 0x03C5
    1ce6:	f0 91 c6 03 	lds	r31, 0x03C6
    1cea:	01 c0       	rjmp	.+2      	; 0x1cee <uxTaskPriorityGetFromISR+0x10>
    1cec:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1cee:	86 89       	ldd	r24, Z+22	; 0x16
    1cf0:	08 95       	ret

00001cf2 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1cf2:	ef 92       	push	r14
    1cf4:	ff 92       	push	r15
    1cf6:	1f 93       	push	r17
    1cf8:	cf 93       	push	r28
    1cfa:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1cfc:	65 30       	cpi	r22, 0x05	; 5
    1cfe:	08 f0       	brcs	.+2      	; 0x1d02 <vTaskPrioritySet+0x10>
    1d00:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1d02:	0f b6       	in	r0, 0x3f	; 63
    1d04:	f8 94       	cli
    1d06:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1d08:	00 97       	sbiw	r24, 0x00	; 0
    1d0a:	29 f4       	brne	.+10     	; 0x1d16 <vTaskPrioritySet+0x24>
    1d0c:	c0 91 c5 03 	lds	r28, 0x03C5
    1d10:	d0 91 c6 03 	lds	r29, 0x03C6
    1d14:	01 c0       	rjmp	.+2      	; 0x1d18 <vTaskPrioritySet+0x26>
    1d16:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1d18:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1d1a:	26 17       	cp	r18, r22
    1d1c:	09 f4       	brne	.+2      	; 0x1d20 <vTaskPrioritySet+0x2e>
    1d1e:	61 c0       	rjmp	.+194    	; 0x1de2 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1d20:	26 17       	cp	r18, r22
    1d22:	88 f4       	brcc	.+34     	; 0x1d46 <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    1d24:	80 91 c5 03 	lds	r24, 0x03C5
    1d28:	90 91 c6 03 	lds	r25, 0x03C6
    1d2c:	c8 17       	cp	r28, r24
    1d2e:	d9 07       	cpc	r29, r25
    1d30:	a1 f0       	breq	.+40     	; 0x1d5a <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1d32:	e0 91 c5 03 	lds	r30, 0x03C5
    1d36:	f0 91 c6 03 	lds	r31, 0x03C6
						{
							xYieldRequired = pdTRUE;
    1d3a:	11 e0       	ldi	r17, 0x01	; 1
    1d3c:	86 89       	ldd	r24, Z+22	; 0x16
    1d3e:	68 17       	cp	r22, r24
    1d40:	68 f4       	brcc	.+26     	; 0x1d5c <vTaskPrioritySet+0x6a>
    1d42:	10 e0       	ldi	r17, 0x00	; 0
    1d44:	0b c0       	rjmp	.+22     	; 0x1d5c <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1d46:	80 91 c5 03 	lds	r24, 0x03C5
    1d4a:	90 91 c6 03 	lds	r25, 0x03C6
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    1d4e:	11 e0       	ldi	r17, 0x01	; 1
    1d50:	c8 17       	cp	r28, r24
    1d52:	d9 07       	cpc	r29, r25
    1d54:	19 f0       	breq	.+6      	; 0x1d5c <vTaskPrioritySet+0x6a>
    1d56:	10 e0       	ldi	r17, 0x00	; 0
    1d58:	01 c0       	rjmp	.+2      	; 0x1d5c <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1d5a:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1d5c:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1d5e:	28 17       	cp	r18, r24
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    1d62:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1d64:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1d66:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d68:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d6a:	33 23       	and	r19, r19
    1d6c:	34 f0       	brlt	.+12     	; 0x1d7a <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d6e:	25 e0       	ldi	r18, 0x05	; 5
    1d70:	30 e0       	ldi	r19, 0x00	; 0
    1d72:	26 1b       	sub	r18, r22
    1d74:	31 09       	sbc	r19, r1
    1d76:	3d 87       	std	Y+13, r19	; 0x0d
    1d78:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	9c 01       	movw	r18, r24
    1d7e:	22 0f       	add	r18, r18
    1d80:	33 1f       	adc	r19, r19
    1d82:	22 0f       	add	r18, r18
    1d84:	33 1f       	adc	r19, r19
    1d86:	22 0f       	add	r18, r18
    1d88:	33 1f       	adc	r19, r19
    1d8a:	82 0f       	add	r24, r18
    1d8c:	93 1f       	adc	r25, r19
    1d8e:	88 52       	subi	r24, 0x28	; 40
    1d90:	9c 4f       	sbci	r25, 0xFC	; 252
    1d92:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d94:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d96:	28 17       	cp	r18, r24
    1d98:	39 07       	cpc	r19, r25
    1d9a:	f9 f4       	brne	.+62     	; 0x1dda <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1d9c:	ee 24       	eor	r14, r14
    1d9e:	ff 24       	eor	r15, r15
    1da0:	68 94       	set
    1da2:	e1 f8       	bld	r14, 1
    1da4:	ec 0e       	add	r14, r28
    1da6:	fd 1e       	adc	r15, r29
    1da8:	c7 01       	movw	r24, r14
    1daa:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1dae:	8e 89       	ldd	r24, Y+22	; 0x16
    1db0:	90 91 ce 03 	lds	r25, 0x03CE
    1db4:	98 17       	cp	r25, r24
    1db6:	10 f4       	brcc	.+4      	; 0x1dbc <vTaskPrioritySet+0xca>
    1db8:	80 93 ce 03 	sts	0x03CE, r24
    1dbc:	90 e0       	ldi	r25, 0x00	; 0
    1dbe:	9c 01       	movw	r18, r24
    1dc0:	22 0f       	add	r18, r18
    1dc2:	33 1f       	adc	r19, r19
    1dc4:	22 0f       	add	r18, r18
    1dc6:	33 1f       	adc	r19, r19
    1dc8:	22 0f       	add	r18, r18
    1dca:	33 1f       	adc	r19, r19
    1dcc:	82 0f       	add	r24, r18
    1dce:	93 1f       	adc	r25, r19
    1dd0:	88 52       	subi	r24, 0x28	; 40
    1dd2:	9c 4f       	sbci	r25, 0xFC	; 252
    1dd4:	b7 01       	movw	r22, r14
    1dd6:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    1dda:	11 23       	and	r17, r17
    1ddc:	11 f0       	breq	.+4      	; 0x1de2 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    1dde:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1de2:	0f 90       	pop	r0
    1de4:	0f be       	out	0x3f, r0	; 63
	}
    1de6:	df 91       	pop	r29
    1de8:	cf 91       	pop	r28
    1dea:	1f 91       	pop	r17
    1dec:	ff 90       	pop	r15
    1dee:	ef 90       	pop	r14
    1df0:	08 95       	ret

00001df2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    1df2:	0f 93       	push	r16
    1df4:	1f 93       	push	r17
    1df6:	cf 93       	push	r28
    1df8:	df 93       	push	r29
    1dfa:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1dfc:	00 97       	sbiw	r24, 0x00	; 0
    1dfe:	b9 f1       	breq	.+110    	; 0x1e6e <vTaskResume+0x7c>
    1e00:	80 91 c5 03 	lds	r24, 0x03C5
    1e04:	90 91 c6 03 	lds	r25, 0x03C6
    1e08:	c8 17       	cp	r28, r24
    1e0a:	d9 07       	cpc	r29, r25
    1e0c:	81 f1       	breq	.+96     	; 0x1e6e <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    1e0e:	0f b6       	in	r0, 0x3f	; 63
    1e10:	f8 94       	cli
    1e12:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1e14:	ce 01       	movw	r24, r28
    1e16:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <prvTaskIsTaskSuspended>
    1e1a:	88 23       	and	r24, r24
    1e1c:	31 f1       	breq	.+76     	; 0x1e6a <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    1e1e:	8e 01       	movw	r16, r28
    1e20:	0e 5f       	subi	r16, 0xFE	; 254
    1e22:	1f 4f       	sbci	r17, 0xFF	; 255
    1e24:	c8 01       	movw	r24, r16
    1e26:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1e2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1e2c:	90 91 ce 03 	lds	r25, 0x03CE
    1e30:	98 17       	cp	r25, r24
    1e32:	10 f4       	brcc	.+4      	; 0x1e38 <vTaskResume+0x46>
    1e34:	80 93 ce 03 	sts	0x03CE, r24
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	9c 01       	movw	r18, r24
    1e3c:	22 0f       	add	r18, r18
    1e3e:	33 1f       	adc	r19, r19
    1e40:	22 0f       	add	r18, r18
    1e42:	33 1f       	adc	r19, r19
    1e44:	22 0f       	add	r18, r18
    1e46:	33 1f       	adc	r19, r19
    1e48:	82 0f       	add	r24, r18
    1e4a:	93 1f       	adc	r25, r19
    1e4c:	88 52       	subi	r24, 0x28	; 40
    1e4e:	9c 4f       	sbci	r25, 0xFC	; 252
    1e50:	b8 01       	movw	r22, r16
    1e52:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e56:	e0 91 c5 03 	lds	r30, 0x03C5
    1e5a:	f0 91 c6 03 	lds	r31, 0x03C6
    1e5e:	9e 89       	ldd	r25, Y+22	; 0x16
    1e60:	86 89       	ldd	r24, Z+22	; 0x16
    1e62:	98 17       	cp	r25, r24
    1e64:	10 f0       	brcs	.+4      	; 0x1e6a <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    1e66:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1e6e:	df 91       	pop	r29
    1e70:	cf 91       	pop	r28
    1e72:	1f 91       	pop	r17
    1e74:	0f 91       	pop	r16
    1e76:	08 95       	ret

00001e78 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    1e78:	ef 92       	push	r14
    1e7a:	ff 92       	push	r15
    1e7c:	1f 93       	push	r17
    1e7e:	cf 93       	push	r28
    1e80:	df 93       	push	r29
    1e82:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1e84:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <prvTaskIsTaskSuspended>
    1e88:	88 23       	and	r24, r24
    1e8a:	b9 f1       	breq	.+110    	; 0x1efa <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e8c:	80 91 c7 03 	lds	r24, 0x03C7
    1e90:	88 23       	and	r24, r24
    1e92:	51 f5       	brne	.+84     	; 0x1ee8 <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e94:	e0 91 c5 03 	lds	r30, 0x03C5
    1e98:	f0 91 c6 03 	lds	r31, 0x03C6

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1e9c:	11 e0       	ldi	r17, 0x01	; 1
    1e9e:	9e 89       	ldd	r25, Y+22	; 0x16
    1ea0:	86 89       	ldd	r24, Z+22	; 0x16
    1ea2:	98 17       	cp	r25, r24
    1ea4:	08 f4       	brcc	.+2      	; 0x1ea8 <xTaskResumeFromISR+0x30>
    1ea6:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1ea8:	ee 24       	eor	r14, r14
    1eaa:	ff 24       	eor	r15, r15
    1eac:	68 94       	set
    1eae:	e1 f8       	bld	r14, 1
    1eb0:	ec 0e       	add	r14, r28
    1eb2:	fd 1e       	adc	r15, r29
    1eb4:	c7 01       	movw	r24, r14
    1eb6:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1eba:	8e 89       	ldd	r24, Y+22	; 0x16
    1ebc:	90 91 ce 03 	lds	r25, 0x03CE
    1ec0:	98 17       	cp	r25, r24
    1ec2:	10 f4       	brcc	.+4      	; 0x1ec8 <xTaskResumeFromISR+0x50>
    1ec4:	80 93 ce 03 	sts	0x03CE, r24
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	9c 01       	movw	r18, r24
    1ecc:	22 0f       	add	r18, r18
    1ece:	33 1f       	adc	r19, r19
    1ed0:	22 0f       	add	r18, r18
    1ed2:	33 1f       	adc	r19, r19
    1ed4:	22 0f       	add	r18, r18
    1ed6:	33 1f       	adc	r19, r19
    1ed8:	82 0f       	add	r24, r18
    1eda:	93 1f       	adc	r25, r19
    1edc:	88 52       	subi	r24, 0x28	; 40
    1ede:	9c 4f       	sbci	r25, 0xFC	; 252
    1ee0:	b7 01       	movw	r22, r14
    1ee2:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
    1ee6:	0a c0       	rjmp	.+20     	; 0x1efc <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1ee8:	be 01       	movw	r22, r28
    1eea:	64 5f       	subi	r22, 0xF4	; 244
    1eec:	7f 4f       	sbci	r23, 0xFF	; 255
    1eee:	87 e1       	ldi	r24, 0x17	; 23
    1ef0:	94 e0       	ldi	r25, 0x04	; 4
    1ef2:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1ef6:	10 e0       	ldi	r17, 0x00	; 0
    1ef8:	01 c0       	rjmp	.+2      	; 0x1efc <xTaskResumeFromISR+0x84>
    1efa:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    1efc:	81 2f       	mov	r24, r17
    1efe:	df 91       	pop	r29
    1f00:	cf 91       	pop	r28
    1f02:	1f 91       	pop	r17
    1f04:	ff 90       	pop	r15
    1f06:	ef 90       	pop	r14
    1f08:	08 95       	ret

00001f0a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1f0a:	ef 92       	push	r14
    1f0c:	ff 92       	push	r15
    1f0e:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1f10:	8a ef       	ldi	r24, 0xFA	; 250
    1f12:	90 e1       	ldi	r25, 0x10	; 16
    1f14:	62 e6       	ldi	r22, 0x62	; 98
    1f16:	70 e0       	ldi	r23, 0x00	; 0
    1f18:	48 ec       	ldi	r20, 0xC8	; 200
    1f1a:	50 e0       	ldi	r21, 0x00	; 0
    1f1c:	20 e0       	ldi	r18, 0x00	; 0
    1f1e:	30 e0       	ldi	r19, 0x00	; 0
    1f20:	00 e0       	ldi	r16, 0x00	; 0
    1f22:	0f 2e       	mov	r0, r31
    1f24:	f2 e3       	ldi	r31, 0x32	; 50
    1f26:	ef 2e       	mov	r14, r31
    1f28:	f4 e0       	ldi	r31, 0x04	; 4
    1f2a:	ff 2e       	mov	r15, r31
    1f2c:	f0 2d       	mov	r31, r0
    1f2e:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1f32:	81 30       	cpi	r24, 0x01	; 1
    1f34:	81 f4       	brne	.+32     	; 0x1f56 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1f36:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1f38:	8f ef       	ldi	r24, 0xFF	; 255
    1f3a:	9f ef       	ldi	r25, 0xFF	; 255
    1f3c:	90 93 c9 03 	sts	0x03C9, r25
    1f40:	80 93 c8 03 	sts	0x03C8, r24
		xSchedulerRunning = pdTRUE;
    1f44:	81 e0       	ldi	r24, 0x01	; 1
    1f46:	80 93 cd 03 	sts	0x03CD, r24
		xTickCount = ( TickType_t ) 0U;
    1f4a:	10 92 d0 03 	sts	0x03D0, r1
    1f4e:	10 92 cf 03 	sts	0x03CF, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1f52:	0e 94 36 07 	call	0xe6c	; 0xe6c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1f56:	0f 91       	pop	r16
    1f58:	ff 90       	pop	r15
    1f5a:	ef 90       	pop	r14
    1f5c:	08 95       	ret

00001f5e <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1f5e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1f60:	10 92 cd 03 	sts	0x03CD, r1
	vPortEndScheduler();
    1f64:	0e 94 6b 07 	call	0xed6	; 0xed6 <vPortEndScheduler>
}
    1f68:	08 95       	ret

00001f6a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1f6a:	80 91 c7 03 	lds	r24, 0x03C7
    1f6e:	8f 5f       	subi	r24, 0xFF	; 255
    1f70:	80 93 c7 03 	sts	0x03C7, r24
}
    1f74:	08 95       	ret

00001f76 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1f76:	0f b6       	in	r0, 0x3f	; 63
    1f78:	f8 94       	cli
    1f7a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1f7c:	80 91 cf 03 	lds	r24, 0x03CF
    1f80:	90 91 d0 03 	lds	r25, 0x03D0
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1f84:	0f 90       	pop	r0
    1f86:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1f88:	08 95       	ret

00001f8a <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1f8a:	80 91 cf 03 	lds	r24, 0x03CF
    1f8e:	90 91 d0 03 	lds	r25, 0x03D0
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f92:	08 95       	ret

00001f94 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1f94:	80 91 d1 03 	lds	r24, 0x03D1
}
    1f98:	08 95       	ret

00001f9a <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1f9a:	00 97       	sbiw	r24, 0x00	; 0
    1f9c:	21 f4       	brne	.+8      	; 0x1fa6 <pcTaskGetName+0xc>
    1f9e:	80 91 c5 03 	lds	r24, 0x03C5
    1fa2:	90 91 c6 03 	lds	r25, 0x03C6
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    1fa6:	49 96       	adiw	r24, 0x19	; 25
}
    1fa8:	08 95       	ret

00001faa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1faa:	cf 92       	push	r12
    1fac:	df 92       	push	r13
    1fae:	ef 92       	push	r14
    1fb0:	ff 92       	push	r15
    1fb2:	0f 93       	push	r16
    1fb4:	1f 93       	push	r17
    1fb6:	cf 93       	push	r28
    1fb8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1fba:	80 91 c7 03 	lds	r24, 0x03C7
    1fbe:	88 23       	and	r24, r24
    1fc0:	09 f0       	breq	.+2      	; 0x1fc4 <xTaskIncrementTick+0x1a>
    1fc2:	82 c0       	rjmp	.+260    	; 0x20c8 <xTaskIncrementTick+0x11e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    1fc4:	c0 90 cf 03 	lds	r12, 0x03CF
    1fc8:	d0 90 d0 03 	lds	r13, 0x03D0
    1fcc:	08 94       	sec
    1fce:	c1 1c       	adc	r12, r1
    1fd0:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1fd2:	d0 92 d0 03 	sts	0x03D0, r13
    1fd6:	c0 92 cf 03 	sts	0x03CF, r12

		if( xConstTickCount == ( TickType_t ) 0U )
    1fda:	c1 14       	cp	r12, r1
    1fdc:	d1 04       	cpc	r13, r1
    1fde:	b9 f4       	brne	.+46     	; 0x200e <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    1fe0:	80 91 d5 03 	lds	r24, 0x03D5
    1fe4:	90 91 d6 03 	lds	r25, 0x03D6
    1fe8:	20 91 d3 03 	lds	r18, 0x03D3
    1fec:	30 91 d4 03 	lds	r19, 0x03D4
    1ff0:	30 93 d6 03 	sts	0x03D6, r19
    1ff4:	20 93 d5 03 	sts	0x03D5, r18
    1ff8:	90 93 d4 03 	sts	0x03D4, r25
    1ffc:	80 93 d3 03 	sts	0x03D3, r24
    2000:	80 91 ca 03 	lds	r24, 0x03CA
    2004:	8f 5f       	subi	r24, 0xFF	; 255
    2006:	80 93 ca 03 	sts	0x03CA, r24
    200a:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    200e:	80 91 c8 03 	lds	r24, 0x03C8
    2012:	90 91 c9 03 	lds	r25, 0x03C9
    2016:	c8 16       	cp	r12, r24
    2018:	d9 06       	cpc	r13, r25
    201a:	20 f4       	brcc	.+8      	; 0x2024 <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    201c:	ff 24       	eor	r15, r15
    201e:	5a c0       	rjmp	.+180    	; 0x20d4 <xTaskIncrementTick+0x12a>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    2020:	fe 2c       	mov	r15, r14
    2022:	03 c0       	rjmp	.+6      	; 0x202a <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    2024:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    2026:	ee 24       	eor	r14, r14
    2028:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    202a:	e0 91 d5 03 	lds	r30, 0x03D5
    202e:	f0 91 d6 03 	lds	r31, 0x03D6
    2032:	80 81       	ld	r24, Z
    2034:	88 23       	and	r24, r24
    2036:	39 f4       	brne	.+14     	; 0x2046 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2038:	8f ef       	ldi	r24, 0xFF	; 255
    203a:	9f ef       	ldi	r25, 0xFF	; 255
    203c:	90 93 c9 03 	sts	0x03C9, r25
    2040:	80 93 c8 03 	sts	0x03C8, r24
					break;
    2044:	47 c0       	rjmp	.+142    	; 0x20d4 <xTaskIncrementTick+0x12a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2046:	e0 91 d5 03 	lds	r30, 0x03D5
    204a:	f0 91 d6 03 	lds	r31, 0x03D6
    204e:	05 80       	ldd	r0, Z+5	; 0x05
    2050:	f6 81       	ldd	r31, Z+6	; 0x06
    2052:	e0 2d       	mov	r30, r0
    2054:	c6 81       	ldd	r28, Z+6	; 0x06
    2056:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2058:	8a 81       	ldd	r24, Y+2	; 0x02
    205a:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    205c:	c8 16       	cp	r12, r24
    205e:	d9 06       	cpc	r13, r25
    2060:	28 f4       	brcc	.+10     	; 0x206c <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2062:	90 93 c9 03 	sts	0x03C9, r25
    2066:	80 93 c8 03 	sts	0x03C8, r24
						break;
    206a:	34 c0       	rjmp	.+104    	; 0x20d4 <xTaskIncrementTick+0x12a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    206c:	8e 01       	movw	r16, r28
    206e:	0e 5f       	subi	r16, 0xFE	; 254
    2070:	1f 4f       	sbci	r17, 0xFF	; 255
    2072:	c8 01       	movw	r24, r16
    2074:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2078:	8c 89       	ldd	r24, Y+20	; 0x14
    207a:	9d 89       	ldd	r25, Y+21	; 0x15
    207c:	00 97       	sbiw	r24, 0x00	; 0
    207e:	21 f0       	breq	.+8      	; 0x2088 <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2080:	ce 01       	movw	r24, r28
    2082:	0c 96       	adiw	r24, 0x0c	; 12
    2084:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2088:	8e 89       	ldd	r24, Y+22	; 0x16
    208a:	90 91 ce 03 	lds	r25, 0x03CE
    208e:	98 17       	cp	r25, r24
    2090:	10 f4       	brcc	.+4      	; 0x2096 <xTaskIncrementTick+0xec>
    2092:	80 93 ce 03 	sts	0x03CE, r24
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	9c 01       	movw	r18, r24
    209a:	22 0f       	add	r18, r18
    209c:	33 1f       	adc	r19, r19
    209e:	22 0f       	add	r18, r18
    20a0:	33 1f       	adc	r19, r19
    20a2:	22 0f       	add	r18, r18
    20a4:	33 1f       	adc	r19, r19
    20a6:	82 0f       	add	r24, r18
    20a8:	93 1f       	adc	r25, r19
    20aa:	88 52       	subi	r24, 0x28	; 40
    20ac:	9c 4f       	sbci	r25, 0xFC	; 252
    20ae:	b8 01       	movw	r22, r16
    20b0:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20b4:	e0 91 c5 03 	lds	r30, 0x03C5
    20b8:	f0 91 c6 03 	lds	r31, 0x03C6
    20bc:	9e 89       	ldd	r25, Y+22	; 0x16
    20be:	86 89       	ldd	r24, Z+22	; 0x16
    20c0:	98 17       	cp	r25, r24
    20c2:	08 f0       	brcs	.+2      	; 0x20c6 <xTaskIncrementTick+0x11c>
    20c4:	ad cf       	rjmp	.-166    	; 0x2020 <xTaskIncrementTick+0x76>
    20c6:	b1 cf       	rjmp	.-158    	; 0x202a <xTaskIncrementTick+0x80>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    20c8:	80 91 cc 03 	lds	r24, 0x03CC
    20cc:	8f 5f       	subi	r24, 0xFF	; 255
    20ce:	80 93 cc 03 	sts	0x03CC, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    20d2:	ff 24       	eor	r15, r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    20d4:	80 91 cb 03 	lds	r24, 0x03CB
    20d8:	88 23       	and	r24, r24
    20da:	11 f0       	breq	.+4      	; 0x20e0 <xTaskIncrementTick+0x136>
		{
			xSwitchRequired = pdTRUE;
    20dc:	ff 24       	eor	r15, r15
    20de:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    20e0:	8f 2d       	mov	r24, r15
    20e2:	df 91       	pop	r29
    20e4:	cf 91       	pop	r28
    20e6:	1f 91       	pop	r17
    20e8:	0f 91       	pop	r16
    20ea:	ff 90       	pop	r15
    20ec:	ef 90       	pop	r14
    20ee:	df 90       	pop	r13
    20f0:	cf 90       	pop	r12
    20f2:	08 95       	ret

000020f4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    20f4:	df 92       	push	r13
    20f6:	ef 92       	push	r14
    20f8:	ff 92       	push	r15
    20fa:	0f 93       	push	r16
    20fc:	1f 93       	push	r17
    20fe:	cf 93       	push	r28
    2100:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2108:	80 91 c7 03 	lds	r24, 0x03C7
    210c:	81 50       	subi	r24, 0x01	; 1
    210e:	80 93 c7 03 	sts	0x03C7, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2112:	80 91 c7 03 	lds	r24, 0x03C7
    2116:	88 23       	and	r24, r24
    2118:	09 f0       	breq	.+2      	; 0x211c <xTaskResumeAll+0x28>
    211a:	5f c0       	rjmp	.+190    	; 0x21da <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    211c:	80 91 d1 03 	lds	r24, 0x03D1
    2120:	88 23       	and	r24, r24
    2122:	91 f5       	brne	.+100    	; 0x2188 <xTaskResumeAll+0x94>
    2124:	5d c0       	rjmp	.+186    	; 0x21e0 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2126:	e0 91 1c 04 	lds	r30, 0x041C
    212a:	f0 91 1d 04 	lds	r31, 0x041D
    212e:	c6 81       	ldd	r28, Z+6	; 0x06
    2130:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2132:	ce 01       	movw	r24, r28
    2134:	0c 96       	adiw	r24, 0x0c	; 12
    2136:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    213a:	8e 01       	movw	r16, r28
    213c:	0e 5f       	subi	r16, 0xFE	; 254
    213e:	1f 4f       	sbci	r17, 0xFF	; 255
    2140:	c8 01       	movw	r24, r16
    2142:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2146:	8e 89       	ldd	r24, Y+22	; 0x16
    2148:	90 91 ce 03 	lds	r25, 0x03CE
    214c:	98 17       	cp	r25, r24
    214e:	10 f4       	brcc	.+4      	; 0x2154 <xTaskResumeAll+0x60>
    2150:	80 93 ce 03 	sts	0x03CE, r24
    2154:	90 e0       	ldi	r25, 0x00	; 0
    2156:	9c 01       	movw	r18, r24
    2158:	22 0f       	add	r18, r18
    215a:	33 1f       	adc	r19, r19
    215c:	22 0f       	add	r18, r18
    215e:	33 1f       	adc	r19, r19
    2160:	22 0f       	add	r18, r18
    2162:	33 1f       	adc	r19, r19
    2164:	82 0f       	add	r24, r18
    2166:	93 1f       	adc	r25, r19
    2168:	88 52       	subi	r24, 0x28	; 40
    216a:	9c 4f       	sbci	r25, 0xFC	; 252
    216c:	b8 01       	movw	r22, r16
    216e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2172:	e0 91 c5 03 	lds	r30, 0x03C5
    2176:	f0 91 c6 03 	lds	r31, 0x03C6
    217a:	9e 89       	ldd	r25, Y+22	; 0x16
    217c:	86 89       	ldd	r24, Z+22	; 0x16
    217e:	98 17       	cp	r25, r24
    2180:	68 f0       	brcs	.+26     	; 0x219c <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    2182:	d0 92 cb 03 	sts	0x03CB, r13
    2186:	0a c0       	rjmp	.+20     	; 0x219c <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2188:	c0 e0       	ldi	r28, 0x00	; 0
    218a:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    218c:	0f 2e       	mov	r0, r31
    218e:	f7 e1       	ldi	r31, 0x17	; 23
    2190:	ef 2e       	mov	r14, r31
    2192:	f4 e0       	ldi	r31, 0x04	; 4
    2194:	ff 2e       	mov	r15, r31
    2196:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    2198:	dd 24       	eor	r13, r13
    219a:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    219c:	f7 01       	movw	r30, r14
    219e:	80 81       	ld	r24, Z
    21a0:	88 23       	and	r24, r24
    21a2:	09 f6       	brne	.-126    	; 0x2126 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    21a4:	20 97       	sbiw	r28, 0x00	; 0
    21a6:	11 f0       	breq	.+4      	; 0x21ac <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    21a8:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    21ac:	c0 91 cc 03 	lds	r28, 0x03CC

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    21b0:	cc 23       	and	r28, r28
    21b2:	59 f0       	breq	.+22     	; 0x21ca <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    21b4:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    21b6:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <xTaskIncrementTick>
    21ba:	88 23       	and	r24, r24
    21bc:	11 f0       	breq	.+4      	; 0x21c2 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    21be:	00 93 cb 03 	sts	0x03CB, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    21c2:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    21c4:	c1 f7       	brne	.-16     	; 0x21b6 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    21c6:	10 92 cc 03 	sts	0x03CC, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    21ca:	80 91 cb 03 	lds	r24, 0x03CB
    21ce:	88 23       	and	r24, r24
    21d0:	31 f0       	breq	.+12     	; 0x21de <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    21d2:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    21d6:	81 e0       	ldi	r24, 0x01	; 1
    21d8:	03 c0       	rjmp	.+6      	; 0x21e0 <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    21da:	80 e0       	ldi	r24, 0x00	; 0
    21dc:	01 c0       	rjmp	.+2      	; 0x21e0 <xTaskResumeAll+0xec>
    21de:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    21e0:	0f 90       	pop	r0
    21e2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	1f 91       	pop	r17
    21ea:	0f 91       	pop	r16
    21ec:	ff 90       	pop	r15
    21ee:	ef 90       	pop	r14
    21f0:	df 90       	pop	r13
    21f2:	08 95       	ret

000021f4 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    21f4:	00 e2       	ldi	r16, 0x20	; 32
    21f6:	14 e0       	ldi	r17, 0x04	; 4

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    21f8:	0f 2e       	mov	r0, r31
    21fa:	f8 ed       	ldi	r31, 0xD8	; 216
    21fc:	ef 2e       	mov	r14, r31
    21fe:	f3 e0       	ldi	r31, 0x03	; 3
    2200:	ff 2e       	mov	r15, r31
    2202:	f0 2d       	mov	r31, r0
    2204:	24 c0       	rjmp	.+72     	; 0x224e <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2206:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    220a:	f8 01       	movw	r30, r16
    220c:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    220e:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2212:	cc 23       	and	r28, r28
    2214:	e1 f0       	breq	.+56     	; 0x224e <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2216:	0f b6       	in	r0, 0x3f	; 63
    2218:	f8 94       	cli
    221a:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    221c:	e0 91 25 04 	lds	r30, 0x0425
    2220:	f0 91 26 04 	lds	r31, 0x0426
    2224:	c6 81       	ldd	r28, Z+6	; 0x06
    2226:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2228:	ce 01       	movw	r24, r28
    222a:	02 96       	adiw	r24, 0x02	; 2
    222c:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					--uxCurrentNumberOfTasks;
    2230:	80 91 d1 03 	lds	r24, 0x03D1
    2234:	81 50       	subi	r24, 0x01	; 1
    2236:	80 93 d1 03 	sts	0x03D1, r24
					--uxDeletedTasksWaitingCleanUp;
    223a:	80 91 d2 03 	lds	r24, 0x03D2
    223e:	81 50       	subi	r24, 0x01	; 1
    2240:	80 93 d2 03 	sts	0x03D2, r24
				}
				taskEXIT_CRITICAL();
    2244:	0f 90       	pop	r0
    2246:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2248:	ce 01       	movw	r24, r28
    224a:	0e 94 df 0c 	call	0x19be	; 0x19be <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    224e:	80 91 d2 03 	lds	r24, 0x03D2
    2252:	88 23       	and	r24, r24
    2254:	c1 f6       	brne	.-80     	; 0x2206 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2256:	f7 01       	movw	r30, r14
    2258:	80 81       	ld	r24, Z
    225a:	82 30       	cpi	r24, 0x02	; 2
    225c:	c0 f3       	brcs	.-16     	; 0x224e <prvIdleTask+0x5a>
			{
				taskYIELD();
    225e:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    2262:	f5 cf       	rjmp	.-22     	; 0x224e <prvIdleTask+0x5a>

00002264 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2264:	cf 93       	push	r28
    2266:	df 93       	push	r29
    2268:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    226a:	00 97       	sbiw	r24, 0x00	; 0
    226c:	51 f0       	breq	.+20     	; 0x2282 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    226e:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2272:	ce 01       	movw	r24, r28
    2274:	60 e0       	ldi	r22, 0x00	; 0
    2276:	0e 94 87 0c 	call	0x190e	; 0x190e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    227a:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    227e:	88 23       	and	r24, r24
    2280:	11 f4       	brne	.+4      	; 0x2286 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    2282:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2286:	df 91       	pop	r29
    2288:	cf 91       	pop	r28
    228a:	08 95       	ret

0000228c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    228c:	0f 93       	push	r16
    228e:	1f 93       	push	r17
    2290:	cf 93       	push	r28
    2292:	df 93       	push	r29
    2294:	8c 01       	movw	r16, r24
    2296:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2298:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    229c:	80 91 cf 03 	lds	r24, 0x03CF
    22a0:	90 91 d0 03 	lds	r25, 0x03D0

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    22a4:	f8 01       	movw	r30, r16
    22a6:	20 81       	ld	r18, Z
    22a8:	31 81       	ldd	r19, Z+1	; 0x01
    22aa:	c2 0f       	add	r28, r18
    22ac:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    22ae:	82 17       	cp	r24, r18
    22b0:	93 07       	cpc	r25, r19
    22b2:	48 f4       	brcc	.+18     	; 0x22c6 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    22b4:	c2 17       	cp	r28, r18
    22b6:	d3 07       	cpc	r29, r19
    22b8:	f8 f4       	brcc	.+62     	; 0x22f8 <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22ba:	d1 83       	std	Z+1, r29	; 0x01
    22bc:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    22be:	8c 17       	cp	r24, r28
    22c0:	9d 07       	cpc	r25, r29
    22c2:	78 f4       	brcc	.+30     	; 0x22e2 <vTaskDelayUntil+0x56>
    22c4:	07 c0       	rjmp	.+14     	; 0x22d4 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    22c6:	c2 17       	cp	r28, r18
    22c8:	d3 07       	cpc	r29, r19
    22ca:	90 f0       	brcs	.+36     	; 0x22f0 <vTaskDelayUntil+0x64>
    22cc:	8c 17       	cp	r24, r28
    22ce:	9d 07       	cpc	r25, r29
    22d0:	78 f0       	brcs	.+30     	; 0x22f0 <vTaskDelayUntil+0x64>
    22d2:	12 c0       	rjmp	.+36     	; 0x22f8 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    22d4:	9e 01       	movw	r18, r28
    22d6:	28 1b       	sub	r18, r24
    22d8:	39 0b       	sbc	r19, r25
    22da:	c9 01       	movw	r24, r18
    22dc:	60 e0       	ldi	r22, 0x00	; 0
    22de:	0e 94 87 0c 	call	0x190e	; 0x190e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    22e2:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22e6:	88 23       	and	r24, r24
    22e8:	59 f4       	brne	.+22     	; 0x2300 <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    22ea:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    22ee:	08 c0       	rjmp	.+16     	; 0x2300 <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22f0:	f8 01       	movw	r30, r16
    22f2:	d1 83       	std	Z+1, r29	; 0x01
    22f4:	c0 83       	st	Z, r28
    22f6:	ee cf       	rjmp	.-36     	; 0x22d4 <vTaskDelayUntil+0x48>
    22f8:	f8 01       	movw	r30, r16
    22fa:	d1 83       	std	Z+1, r29	; 0x01
    22fc:	c0 83       	st	Z, r28
    22fe:	f1 cf       	rjmp	.-30     	; 0x22e2 <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2300:	df 91       	pop	r29
    2302:	cf 91       	pop	r28
    2304:	1f 91       	pop	r17
    2306:	0f 91       	pop	r16
    2308:	08 95       	ret

0000230a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    230a:	80 91 c7 03 	lds	r24, 0x03C7
    230e:	88 23       	and	r24, r24
    2310:	21 f0       	breq	.+8      	; 0x231a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2312:	81 e0       	ldi	r24, 0x01	; 1
    2314:	80 93 cb 03 	sts	0x03CB, r24
    2318:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    231a:	10 92 cb 03 	sts	0x03CB, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    231e:	20 91 ce 03 	lds	r18, 0x03CE
    2322:	82 2f       	mov	r24, r18
    2324:	90 e0       	ldi	r25, 0x00	; 0
    2326:	fc 01       	movw	r30, r24
    2328:	ee 0f       	add	r30, r30
    232a:	ff 1f       	adc	r31, r31
    232c:	ee 0f       	add	r30, r30
    232e:	ff 1f       	adc	r31, r31
    2330:	ee 0f       	add	r30, r30
    2332:	ff 1f       	adc	r31, r31
    2334:	e8 0f       	add	r30, r24
    2336:	f9 1f       	adc	r31, r25
    2338:	e8 52       	subi	r30, 0x28	; 40
    233a:	fc 4f       	sbci	r31, 0xFC	; 252
    233c:	30 81       	ld	r19, Z
    233e:	33 23       	and	r19, r19
    2340:	89 f4       	brne	.+34     	; 0x2364 <vTaskSwitchContext+0x5a>
    2342:	21 50       	subi	r18, 0x01	; 1
    2344:	82 2f       	mov	r24, r18
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	fc 01       	movw	r30, r24
    234a:	ee 0f       	add	r30, r30
    234c:	ff 1f       	adc	r31, r31
    234e:	ee 0f       	add	r30, r30
    2350:	ff 1f       	adc	r31, r31
    2352:	ee 0f       	add	r30, r30
    2354:	ff 1f       	adc	r31, r31
    2356:	e8 0f       	add	r30, r24
    2358:	f9 1f       	adc	r31, r25
    235a:	e8 52       	subi	r30, 0x28	; 40
    235c:	fc 4f       	sbci	r31, 0xFC	; 252
    235e:	30 81       	ld	r19, Z
    2360:	33 23       	and	r19, r19
    2362:	79 f3       	breq	.-34     	; 0x2342 <vTaskSwitchContext+0x38>
    2364:	dc 01       	movw	r26, r24
    2366:	aa 0f       	add	r26, r26
    2368:	bb 1f       	adc	r27, r27
    236a:	aa 0f       	add	r26, r26
    236c:	bb 1f       	adc	r27, r27
    236e:	aa 0f       	add	r26, r26
    2370:	bb 1f       	adc	r27, r27
    2372:	8a 0f       	add	r24, r26
    2374:	9b 1f       	adc	r25, r27
    2376:	dc 01       	movw	r26, r24
    2378:	a8 52       	subi	r26, 0x28	; 40
    237a:	bc 4f       	sbci	r27, 0xFC	; 252
    237c:	11 96       	adiw	r26, 0x01	; 1
    237e:	ed 91       	ld	r30, X+
    2380:	fc 91       	ld	r31, X
    2382:	12 97       	sbiw	r26, 0x02	; 2
    2384:	02 80       	ldd	r0, Z+2	; 0x02
    2386:	f3 81       	ldd	r31, Z+3	; 0x03
    2388:	e0 2d       	mov	r30, r0
    238a:	12 96       	adiw	r26, 0x02	; 2
    238c:	fc 93       	st	X, r31
    238e:	ee 93       	st	-X, r30
    2390:	11 97       	sbiw	r26, 0x01	; 1
    2392:	cd 01       	movw	r24, r26
    2394:	03 96       	adiw	r24, 0x03	; 3
    2396:	e8 17       	cp	r30, r24
    2398:	f9 07       	cpc	r31, r25
    239a:	31 f4       	brne	.+12     	; 0x23a8 <vTaskSwitchContext+0x9e>
    239c:	82 81       	ldd	r24, Z+2	; 0x02
    239e:	93 81       	ldd	r25, Z+3	; 0x03
    23a0:	12 96       	adiw	r26, 0x02	; 2
    23a2:	9c 93       	st	X, r25
    23a4:	8e 93       	st	-X, r24
    23a6:	11 97       	sbiw	r26, 0x01	; 1
    23a8:	11 96       	adiw	r26, 0x01	; 1
    23aa:	ed 91       	ld	r30, X+
    23ac:	fc 91       	ld	r31, X
    23ae:	12 97       	sbiw	r26, 0x02	; 2
    23b0:	86 81       	ldd	r24, Z+6	; 0x06
    23b2:	97 81       	ldd	r25, Z+7	; 0x07
    23b4:	90 93 c6 03 	sts	0x03C6, r25
    23b8:	80 93 c5 03 	sts	0x03C5, r24
    23bc:	20 93 ce 03 	sts	0x03CE, r18
    23c0:	08 95       	ret

000023c2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    23c2:	0f 93       	push	r16
    23c4:	1f 93       	push	r17
    23c6:	cf 93       	push	r28
    23c8:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    23ca:	0f b6       	in	r0, 0x3f	; 63
    23cc:	f8 94       	cli
    23ce:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    23d0:	00 97       	sbiw	r24, 0x00	; 0
    23d2:	29 f4       	brne	.+10     	; 0x23de <vTaskSuspend+0x1c>
    23d4:	00 91 c5 03 	lds	r16, 0x03C5
    23d8:	10 91 c6 03 	lds	r17, 0x03C6
    23dc:	01 c0       	rjmp	.+2      	; 0x23e0 <vTaskSuspend+0x1e>
    23de:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    23e0:	e8 01       	movw	r28, r16
    23e2:	22 96       	adiw	r28, 0x02	; 2
    23e4:	ce 01       	movw	r24, r28
    23e6:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    23ea:	f8 01       	movw	r30, r16
    23ec:	84 89       	ldd	r24, Z+20	; 0x14
    23ee:	95 89       	ldd	r25, Z+21	; 0x15
    23f0:	00 97       	sbiw	r24, 0x00	; 0
    23f2:	21 f0       	breq	.+8      	; 0x23fc <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    23f4:	c8 01       	movw	r24, r16
    23f6:	0c 96       	adiw	r24, 0x0c	; 12
    23f8:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    23fc:	89 e2       	ldi	r24, 0x29	; 41
    23fe:	94 e0       	ldi	r25, 0x04	; 4
    2400:	be 01       	movw	r22, r28
    2402:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2406:	0f 90       	pop	r0
    2408:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    240a:	80 91 cd 03 	lds	r24, 0x03CD
    240e:	88 23       	and	r24, r24
    2410:	39 f0       	breq	.+14     	; 0x2420 <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    2418:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    241c:	0f 90       	pop	r0
    241e:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    2420:	80 91 c5 03 	lds	r24, 0x03C5
    2424:	90 91 c6 03 	lds	r25, 0x03C6
    2428:	08 17       	cp	r16, r24
    242a:	19 07       	cpc	r17, r25
    242c:	a1 f4       	brne	.+40     	; 0x2456 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    242e:	80 91 cd 03 	lds	r24, 0x03CD
    2432:	88 23       	and	r24, r24
    2434:	19 f0       	breq	.+6      	; 0x243c <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2436:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    243a:	0d c0       	rjmp	.+26     	; 0x2456 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    243c:	80 91 d1 03 	lds	r24, 0x03D1
    2440:	90 91 29 04 	lds	r25, 0x0429
    2444:	98 17       	cp	r25, r24
    2446:	29 f4       	brne	.+10     	; 0x2452 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2448:	10 92 c6 03 	sts	0x03C6, r1
    244c:	10 92 c5 03 	sts	0x03C5, r1
    2450:	02 c0       	rjmp	.+4      	; 0x2456 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    2452:	0e 94 85 11 	call	0x230a	; 0x230a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2456:	df 91       	pop	r29
    2458:	cf 91       	pop	r28
    245a:	1f 91       	pop	r17
    245c:	0f 91       	pop	r16
    245e:	08 95       	ret

00002460 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2460:	cf 93       	push	r28
    2462:	df 93       	push	r29
    2464:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2466:	60 91 c5 03 	lds	r22, 0x03C5
    246a:	70 91 c6 03 	lds	r23, 0x03C6
    246e:	64 5f       	subi	r22, 0xF4	; 244
    2470:	7f 4f       	sbci	r23, 0xFF	; 255
    2472:	0e 94 4c 06 	call	0xc98	; 0xc98 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2476:	ce 01       	movw	r24, r28
    2478:	61 e0       	ldi	r22, 0x01	; 1
    247a:	0e 94 87 0c 	call	0x190e	; 0x190e <prvAddCurrentTaskToDelayedList>
}
    247e:	df 91       	pop	r29
    2480:	cf 91       	pop	r28
    2482:	08 95       	ret

00002484 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2484:	cf 93       	push	r28
    2486:	df 93       	push	r29
    2488:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    248a:	e0 91 c5 03 	lds	r30, 0x03C5
    248e:	f0 91 c6 03 	lds	r31, 0x03C6
    2492:	70 68       	ori	r23, 0x80	; 128
    2494:	75 87       	std	Z+13, r23	; 0x0d
    2496:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2498:	60 91 c5 03 	lds	r22, 0x03C5
    249c:	70 91 c6 03 	lds	r23, 0x03C6
    24a0:	64 5f       	subi	r22, 0xF4	; 244
    24a2:	7f 4f       	sbci	r23, 0xFF	; 255
    24a4:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    24a8:	ce 01       	movw	r24, r28
    24aa:	61 e0       	ldi	r22, 0x01	; 1
    24ac:	0e 94 87 0c 	call	0x190e	; 0x190e <prvAddCurrentTaskToDelayedList>
}
    24b0:	df 91       	pop	r29
    24b2:	cf 91       	pop	r28
    24b4:	08 95       	ret

000024b6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    24b6:	0f 93       	push	r16
    24b8:	1f 93       	push	r17
    24ba:	cf 93       	push	r28
    24bc:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    24be:	dc 01       	movw	r26, r24
    24c0:	15 96       	adiw	r26, 0x05	; 5
    24c2:	ed 91       	ld	r30, X+
    24c4:	fc 91       	ld	r31, X
    24c6:	16 97       	sbiw	r26, 0x06	; 6
    24c8:	06 81       	ldd	r16, Z+6	; 0x06
    24ca:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    24cc:	e8 01       	movw	r28, r16
    24ce:	2c 96       	adiw	r28, 0x0c	; 12
    24d0:	ce 01       	movw	r24, r28
    24d2:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24d6:	80 91 c7 03 	lds	r24, 0x03C7
    24da:	88 23       	and	r24, r24
    24dc:	e9 f4       	brne	.+58     	; 0x2518 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    24de:	e8 01       	movw	r28, r16
    24e0:	22 96       	adiw	r28, 0x02	; 2
    24e2:	ce 01       	movw	r24, r28
    24e4:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    24e8:	f8 01       	movw	r30, r16
    24ea:	86 89       	ldd	r24, Z+22	; 0x16
    24ec:	90 91 ce 03 	lds	r25, 0x03CE
    24f0:	98 17       	cp	r25, r24
    24f2:	10 f4       	brcc	.+4      	; 0x24f8 <xTaskRemoveFromEventList+0x42>
    24f4:	80 93 ce 03 	sts	0x03CE, r24
    24f8:	90 e0       	ldi	r25, 0x00	; 0
    24fa:	9c 01       	movw	r18, r24
    24fc:	22 0f       	add	r18, r18
    24fe:	33 1f       	adc	r19, r19
    2500:	22 0f       	add	r18, r18
    2502:	33 1f       	adc	r19, r19
    2504:	22 0f       	add	r18, r18
    2506:	33 1f       	adc	r19, r19
    2508:	82 0f       	add	r24, r18
    250a:	93 1f       	adc	r25, r19
    250c:	88 52       	subi	r24, 0x28	; 40
    250e:	9c 4f       	sbci	r25, 0xFC	; 252
    2510:	be 01       	movw	r22, r28
    2512:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
    2516:	05 c0       	rjmp	.+10     	; 0x2522 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2518:	87 e1       	ldi	r24, 0x17	; 23
    251a:	94 e0       	ldi	r25, 0x04	; 4
    251c:	be 01       	movw	r22, r28
    251e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2522:	e0 91 c5 03 	lds	r30, 0x03C5
    2526:	f0 91 c6 03 	lds	r31, 0x03C6
    252a:	d8 01       	movw	r26, r16
    252c:	56 96       	adiw	r26, 0x16	; 22
    252e:	9c 91       	ld	r25, X
    2530:	56 97       	sbiw	r26, 0x16	; 22
    2532:	86 89       	ldd	r24, Z+22	; 0x16
    2534:	89 17       	cp	r24, r25
    2536:	20 f4       	brcc	.+8      	; 0x2540 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	80 93 cb 03 	sts	0x03CB, r24
    253e:	01 c0       	rjmp	.+2      	; 0x2542 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    2540:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    2542:	df 91       	pop	r29
    2544:	cf 91       	pop	r28
    2546:	1f 91       	pop	r17
    2548:	0f 91       	pop	r16
    254a:	08 95       	ret

0000254c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    254c:	0f 93       	push	r16
    254e:	1f 93       	push	r17
    2550:	cf 93       	push	r28
    2552:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2554:	70 68       	ori	r23, 0x80	; 128
    2556:	fc 01       	movw	r30, r24
    2558:	71 83       	std	Z+1, r23	; 0x01
    255a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    255c:	c6 81       	ldd	r28, Z+6	; 0x06
    255e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2560:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2564:	8e 01       	movw	r16, r28
    2566:	0e 5f       	subi	r16, 0xFE	; 254
    2568:	1f 4f       	sbci	r17, 0xFF	; 255
    256a:	c8 01       	movw	r24, r16
    256c:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2570:	8e 89       	ldd	r24, Y+22	; 0x16
    2572:	90 91 ce 03 	lds	r25, 0x03CE
    2576:	98 17       	cp	r25, r24
    2578:	10 f4       	brcc	.+4      	; 0x257e <xTaskRemoveFromUnorderedEventList+0x32>
    257a:	80 93 ce 03 	sts	0x03CE, r24
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	9c 01       	movw	r18, r24
    2582:	22 0f       	add	r18, r18
    2584:	33 1f       	adc	r19, r19
    2586:	22 0f       	add	r18, r18
    2588:	33 1f       	adc	r19, r19
    258a:	22 0f       	add	r18, r18
    258c:	33 1f       	adc	r19, r19
    258e:	82 0f       	add	r24, r18
    2590:	93 1f       	adc	r25, r19
    2592:	88 52       	subi	r24, 0x28	; 40
    2594:	9c 4f       	sbci	r25, 0xFC	; 252
    2596:	b8 01       	movw	r22, r16
    2598:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    259c:	e0 91 c5 03 	lds	r30, 0x03C5
    25a0:	f0 91 c6 03 	lds	r31, 0x03C6
    25a4:	9e 89       	ldd	r25, Y+22	; 0x16
    25a6:	86 89       	ldd	r24, Z+22	; 0x16
    25a8:	89 17       	cp	r24, r25
    25aa:	20 f4       	brcc	.+8      	; 0x25b4 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    25ac:	81 e0       	ldi	r24, 0x01	; 1
    25ae:	80 93 cb 03 	sts	0x03CB, r24
    25b2:	01 c0       	rjmp	.+2      	; 0x25b6 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    25b4:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    25b6:	df 91       	pop	r29
    25b8:	cf 91       	pop	r28
    25ba:	1f 91       	pop	r17
    25bc:	0f 91       	pop	r16
    25be:	08 95       	ret

000025c0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    25c0:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    25c2:	80 91 ca 03 	lds	r24, 0x03CA
    25c6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    25c8:	80 91 cf 03 	lds	r24, 0x03CF
    25cc:	90 91 d0 03 	lds	r25, 0x03D0
    25d0:	92 83       	std	Z+2, r25	; 0x02
    25d2:	81 83       	std	Z+1, r24	; 0x01
}
    25d4:	08 95       	ret

000025d6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    25d6:	fc 01       	movw	r30, r24
    25d8:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25da:	0f b6       	in	r0, 0x3f	; 63
    25dc:	f8 94       	cli
    25de:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    25e0:	60 91 cf 03 	lds	r22, 0x03CF
    25e4:	70 91 d0 03 	lds	r23, 0x03D0
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    25e8:	4d 91       	ld	r20, X+
    25ea:	5c 91       	ld	r21, X
    25ec:	11 97       	sbiw	r26, 0x01	; 1
    25ee:	8f ef       	ldi	r24, 0xFF	; 255
    25f0:	4f 3f       	cpi	r20, 0xFF	; 255
    25f2:	58 07       	cpc	r21, r24
    25f4:	e9 f0       	breq	.+58     	; 0x2630 <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    25f6:	80 91 ca 03 	lds	r24, 0x03CA
    25fa:	90 81       	ld	r25, Z
    25fc:	98 17       	cp	r25, r24
    25fe:	29 f0       	breq	.+10     	; 0x260a <xTaskCheckForTimeOut+0x34>
    2600:	81 81       	ldd	r24, Z+1	; 0x01
    2602:	92 81       	ldd	r25, Z+2	; 0x02
    2604:	68 17       	cp	r22, r24
    2606:	79 07       	cpc	r23, r25
    2608:	a8 f4       	brcc	.+42     	; 0x2634 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    260a:	81 81       	ldd	r24, Z+1	; 0x01
    260c:	92 81       	ldd	r25, Z+2	; 0x02
    260e:	9b 01       	movw	r18, r22
    2610:	28 1b       	sub	r18, r24
    2612:	39 0b       	sbc	r19, r25
    2614:	24 17       	cp	r18, r20
    2616:	35 07       	cpc	r19, r21
    2618:	78 f4       	brcc	.+30     	; 0x2638 <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    261a:	86 1b       	sub	r24, r22
    261c:	97 0b       	sbc	r25, r23
    261e:	84 0f       	add	r24, r20
    2620:	95 1f       	adc	r25, r21
    2622:	8d 93       	st	X+, r24
    2624:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2626:	cf 01       	movw	r24, r30
    2628:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    262c:	80 e0       	ldi	r24, 0x00	; 0
    262e:	05 c0       	rjmp	.+10     	; 0x263a <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    2630:	80 e0       	ldi	r24, 0x00	; 0
    2632:	03 c0       	rjmp	.+6      	; 0x263a <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	01 c0       	rjmp	.+2      	; 0x263a <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2638:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    263a:	0f 90       	pop	r0
    263c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    263e:	08 95       	ret

00002640 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2640:	81 e0       	ldi	r24, 0x01	; 1
    2642:	80 93 cb 03 	sts	0x03CB, r24
}
    2646:	08 95       	ret

00002648 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2648:	80 91 c5 03 	lds	r24, 0x03C5
    264c:	90 91 c6 03 	lds	r25, 0x03C6

		return xReturn;
	}
    2650:	08 95       	ret

00002652 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    2652:	0f 93       	push	r16
    2654:	1f 93       	push	r17
    2656:	cf 93       	push	r28
    2658:	df 93       	push	r29
    265a:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    265c:	00 97       	sbiw	r24, 0x00	; 0
    265e:	09 f4       	brne	.+2      	; 0x2662 <vTaskPriorityInherit+0x10>
    2660:	51 c0       	rjmp	.+162    	; 0x2704 <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2662:	8e 89       	ldd	r24, Y+22	; 0x16
    2664:	e0 91 c5 03 	lds	r30, 0x03C5
    2668:	f0 91 c6 03 	lds	r31, 0x03C6
    266c:	96 89       	ldd	r25, Z+22	; 0x16
    266e:	89 17       	cp	r24, r25
    2670:	08 f0       	brcs	.+2      	; 0x2674 <vTaskPriorityInherit+0x22>
    2672:	48 c0       	rjmp	.+144    	; 0x2704 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2674:	2c 85       	ldd	r18, Y+12	; 0x0c
    2676:	3d 85       	ldd	r19, Y+13	; 0x0d
    2678:	33 23       	and	r19, r19
    267a:	5c f0       	brlt	.+22     	; 0x2692 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    267c:	e0 91 c5 03 	lds	r30, 0x03C5
    2680:	f0 91 c6 03 	lds	r31, 0x03C6
    2684:	96 89       	ldd	r25, Z+22	; 0x16
    2686:	25 e0       	ldi	r18, 0x05	; 5
    2688:	30 e0       	ldi	r19, 0x00	; 0
    268a:	29 1b       	sub	r18, r25
    268c:	31 09       	sbc	r19, r1
    268e:	3d 87       	std	Y+13, r19	; 0x0d
    2690:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2692:	90 e0       	ldi	r25, 0x00	; 0
    2694:	9c 01       	movw	r18, r24
    2696:	22 0f       	add	r18, r18
    2698:	33 1f       	adc	r19, r19
    269a:	22 0f       	add	r18, r18
    269c:	33 1f       	adc	r19, r19
    269e:	22 0f       	add	r18, r18
    26a0:	33 1f       	adc	r19, r19
    26a2:	82 0f       	add	r24, r18
    26a4:	93 1f       	adc	r25, r19
    26a6:	88 52       	subi	r24, 0x28	; 40
    26a8:	9c 4f       	sbci	r25, 0xFC	; 252
    26aa:	2a 85       	ldd	r18, Y+10	; 0x0a
    26ac:	3b 85       	ldd	r19, Y+11	; 0x0b
    26ae:	28 17       	cp	r18, r24
    26b0:	39 07       	cpc	r19, r25
    26b2:	11 f5       	brne	.+68     	; 0x26f8 <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    26b4:	8e 01       	movw	r16, r28
    26b6:	0e 5f       	subi	r16, 0xFE	; 254
    26b8:	1f 4f       	sbci	r17, 0xFF	; 255
    26ba:	c8 01       	movw	r24, r16
    26bc:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    26c0:	e0 91 c5 03 	lds	r30, 0x03C5
    26c4:	f0 91 c6 03 	lds	r31, 0x03C6
    26c8:	86 89       	ldd	r24, Z+22	; 0x16
    26ca:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    26cc:	90 91 ce 03 	lds	r25, 0x03CE
    26d0:	98 17       	cp	r25, r24
    26d2:	10 f4       	brcc	.+4      	; 0x26d8 <vTaskPriorityInherit+0x86>
    26d4:	80 93 ce 03 	sts	0x03CE, r24
    26d8:	90 e0       	ldi	r25, 0x00	; 0
    26da:	9c 01       	movw	r18, r24
    26dc:	22 0f       	add	r18, r18
    26de:	33 1f       	adc	r19, r19
    26e0:	22 0f       	add	r18, r18
    26e2:	33 1f       	adc	r19, r19
    26e4:	22 0f       	add	r18, r18
    26e6:	33 1f       	adc	r19, r19
    26e8:	82 0f       	add	r24, r18
    26ea:	93 1f       	adc	r25, r19
    26ec:	88 52       	subi	r24, 0x28	; 40
    26ee:	9c 4f       	sbci	r25, 0xFC	; 252
    26f0:	b8 01       	movw	r22, r16
    26f2:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
    26f6:	06 c0       	rjmp	.+12     	; 0x2704 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    26f8:	e0 91 c5 03 	lds	r30, 0x03C5
    26fc:	f0 91 c6 03 	lds	r31, 0x03C6
    2700:	86 89       	ldd	r24, Z+22	; 0x16
    2702:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2704:	df 91       	pop	r29
    2706:	cf 91       	pop	r28
    2708:	1f 91       	pop	r17
    270a:	0f 91       	pop	r16
    270c:	08 95       	ret

0000270e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    270e:	0f 93       	push	r16
    2710:	1f 93       	push	r17
    2712:	cf 93       	push	r28
    2714:	df 93       	push	r29
    2716:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	81 f1       	breq	.+96     	; 0x277c <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    271c:	8c a1       	lds	r24, 0x4c
    271e:	81 50       	subi	r24, 0x01	; 1
    2720:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2722:	2e 89       	ldd	r18, Y+22	; 0x16
    2724:	9b a1       	lds	r25, 0x4b
    2726:	29 17       	cp	r18, r25
    2728:	59 f1       	breq	.+86     	; 0x2780 <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    272a:	88 23       	and	r24, r24
    272c:	59 f5       	brne	.+86     	; 0x2784 <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    272e:	8e 01       	movw	r16, r28
    2730:	0e 5f       	subi	r16, 0xFE	; 254
    2732:	1f 4f       	sbci	r17, 0xFF	; 255
    2734:	c8 01       	movw	r24, r16
    2736:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    273a:	4b a1       	lds	r20, 0x4b
    273c:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    273e:	24 2f       	mov	r18, r20
    2740:	30 e0       	ldi	r19, 0x00	; 0
    2742:	85 e0       	ldi	r24, 0x05	; 5
    2744:	90 e0       	ldi	r25, 0x00	; 0
    2746:	82 1b       	sub	r24, r18
    2748:	93 0b       	sbc	r25, r19
    274a:	9d 87       	std	Y+13, r25	; 0x0d
    274c:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    274e:	80 91 ce 03 	lds	r24, 0x03CE
    2752:	84 17       	cp	r24, r20
    2754:	10 f4       	brcc	.+4      	; 0x275a <xTaskPriorityDisinherit+0x4c>
    2756:	40 93 ce 03 	sts	0x03CE, r20
    275a:	c9 01       	movw	r24, r18
    275c:	88 0f       	add	r24, r24
    275e:	99 1f       	adc	r25, r25
    2760:	88 0f       	add	r24, r24
    2762:	99 1f       	adc	r25, r25
    2764:	88 0f       	add	r24, r24
    2766:	99 1f       	adc	r25, r25
    2768:	28 0f       	add	r18, r24
    276a:	39 1f       	adc	r19, r25
    276c:	c9 01       	movw	r24, r18
    276e:	88 52       	subi	r24, 0x28	; 40
    2770:	9c 4f       	sbci	r25, 0xFC	; 252
    2772:	b8 01       	movw	r22, r16
    2774:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    2778:	81 e0       	ldi	r24, 0x01	; 1
    277a:	05 c0       	rjmp	.+10     	; 0x2786 <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    277c:	80 e0       	ldi	r24, 0x00	; 0
    277e:	03 c0       	rjmp	.+6      	; 0x2786 <xTaskPriorityDisinherit+0x78>
    2780:	80 e0       	ldi	r24, 0x00	; 0
    2782:	01 c0       	rjmp	.+2      	; 0x2786 <xTaskPriorityDisinherit+0x78>
    2784:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    2786:	df 91       	pop	r29
    2788:	cf 91       	pop	r28
    278a:	1f 91       	pop	r17
    278c:	0f 91       	pop	r16
    278e:	08 95       	ret

00002790 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2790:	e0 91 c5 03 	lds	r30, 0x03C5
    2794:	f0 91 c6 03 	lds	r31, 0x03C6
    2798:	84 85       	ldd	r24, Z+12	; 0x0c
    279a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    279c:	e0 91 c5 03 	lds	r30, 0x03C5
    27a0:	f0 91 c6 03 	lds	r31, 0x03C6
    27a4:	a0 91 c5 03 	lds	r26, 0x03C5
    27a8:	b0 91 c6 03 	lds	r27, 0x03C6
    27ac:	56 96       	adiw	r26, 0x16	; 22
    27ae:	4c 91       	ld	r20, X
    27b0:	56 97       	sbiw	r26, 0x16	; 22
    27b2:	25 e0       	ldi	r18, 0x05	; 5
    27b4:	30 e0       	ldi	r19, 0x00	; 0
    27b6:	24 1b       	sub	r18, r20
    27b8:	31 09       	sbc	r19, r1
    27ba:	35 87       	std	Z+13, r19	; 0x0d
    27bc:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    27be:	08 95       	ret

000027c0 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    27c0:	80 91 c5 03 	lds	r24, 0x03C5
    27c4:	90 91 c6 03 	lds	r25, 0x03C6
    27c8:	00 97       	sbiw	r24, 0x00	; 0
    27ca:	39 f0       	breq	.+14     	; 0x27da <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    27cc:	e0 91 c5 03 	lds	r30, 0x03C5
    27d0:	f0 91 c6 03 	lds	r31, 0x03C6
    27d4:	84 a1       	lds	r24, 0x44
    27d6:	8f 5f       	subi	r24, 0xFF	; 255
    27d8:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    27da:	80 91 c5 03 	lds	r24, 0x03C5
    27de:	90 91 c6 03 	lds	r25, 0x03C6
	}
    27e2:	08 95       	ret

000027e4 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    27e4:	0f 93       	push	r16
    27e6:	1f 93       	push	r17
    27e8:	cf 93       	push	r28
    27ea:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    27ec:	0f b6       	in	r0, 0x3f	; 63
    27ee:	f8 94       	cli
    27f0:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    27f2:	e0 91 c5 03 	lds	r30, 0x03C5
    27f6:	f0 91 c6 03 	lds	r31, 0x03C6
    27fa:	85 a1       	lds	r24, 0x45
    27fc:	96 a1       	lds	r25, 0x46
    27fe:	a7 a1       	lds	r26, 0x47
    2800:	b0 a5       	lds	r27, 0x60
    2802:	00 97       	sbiw	r24, 0x00	; 0
    2804:	a1 05       	cpc	r26, r1
    2806:	b1 05       	cpc	r27, r1
    2808:	79 f4       	brne	.+30     	; 0x2828 <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    280a:	e0 91 c5 03 	lds	r30, 0x03C5
    280e:	f0 91 c6 03 	lds	r31, 0x03C6
    2812:	81 e0       	ldi	r24, 0x01	; 1
    2814:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2816:	61 15       	cp	r22, r1
    2818:	71 05       	cpc	r23, r1
    281a:	31 f0       	breq	.+12     	; 0x2828 <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    281c:	cb 01       	movw	r24, r22
    281e:	61 e0       	ldi	r22, 0x01	; 1
    2820:	0e 94 87 0c 	call	0x190e	; 0x190e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2824:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2828:	0f 90       	pop	r0
    282a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2832:	e0 91 c5 03 	lds	r30, 0x03C5
    2836:	f0 91 c6 03 	lds	r31, 0x03C6
    283a:	05 a1       	lds	r16, 0x45
    283c:	16 a1       	lds	r17, 0x46
    283e:	27 a1       	lds	r18, 0x47
    2840:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    2842:	01 15       	cp	r16, r1
    2844:	11 05       	cpc	r17, r1
    2846:	21 05       	cpc	r18, r1
    2848:	31 05       	cpc	r19, r1
    284a:	c1 f0       	breq	.+48     	; 0x287c <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    284c:	cc 23       	and	r28, r28
    284e:	49 f0       	breq	.+18     	; 0x2862 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2850:	e0 91 c5 03 	lds	r30, 0x03C5
    2854:	f0 91 c6 03 	lds	r31, 0x03C6
    2858:	15 a2       	lds	r17, 0x95
    285a:	16 a2       	lds	r17, 0x96
    285c:	17 a2       	lds	r17, 0x97
    285e:	10 a6       	lds	r17, 0xb0
    2860:	0d c0       	rjmp	.+26     	; 0x287c <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2862:	e0 91 c5 03 	lds	r30, 0x03C5
    2866:	f0 91 c6 03 	lds	r31, 0x03C6
    286a:	d9 01       	movw	r26, r18
    286c:	c8 01       	movw	r24, r16
    286e:	01 97       	sbiw	r24, 0x01	; 1
    2870:	a1 09       	sbc	r26, r1
    2872:	b1 09       	sbc	r27, r1
    2874:	85 a3       	lds	r24, 0x55
    2876:	96 a3       	lds	r25, 0x56
    2878:	a7 a3       	lds	r26, 0x57
    287a:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    287c:	e0 91 c5 03 	lds	r30, 0x03C5
    2880:	f0 91 c6 03 	lds	r31, 0x03C6
    2884:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2886:	0f 90       	pop	r0
    2888:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    288a:	60 2f       	mov	r22, r16
    288c:	71 2f       	mov	r23, r17
    288e:	82 2f       	mov	r24, r18
    2890:	93 2f       	mov	r25, r19
    2892:	cf 91       	pop	r28
    2894:	1f 91       	pop	r17
    2896:	0f 91       	pop	r16
    2898:	08 95       	ret

0000289a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    289a:	8f 92       	push	r8
    289c:	9f 92       	push	r9
    289e:	af 92       	push	r10
    28a0:	bf 92       	push	r11
    28a2:	ef 92       	push	r14
    28a4:	ff 92       	push	r15
    28a6:	0f 93       	push	r16
    28a8:	1f 93       	push	r17
    28aa:	dc 01       	movw	r26, r24
    28ac:	cb 01       	movw	r24, r22
    28ae:	49 01       	movw	r8, r18
    28b0:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    28b2:	0f b6       	in	r0, 0x3f	; 63
    28b4:	f8 94       	cli
    28b6:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    28b8:	e0 91 c5 03 	lds	r30, 0x03C5
    28bc:	f0 91 c6 03 	lds	r31, 0x03C6
    28c0:	21 a5       	lds	r18, 0x61
    28c2:	22 30       	cpi	r18, 0x02	; 2
    28c4:	19 f1       	breq	.+70     	; 0x290c <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    28c6:	e0 91 c5 03 	lds	r30, 0x03C5
    28ca:	f0 91 c6 03 	lds	r31, 0x03C6
    28ce:	45 a1       	lds	r20, 0x45
    28d0:	56 a1       	lds	r21, 0x46
    28d2:	67 a1       	lds	r22, 0x47
    28d4:	70 a5       	lds	r23, 0x60
    28d6:	80 95       	com	r24
    28d8:	90 95       	com	r25
    28da:	a0 95       	com	r26
    28dc:	b0 95       	com	r27
    28de:	84 23       	and	r24, r20
    28e0:	95 23       	and	r25, r21
    28e2:	a6 23       	and	r26, r22
    28e4:	b7 23       	and	r27, r23
    28e6:	85 a3       	lds	r24, 0x55
    28e8:	96 a3       	lds	r25, 0x56
    28ea:	a7 a3       	lds	r26, 0x57
    28ec:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    28ee:	e0 91 c5 03 	lds	r30, 0x03C5
    28f2:	f0 91 c6 03 	lds	r31, 0x03C6
    28f6:	81 e0       	ldi	r24, 0x01	; 1
    28f8:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    28fa:	e1 14       	cp	r14, r1
    28fc:	f1 04       	cpc	r15, r1
    28fe:	31 f0       	breq	.+12     	; 0x290c <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2900:	c7 01       	movw	r24, r14
    2902:	61 e0       	ldi	r22, 0x01	; 1
    2904:	0e 94 87 0c 	call	0x190e	; 0x190e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2908:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    290c:	0f 90       	pop	r0
    290e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2910:	0f b6       	in	r0, 0x3f	; 63
    2912:	f8 94       	cli
    2914:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2916:	01 15       	cp	r16, r1
    2918:	11 05       	cpc	r17, r1
    291a:	69 f0       	breq	.+26     	; 0x2936 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    291c:	e0 91 c5 03 	lds	r30, 0x03C5
    2920:	f0 91 c6 03 	lds	r31, 0x03C6
    2924:	85 a1       	lds	r24, 0x45
    2926:	96 a1       	lds	r25, 0x46
    2928:	a7 a1       	lds	r26, 0x47
    292a:	b0 a5       	lds	r27, 0x60
    292c:	f8 01       	movw	r30, r16
    292e:	80 83       	st	Z, r24
    2930:	91 83       	std	Z+1, r25	; 0x01
    2932:	a2 83       	std	Z+2, r26	; 0x02
    2934:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2936:	e0 91 c5 03 	lds	r30, 0x03C5
    293a:	f0 91 c6 03 	lds	r31, 0x03C6
    293e:	81 a5       	lds	r24, 0x61
    2940:	81 30       	cpi	r24, 0x01	; 1
    2942:	b1 f0       	breq	.+44     	; 0x2970 <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2944:	e0 91 c5 03 	lds	r30, 0x03C5
    2948:	f0 91 c6 03 	lds	r31, 0x03C6
    294c:	85 a1       	lds	r24, 0x45
    294e:	96 a1       	lds	r25, 0x46
    2950:	a7 a1       	lds	r26, 0x47
    2952:	b0 a5       	lds	r27, 0x60
    2954:	80 94       	com	r8
    2956:	90 94       	com	r9
    2958:	a0 94       	com	r10
    295a:	b0 94       	com	r11
    295c:	88 22       	and	r8, r24
    295e:	99 22       	and	r9, r25
    2960:	aa 22       	and	r10, r26
    2962:	bb 22       	and	r11, r27
    2964:	85 a2       	lds	r24, 0x95
    2966:	96 a2       	lds	r25, 0x96
    2968:	a7 a2       	lds	r26, 0x97
    296a:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    296c:	81 e0       	ldi	r24, 0x01	; 1
    296e:	01 c0       	rjmp	.+2      	; 0x2972 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2970:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2972:	e0 91 c5 03 	lds	r30, 0x03C5
    2976:	f0 91 c6 03 	lds	r31, 0x03C6
    297a:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    297c:	0f 90       	pop	r0
    297e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	ff 90       	pop	r15
    2986:	ef 90       	pop	r14
    2988:	bf 90       	pop	r11
    298a:	af 90       	pop	r10
    298c:	9f 90       	pop	r9
    298e:	8f 90       	pop	r8
    2990:	08 95       	ret

00002992 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2992:	0f 93       	push	r16
    2994:	1f 93       	push	r17
    2996:	cf 93       	push	r28
    2998:	df 93       	push	r29
    299a:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    299c:	0f b6       	in	r0, 0x3f	; 63
    299e:	f8 94       	cli
    29a0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    29a2:	01 15       	cp	r16, r1
    29a4:	11 05       	cpc	r17, r1
    29a6:	49 f0       	breq	.+18     	; 0x29ba <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    29a8:	8d a1       	lds	r24, 0x4d
    29aa:	9e a1       	lds	r25, 0x4e
    29ac:	af a1       	lds	r26, 0x4f
    29ae:	b8 a5       	lds	r27, 0x68
    29b0:	f8 01       	movw	r30, r16
    29b2:	80 83       	st	Z, r24
    29b4:	91 83       	std	Z+1, r25	; 0x01
    29b6:	a2 83       	std	Z+2, r26	; 0x02
    29b8:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    29ba:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    29bc:	82 e0       	ldi	r24, 0x02	; 2
    29be:	89 a7       	lds	r24, 0x79

			switch( eAction )
    29c0:	22 30       	cpi	r18, 0x02	; 2
    29c2:	b9 f0       	breq	.+46     	; 0x29f2 <xTaskGenericNotify+0x60>
    29c4:	23 30       	cpi	r18, 0x03	; 3
    29c6:	18 f4       	brcc	.+6      	; 0x29ce <xTaskGenericNotify+0x3c>
    29c8:	21 30       	cpi	r18, 0x01	; 1
    29ca:	51 f5       	brne	.+84     	; 0x2a20 <xTaskGenericNotify+0x8e>
    29cc:	05 c0       	rjmp	.+10     	; 0x29d8 <xTaskGenericNotify+0x46>
    29ce:	23 30       	cpi	r18, 0x03	; 3
    29d0:	e1 f0       	breq	.+56     	; 0x2a0a <xTaskGenericNotify+0x78>
    29d2:	24 30       	cpi	r18, 0x04	; 4
    29d4:	29 f5       	brne	.+74     	; 0x2a20 <xTaskGenericNotify+0x8e>
    29d6:	1e c0       	rjmp	.+60     	; 0x2a14 <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    29d8:	8d a1       	lds	r24, 0x4d
    29da:	9e a1       	lds	r25, 0x4e
    29dc:	af a1       	lds	r26, 0x4f
    29de:	b8 a5       	lds	r27, 0x68
    29e0:	48 2b       	or	r20, r24
    29e2:	59 2b       	or	r21, r25
    29e4:	6a 2b       	or	r22, r26
    29e6:	7b 2b       	or	r23, r27
    29e8:	4d a3       	lds	r20, 0x5d
    29ea:	5e a3       	lds	r21, 0x5e
    29ec:	6f a3       	lds	r22, 0x5f
    29ee:	78 a7       	lds	r23, 0x78
					break;
    29f0:	17 c0       	rjmp	.+46     	; 0x2a20 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    29f2:	8d a1       	lds	r24, 0x4d
    29f4:	9e a1       	lds	r25, 0x4e
    29f6:	af a1       	lds	r26, 0x4f
    29f8:	b8 a5       	lds	r27, 0x68
    29fa:	01 96       	adiw	r24, 0x01	; 1
    29fc:	a1 1d       	adc	r26, r1
    29fe:	b1 1d       	adc	r27, r1
    2a00:	8d a3       	lds	r24, 0x5d
    2a02:	9e a3       	lds	r25, 0x5e
    2a04:	af a3       	lds	r26, 0x5f
    2a06:	b8 a7       	lds	r27, 0x78
					break;
    2a08:	0b c0       	rjmp	.+22     	; 0x2a20 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2a0a:	4d a3       	lds	r20, 0x5d
    2a0c:	5e a3       	lds	r21, 0x5e
    2a0e:	6f a3       	lds	r22, 0x5f
    2a10:	78 a7       	lds	r23, 0x78
					break;
    2a12:	06 c0       	rjmp	.+12     	; 0x2a20 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2a14:	32 30       	cpi	r19, 0x02	; 2
    2a16:	71 f1       	breq	.+92     	; 0x2a74 <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2a18:	4d a3       	lds	r20, 0x5d
    2a1a:	5e a3       	lds	r21, 0x5e
    2a1c:	6f a3       	lds	r22, 0x5f
    2a1e:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2a20:	31 30       	cpi	r19, 0x01	; 1
    2a22:	51 f5       	brne	.+84     	; 0x2a78 <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2a24:	8e 01       	movw	r16, r28
    2a26:	0e 5f       	subi	r16, 0xFE	; 254
    2a28:	1f 4f       	sbci	r17, 0xFF	; 255
    2a2a:	c8 01       	movw	r24, r16
    2a2c:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2a30:	8e 89       	ldd	r24, Y+22	; 0x16
    2a32:	90 91 ce 03 	lds	r25, 0x03CE
    2a36:	98 17       	cp	r25, r24
    2a38:	10 f4       	brcc	.+4      	; 0x2a3e <xTaskGenericNotify+0xac>
    2a3a:	80 93 ce 03 	sts	0x03CE, r24
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	9c 01       	movw	r18, r24
    2a42:	22 0f       	add	r18, r18
    2a44:	33 1f       	adc	r19, r19
    2a46:	22 0f       	add	r18, r18
    2a48:	33 1f       	adc	r19, r19
    2a4a:	22 0f       	add	r18, r18
    2a4c:	33 1f       	adc	r19, r19
    2a4e:	82 0f       	add	r24, r18
    2a50:	93 1f       	adc	r25, r19
    2a52:	88 52       	subi	r24, 0x28	; 40
    2a54:	9c 4f       	sbci	r25, 0xFC	; 252
    2a56:	b8 01       	movw	r22, r16
    2a58:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a5c:	e0 91 c5 03 	lds	r30, 0x03C5
    2a60:	f0 91 c6 03 	lds	r31, 0x03C6
    2a64:	9e 89       	ldd	r25, Y+22	; 0x16
    2a66:	86 89       	ldd	r24, Z+22	; 0x16
    2a68:	89 17       	cp	r24, r25
    2a6a:	40 f4       	brcc	.+16     	; 0x2a7c <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    2a6c:	0e 94 6c 07 	call	0xed8	; 0xed8 <vPortYield>
    2a70:	81 e0       	ldi	r24, 0x01	; 1
    2a72:	05 c0       	rjmp	.+10     	; 0x2a7e <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2a74:	80 e0       	ldi	r24, 0x00	; 0
    2a76:	03 c0       	rjmp	.+6      	; 0x2a7e <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	01 c0       	rjmp	.+2      	; 0x2a7e <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a7c:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2a7e:	0f 90       	pop	r0
    2a80:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2a82:	df 91       	pop	r29
    2a84:	cf 91       	pop	r28
    2a86:	1f 91       	pop	r17
    2a88:	0f 91       	pop	r16
    2a8a:	08 95       	ret

00002a8c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2a8c:	ef 92       	push	r14
    2a8e:	ff 92       	push	r15
    2a90:	0f 93       	push	r16
    2a92:	1f 93       	push	r17
    2a94:	cf 93       	push	r28
    2a96:	df 93       	push	r29
    2a98:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2a9a:	01 15       	cp	r16, r1
    2a9c:	11 05       	cpc	r17, r1
    2a9e:	49 f0       	breq	.+18     	; 0x2ab2 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2aa0:	8d a1       	lds	r24, 0x4d
    2aa2:	9e a1       	lds	r25, 0x4e
    2aa4:	af a1       	lds	r26, 0x4f
    2aa6:	b8 a5       	lds	r27, 0x68
    2aa8:	f8 01       	movw	r30, r16
    2aaa:	80 83       	st	Z, r24
    2aac:	91 83       	std	Z+1, r25	; 0x01
    2aae:	a2 83       	std	Z+2, r26	; 0x02
    2ab0:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2ab2:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2ab4:	82 e0       	ldi	r24, 0x02	; 2
    2ab6:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2ab8:	22 30       	cpi	r18, 0x02	; 2
    2aba:	b9 f0       	breq	.+46     	; 0x2aea <xTaskGenericNotifyFromISR+0x5e>
    2abc:	23 30       	cpi	r18, 0x03	; 3
    2abe:	18 f4       	brcc	.+6      	; 0x2ac6 <xTaskGenericNotifyFromISR+0x3a>
    2ac0:	21 30       	cpi	r18, 0x01	; 1
    2ac2:	59 f5       	brne	.+86     	; 0x2b1a <xTaskGenericNotifyFromISR+0x8e>
    2ac4:	05 c0       	rjmp	.+10     	; 0x2ad0 <xTaskGenericNotifyFromISR+0x44>
    2ac6:	23 30       	cpi	r18, 0x03	; 3
    2ac8:	e1 f0       	breq	.+56     	; 0x2b02 <xTaskGenericNotifyFromISR+0x76>
    2aca:	24 30       	cpi	r18, 0x04	; 4
    2acc:	31 f5       	brne	.+76     	; 0x2b1a <xTaskGenericNotifyFromISR+0x8e>
    2ace:	1e c0       	rjmp	.+60     	; 0x2b0c <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2ad0:	8d a1       	lds	r24, 0x4d
    2ad2:	9e a1       	lds	r25, 0x4e
    2ad4:	af a1       	lds	r26, 0x4f
    2ad6:	b8 a5       	lds	r27, 0x68
    2ad8:	84 2b       	or	r24, r20
    2ada:	95 2b       	or	r25, r21
    2adc:	a6 2b       	or	r26, r22
    2ade:	b7 2b       	or	r27, r23
    2ae0:	8d a3       	lds	r24, 0x5d
    2ae2:	9e a3       	lds	r25, 0x5e
    2ae4:	af a3       	lds	r26, 0x5f
    2ae6:	b8 a7       	lds	r27, 0x78
					break;
    2ae8:	18 c0       	rjmp	.+48     	; 0x2b1a <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2aea:	8d a1       	lds	r24, 0x4d
    2aec:	9e a1       	lds	r25, 0x4e
    2aee:	af a1       	lds	r26, 0x4f
    2af0:	b8 a5       	lds	r27, 0x68
    2af2:	01 96       	adiw	r24, 0x01	; 1
    2af4:	a1 1d       	adc	r26, r1
    2af6:	b1 1d       	adc	r27, r1
    2af8:	8d a3       	lds	r24, 0x5d
    2afa:	9e a3       	lds	r25, 0x5e
    2afc:	af a3       	lds	r26, 0x5f
    2afe:	b8 a7       	lds	r27, 0x78
					break;
    2b00:	0c c0       	rjmp	.+24     	; 0x2b1a <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2b02:	4d a3       	lds	r20, 0x5d
    2b04:	5e a3       	lds	r21, 0x5e
    2b06:	6f a3       	lds	r22, 0x5f
    2b08:	78 a7       	lds	r23, 0x78
					break;
    2b0a:	07 c0       	rjmp	.+14     	; 0x2b1a <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2b0c:	32 30       	cpi	r19, 0x02	; 2
    2b0e:	09 f4       	brne	.+2      	; 0x2b12 <xTaskGenericNotifyFromISR+0x86>
    2b10:	41 c0       	rjmp	.+130    	; 0x2b94 <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2b12:	4d a3       	lds	r20, 0x5d
    2b14:	5e a3       	lds	r21, 0x5e
    2b16:	6f a3       	lds	r22, 0x5f
    2b18:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2b1a:	31 30       	cpi	r19, 0x01	; 1
    2b1c:	e9 f5       	brne	.+122    	; 0x2b98 <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2b1e:	80 91 c7 03 	lds	r24, 0x03C7
    2b22:	88 23       	and	r24, r24
    2b24:	e9 f4       	brne	.+58     	; 0x2b60 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2b26:	8e 01       	movw	r16, r28
    2b28:	0e 5f       	subi	r16, 0xFE	; 254
    2b2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b2c:	c8 01       	movw	r24, r16
    2b2e:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2b32:	8e 89       	ldd	r24, Y+22	; 0x16
    2b34:	90 91 ce 03 	lds	r25, 0x03CE
    2b38:	98 17       	cp	r25, r24
    2b3a:	10 f4       	brcc	.+4      	; 0x2b40 <xTaskGenericNotifyFromISR+0xb4>
    2b3c:	80 93 ce 03 	sts	0x03CE, r24
    2b40:	90 e0       	ldi	r25, 0x00	; 0
    2b42:	9c 01       	movw	r18, r24
    2b44:	22 0f       	add	r18, r18
    2b46:	33 1f       	adc	r19, r19
    2b48:	22 0f       	add	r18, r18
    2b4a:	33 1f       	adc	r19, r19
    2b4c:	22 0f       	add	r18, r18
    2b4e:	33 1f       	adc	r19, r19
    2b50:	82 0f       	add	r24, r18
    2b52:	93 1f       	adc	r25, r19
    2b54:	88 52       	subi	r24, 0x28	; 40
    2b56:	9c 4f       	sbci	r25, 0xFC	; 252
    2b58:	b8 01       	movw	r22, r16
    2b5a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
    2b5e:	07 c0       	rjmp	.+14     	; 0x2b6e <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2b60:	be 01       	movw	r22, r28
    2b62:	64 5f       	subi	r22, 0xF4	; 244
    2b64:	7f 4f       	sbci	r23, 0xFF	; 255
    2b66:	87 e1       	ldi	r24, 0x17	; 23
    2b68:	94 e0       	ldi	r25, 0x04	; 4
    2b6a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2b6e:	e0 91 c5 03 	lds	r30, 0x03C5
    2b72:	f0 91 c6 03 	lds	r31, 0x03C6
    2b76:	9e 89       	ldd	r25, Y+22	; 0x16
    2b78:	86 89       	ldd	r24, Z+22	; 0x16
    2b7a:	89 17       	cp	r24, r25
    2b7c:	78 f4       	brcc	.+30     	; 0x2b9c <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2b7e:	e1 14       	cp	r14, r1
    2b80:	f1 04       	cpc	r15, r1
    2b82:	21 f0       	breq	.+8      	; 0x2b8c <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2b84:	81 e0       	ldi	r24, 0x01	; 1
    2b86:	f7 01       	movw	r30, r14
    2b88:	80 83       	st	Z, r24
    2b8a:	09 c0       	rjmp	.+18     	; 0x2b9e <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2b8c:	81 e0       	ldi	r24, 0x01	; 1
    2b8e:	80 93 cb 03 	sts	0x03CB, r24
    2b92:	05 c0       	rjmp	.+10     	; 0x2b9e <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2b94:	80 e0       	ldi	r24, 0x00	; 0
    2b96:	03 c0       	rjmp	.+6      	; 0x2b9e <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	01 c0       	rjmp	.+2      	; 0x2b9e <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2b9e:	df 91       	pop	r29
    2ba0:	cf 91       	pop	r28
    2ba2:	1f 91       	pop	r17
    2ba4:	0f 91       	pop	r16
    2ba6:	ff 90       	pop	r15
    2ba8:	ef 90       	pop	r14
    2baa:	08 95       	ret

00002bac <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2bac:	ef 92       	push	r14
    2bae:	ff 92       	push	r15
    2bb0:	0f 93       	push	r16
    2bb2:	1f 93       	push	r17
    2bb4:	cf 93       	push	r28
    2bb6:	df 93       	push	r29
    2bb8:	ec 01       	movw	r28, r24
    2bba:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2bbc:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2bbe:	82 e0       	ldi	r24, 0x02	; 2
    2bc0:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    2bc2:	8d a1       	lds	r24, 0x4d
    2bc4:	9e a1       	lds	r25, 0x4e
    2bc6:	af a1       	lds	r26, 0x4f
    2bc8:	b8 a5       	lds	r27, 0x68
    2bca:	01 96       	adiw	r24, 0x01	; 1
    2bcc:	a1 1d       	adc	r26, r1
    2bce:	b1 1d       	adc	r27, r1
    2bd0:	8d a3       	lds	r24, 0x5d
    2bd2:	9e a3       	lds	r25, 0x5e
    2bd4:	af a3       	lds	r26, 0x5f
    2bd6:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2bd8:	21 30       	cpi	r18, 0x01	; 1
    2bda:	e9 f5       	brne	.+122    	; 0x2c56 <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2bdc:	80 91 c7 03 	lds	r24, 0x03C7
    2be0:	88 23       	and	r24, r24
    2be2:	01 f5       	brne	.+64     	; 0x2c24 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2be4:	ee 24       	eor	r14, r14
    2be6:	ff 24       	eor	r15, r15
    2be8:	68 94       	set
    2bea:	e1 f8       	bld	r14, 1
    2bec:	ec 0e       	add	r14, r28
    2bee:	fd 1e       	adc	r15, r29
    2bf0:	c7 01       	movw	r24, r14
    2bf2:	0e 94 7e 06 	call	0xcfc	; 0xcfc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2bf6:	8e 89       	ldd	r24, Y+22	; 0x16
    2bf8:	90 91 ce 03 	lds	r25, 0x03CE
    2bfc:	98 17       	cp	r25, r24
    2bfe:	10 f4       	brcc	.+4      	; 0x2c04 <vTaskNotifyGiveFromISR+0x58>
    2c00:	80 93 ce 03 	sts	0x03CE, r24
    2c04:	90 e0       	ldi	r25, 0x00	; 0
    2c06:	9c 01       	movw	r18, r24
    2c08:	22 0f       	add	r18, r18
    2c0a:	33 1f       	adc	r19, r19
    2c0c:	22 0f       	add	r18, r18
    2c0e:	33 1f       	adc	r19, r19
    2c10:	22 0f       	add	r18, r18
    2c12:	33 1f       	adc	r19, r19
    2c14:	82 0f       	add	r24, r18
    2c16:	93 1f       	adc	r25, r19
    2c18:	88 52       	subi	r24, 0x28	; 40
    2c1a:	9c 4f       	sbci	r25, 0xFC	; 252
    2c1c:	b7 01       	movw	r22, r14
    2c1e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
    2c22:	07 c0       	rjmp	.+14     	; 0x2c32 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2c24:	be 01       	movw	r22, r28
    2c26:	64 5f       	subi	r22, 0xF4	; 244
    2c28:	7f 4f       	sbci	r23, 0xFF	; 255
    2c2a:	87 e1       	ldi	r24, 0x17	; 23
    2c2c:	94 e0       	ldi	r25, 0x04	; 4
    2c2e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2c32:	e0 91 c5 03 	lds	r30, 0x03C5
    2c36:	f0 91 c6 03 	lds	r31, 0x03C6
    2c3a:	9e 89       	ldd	r25, Y+22	; 0x16
    2c3c:	86 89       	ldd	r24, Z+22	; 0x16
    2c3e:	89 17       	cp	r24, r25
    2c40:	50 f4       	brcc	.+20     	; 0x2c56 <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2c42:	01 15       	cp	r16, r1
    2c44:	11 05       	cpc	r17, r1
    2c46:	21 f0       	breq	.+8      	; 0x2c50 <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2c48:	81 e0       	ldi	r24, 0x01	; 1
    2c4a:	f8 01       	movw	r30, r16
    2c4c:	80 83       	st	Z, r24
    2c4e:	03 c0       	rjmp	.+6      	; 0x2c56 <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2c50:	81 e0       	ldi	r24, 0x01	; 1
    2c52:	80 93 cb 03 	sts	0x03CB, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2c56:	df 91       	pop	r29
    2c58:	cf 91       	pop	r28
    2c5a:	1f 91       	pop	r17
    2c5c:	0f 91       	pop	r16
    2c5e:	ff 90       	pop	r15
    2c60:	ef 90       	pop	r14
    2c62:	08 95       	ret

00002c64 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    2c64:	00 97       	sbiw	r24, 0x00	; 0
    2c66:	29 f4       	brne	.+10     	; 0x2c72 <xTaskNotifyStateClear+0xe>
    2c68:	e0 91 c5 03 	lds	r30, 0x03C5
    2c6c:	f0 91 c6 03 	lds	r31, 0x03C6
    2c70:	01 c0       	rjmp	.+2      	; 0x2c74 <xTaskNotifyStateClear+0x10>
    2c72:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    2c74:	0f b6       	in	r0, 0x3f	; 63
    2c76:	f8 94       	cli
    2c78:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2c7a:	81 a5       	lds	r24, 0x61
    2c7c:	82 30       	cpi	r24, 0x02	; 2
    2c7e:	19 f4       	brne	.+6      	; 0x2c86 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2c80:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    2c82:	81 e0       	ldi	r24, 0x01	; 1
    2c84:	01 c0       	rjmp	.+2      	; 0x2c88 <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    2c86:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2c88:	0f 90       	pop	r0
    2c8a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2c8c:	08 95       	ret

00002c8e <Keypad_vinit>:
#include "dio.h"
#include "Keybad.h"

void Keypad_vinit (void)
{
    DIO_vset_pin_direction(ROW_PORT , R1 , 1);
    2c8e:	83 e6       	ldi	r24, 0x63	; 99
    2c90:	60 e0       	ldi	r22, 0x00	; 0
    2c92:	41 e0       	ldi	r20, 0x01	; 1
    2c94:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
    DIO_vset_pin_direction(ROW_PORT , R2 , 1);
    2c98:	83 e6       	ldi	r24, 0x63	; 99
    2c9a:	61 e0       	ldi	r22, 0x01	; 1
    2c9c:	41 e0       	ldi	r20, 0x01	; 1
    2c9e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
    DIO_vset_pin_direction(ROW_PORT , R3 , 1);
    2ca2:	83 e6       	ldi	r24, 0x63	; 99
    2ca4:	62 e0       	ldi	r22, 0x02	; 2
    2ca6:	41 e0       	ldi	r20, 0x01	; 1
    2ca8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
    DIO_vset_pin_direction(ROW_PORT , R4 , 1);
    2cac:	83 e6       	ldi	r24, 0x63	; 99
    2cae:	63 e0       	ldi	r22, 0x03	; 3
    2cb0:	41 e0       	ldi	r20, 0x01	; 1
    2cb2:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>

    DIO_vset_pin_direction(COL_PORT , C1 , 0);
    2cb6:	84 e6       	ldi	r24, 0x64	; 100
    2cb8:	64 e0       	ldi	r22, 0x04	; 4
    2cba:	40 e0       	ldi	r20, 0x00	; 0
    2cbc:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
    DIO_vset_pin_direction(COL_PORT , C2 , 0);
    2cc0:	84 e6       	ldi	r24, 0x64	; 100
    2cc2:	65 e0       	ldi	r22, 0x05	; 5
    2cc4:	40 e0       	ldi	r20, 0x00	; 0
    2cc6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
    DIO_vset_pin_direction(COL_PORT , C3 , 0);
    2cca:	84 e6       	ldi	r24, 0x64	; 100
    2ccc:	66 e0       	ldi	r22, 0x06	; 6
    2cce:	40 e0       	ldi	r20, 0x00	; 0
    2cd0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
    DIO_vset_pin_direction(COL_PORT , C4 , 0);
    2cd4:	84 e6       	ldi	r24, 0x64	; 100
    2cd6:	67 e0       	ldi	r22, 0x07	; 7
    2cd8:	40 e0       	ldi	r20, 0x00	; 0
    2cda:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>

	DIO_vinternal_pull_up_pin(COL_PORT , C1 , 1);//pin_portname default is 1111 
    2cde:	84 e6       	ldi	r24, 0x64	; 100
    2ce0:	64 e0       	ldi	r22, 0x04	; 4
    2ce2:	41 e0       	ldi	r20, 0x01	; 1
    2ce4:	0e 94 a5 02 	call	0x54a	; 0x54a <DIO_vinternal_pull_up_pin>
	DIO_vinternal_pull_up_pin(COL_PORT , C2 , 1);
    2ce8:	84 e6       	ldi	r24, 0x64	; 100
    2cea:	65 e0       	ldi	r22, 0x05	; 5
    2cec:	41 e0       	ldi	r20, 0x01	; 1
    2cee:	0e 94 a5 02 	call	0x54a	; 0x54a <DIO_vinternal_pull_up_pin>
	DIO_vinternal_pull_up_pin(COL_PORT , C3 , 1);
    2cf2:	84 e6       	ldi	r24, 0x64	; 100
    2cf4:	66 e0       	ldi	r22, 0x06	; 6
    2cf6:	41 e0       	ldi	r20, 0x01	; 1
    2cf8:	0e 94 a5 02 	call	0x54a	; 0x54a <DIO_vinternal_pull_up_pin>
	DIO_vinternal_pull_up_pin(COL_PORT , C4 , 1);	
    2cfc:	84 e6       	ldi	r24, 0x64	; 100
    2cfe:	67 e0       	ldi	r22, 0x07	; 7
    2d00:	41 e0       	ldi	r20, 0x01	; 1
    2d02:	0e 94 a5 02 	call	0x54a	; 0x54a <DIO_vinternal_pull_up_pin>
}
    2d06:	08 95       	ret

00002d08 <Keypad_u8read>:

unsigned char Keypad_u8read(void)
{
    2d08:	2f 92       	push	r2
    2d0a:	3f 92       	push	r3
    2d0c:	4f 92       	push	r4
    2d0e:	5f 92       	push	r5
    2d10:	6f 92       	push	r6
    2d12:	7f 92       	push	r7
    2d14:	8f 92       	push	r8
    2d16:	9f 92       	push	r9
    2d18:	af 92       	push	r10
    2d1a:	bf 92       	push	r11
    2d1c:	df 92       	push	r13
    2d1e:	ef 92       	push	r14
    2d20:	ff 92       	push	r15
    2d22:	0f 93       	push	r16
    2d24:	1f 93       	push	r17
    2d26:	cf 93       	push	r28
    2d28:	df 93       	push	r29
    2d2a:	cd b7       	in	r28, 0x3d	; 61
    2d2c:	de b7       	in	r29, 0x3e	; 62
    2d2e:	68 97       	sbiw	r28, 0x18	; 24
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	de bf       	out	0x3e, r29	; 62
    2d36:	0f be       	out	0x3f, r0	; 63
    2d38:	cd bf       	out	0x3d, r28	; 61
	char keybad[4][4] = { {7,8,9,'/'} , {4,5,6,'*'} , {1,2,3,'-'} , {'A',0,'=','+'} };
    2d3a:	de 01       	movw	r26, r28
    2d3c:	11 96       	adiw	r26, 0x01	; 1
    2d3e:	e7 e6       	ldi	r30, 0x67	; 103
    2d40:	f0 e0       	ldi	r31, 0x00	; 0
    2d42:	80 e1       	ldi	r24, 0x10	; 16
    2d44:	01 90       	ld	r0, Z+
    2d46:	0d 92       	st	X+, r0
    2d48:	81 50       	subi	r24, 0x01	; 1
    2d4a:	e1 f7       	brne	.-8      	; 0x2d44 <Keypad_u8read+0x3c>
    char Keypad_Row[] = { R1, R2, R3, R4 }; //rows
    2d4c:	19 8a       	std	Y+17, r1	; 0x11
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	8a 8b       	std	Y+18, r24	; 0x12
    2d52:	82 e0       	ldi	r24, 0x02	; 2
    2d54:	8b 8b       	std	Y+19, r24	; 0x13
    2d56:	83 e0       	ldi	r24, 0x03	; 3
    2d58:	8c 8b       	std	Y+20, r24	; 0x14
	char Keypad_Col[] = { C1, C2, C3, C4 }; //columns
    2d5a:	84 e0       	ldi	r24, 0x04	; 4
    2d5c:	8d 8b       	std	Y+21, r24	; 0x15
    2d5e:	85 e0       	ldi	r24, 0x05	; 5
    2d60:	8e 8b       	std	Y+22, r24	; 0x16
    2d62:	86 e0       	ldi	r24, 0x06	; 6
    2d64:	8f 8b       	std	Y+23, r24	; 0x17
    2d66:	87 e0       	ldi	r24, 0x07	; 7
    2d68:	88 8f       	std	Y+24, r24	; 0x18
    2d6a:	0f 2e       	mov	r0, r31
    2d6c:	f1 e1       	ldi	r31, 0x11	; 17
    2d6e:	6f 2e       	mov	r6, r31
    2d70:	77 24       	eor	r7, r7
    2d72:	f0 2d       	mov	r31, r0
    2d74:	6c 0e       	add	r6, r28
    2d76:	7d 1e       	adc	r7, r29
    2d78:	88 24       	eor	r8, r8
    2d7a:	99 24       	eor	r9, r9
	{
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[0] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[1] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[2] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[3] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[row] , 0);
    2d7c:	22 24       	eor	r2, r2
    2d7e:	33 24       	eor	r3, r3

	char row , column , x ;
	char retval = NOT_PRESSED;
	for (row=0 ; row<4 ; row++)
	{
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[0] , 1);
    2d80:	83 e6       	ldi	r24, 0x63	; 99
    2d82:	60 e0       	ldi	r22, 0x00	; 0
    2d84:	41 e0       	ldi	r20, 0x01	; 1
    2d86:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[1] , 1);
    2d8a:	83 e6       	ldi	r24, 0x63	; 99
    2d8c:	61 e0       	ldi	r22, 0x01	; 1
    2d8e:	41 e0       	ldi	r20, 0x01	; 1
    2d90:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[2] , 1);
    2d94:	83 e6       	ldi	r24, 0x63	; 99
    2d96:	62 e0       	ldi	r22, 0x02	; 2
    2d98:	41 e0       	ldi	r20, 0x01	; 1
    2d9a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[3] , 1);
    2d9e:	83 e6       	ldi	r24, 0x63	; 99
    2da0:	63 e0       	ldi	r22, 0x03	; 3
    2da2:	41 e0       	ldi	r20, 0x01	; 1
    2da4:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[row] , 0);
    2da8:	24 01       	movw	r4, r8
    2daa:	f3 01       	movw	r30, r6
    2dac:	61 91       	ld	r22, Z+
    2dae:	3f 01       	movw	r6, r30
    2db0:	83 e6       	ldi	r24, 0x63	; 99
    2db2:	40 e0       	ldi	r20, 0x00	; 0
    2db4:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
    2db8:	0f 2e       	mov	r0, r31
    2dba:	f5 e1       	ldi	r31, 0x15	; 21
    2dbc:	ef 2e       	mov	r14, r31
    2dbe:	ff 24       	eor	r15, r15
    2dc0:	f0 2d       	mov	r31, r0
    2dc2:	ec 0e       	add	r14, r28
    2dc4:	fd 1e       	adc	r15, r29
    2dc6:	81 01       	movw	r16, r2
		for (column=0 ; column<4 ; column++)
		{
			x=DIO_u8read_pin(COL_PORT , Keypad_Col[column]);
    2dc8:	58 01       	movw	r10, r16
    2dca:	f7 01       	movw	r30, r14
    2dcc:	d1 90       	ld	r13, Z+
    2dce:	7f 01       	movw	r14, r30
    2dd0:	84 e6       	ldi	r24, 0x64	; 100
    2dd2:	6d 2d       	mov	r22, r13
    2dd4:	0e 94 b8 01 	call	0x370	; 0x370 <DIO_u8read_pin>
			if (x == 0)
    2dd8:	88 23       	and	r24, r24
    2dda:	91 f4       	brne	.+36     	; 0x2e00 <Keypad_u8read+0xf8>
			{
				retval = keybad[row][column];
    2ddc:	f2 01       	movw	r30, r4
    2dde:	ee 0f       	add	r30, r30
    2de0:	ff 1f       	adc	r31, r31
    2de2:	ee 0f       	add	r30, r30
    2de4:	ff 1f       	adc	r31, r31
    2de6:	ae 0e       	add	r10, r30
    2de8:	bf 1e       	adc	r11, r31
    2dea:	fe 01       	movw	r30, r28
    2dec:	ea 0d       	add	r30, r10
    2dee:	fb 1d       	adc	r31, r11
    2df0:	01 81       	ldd	r16, Z+1	; 0x01
				while(DIO_u8read_pin(COL_PORT , Keypad_Col[column]) == 0);//continuous pressed
    2df2:	84 e6       	ldi	r24, 0x64	; 100
    2df4:	6d 2d       	mov	r22, r13
    2df6:	0e 94 b8 01 	call	0x370	; 0x370 <DIO_u8read_pin>
    2dfa:	88 23       	and	r24, r24
    2dfc:	d1 f3       	breq	.-12     	; 0x2df2 <Keypad_u8read+0xea>
    2dfe:	06 c0       	rjmp	.+12     	; 0x2e0c <Keypad_u8read+0x104>
    2e00:	0f 5f       	subi	r16, 0xFF	; 255
    2e02:	1f 4f       	sbci	r17, 0xFF	; 255
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[0] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[1] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[2] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[3] , 1);
		DIO_vwrite_pin_value(ROW_PORT , Keypad_Row[row] , 0);
		for (column=0 ; column<4 ; column++)
    2e04:	04 30       	cpi	r16, 0x04	; 4
    2e06:	11 05       	cpc	r17, r1
    2e08:	f9 f6       	brne	.-66     	; 0x2dc8 <Keypad_u8read+0xc0>
    2e0a:	19 c0       	rjmp	.+50     	; 0x2e3e <Keypad_u8read+0x136>
		{
			break;
		}
	}
	return retval;
    2e0c:	80 2f       	mov	r24, r16
    2e0e:	68 96       	adiw	r28, 0x18	; 24
    2e10:	0f b6       	in	r0, 0x3f	; 63
    2e12:	f8 94       	cli
    2e14:	de bf       	out	0x3e, r29	; 62
    2e16:	0f be       	out	0x3f, r0	; 63
    2e18:	cd bf       	out	0x3d, r28	; 61
    2e1a:	df 91       	pop	r29
    2e1c:	cf 91       	pop	r28
    2e1e:	1f 91       	pop	r17
    2e20:	0f 91       	pop	r16
    2e22:	ff 90       	pop	r15
    2e24:	ef 90       	pop	r14
    2e26:	df 90       	pop	r13
    2e28:	bf 90       	pop	r11
    2e2a:	af 90       	pop	r10
    2e2c:	9f 90       	pop	r9
    2e2e:	8f 90       	pop	r8
    2e30:	7f 90       	pop	r7
    2e32:	6f 90       	pop	r6
    2e34:	5f 90       	pop	r5
    2e36:	4f 90       	pop	r4
    2e38:	3f 90       	pop	r3
    2e3a:	2f 90       	pop	r2
    2e3c:	08 95       	ret
		if (x == 0)
		{
			break;
		}
	}
	return retval;
    2e3e:	08 94       	sec
    2e40:	81 1c       	adc	r8, r1
    2e42:	91 1c       	adc	r9, r1
    char Keypad_Row[] = { R1, R2, R3, R4 }; //rows
	char Keypad_Col[] = { C1, C2, C3, C4 }; //columns

	char row , column , x ;
	char retval = NOT_PRESSED;
	for (row=0 ; row<4 ; row++)
    2e44:	f4 e0       	ldi	r31, 0x04	; 4
    2e46:	8f 16       	cp	r8, r31
    2e48:	91 04       	cpc	r9, r1
    2e4a:	09 f0       	breq	.+2      	; 0x2e4e <Keypad_u8read+0x146>
    2e4c:	99 cf       	rjmp	.-206    	; 0x2d80 <Keypad_u8read+0x78>
    2e4e:	0f ef       	ldi	r16, 0xFF	; 255
    2e50:	dd cf       	rjmp	.-70     	; 0x2e0c <Keypad_u8read+0x104>

00002e52 <Enable_bit>:
	
}
/********* pulse_enable_lcd ********/
static void Enable_bit (void)
{
	DIO_vwrite_pin_value(portname_control , EN , 1);
    2e52:	81 e6       	ldi	r24, 0x61	; 97
    2e54:	60 e0       	ldi	r22, 0x00	; 0
    2e56:	41 e0       	ldi	r20, 0x01	; 1
    2e58:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2e5c:	8f e9       	ldi	r24, 0x9F	; 159
    2e5e:	9f e0       	ldi	r25, 0x0F	; 15
    2e60:	01 97       	sbiw	r24, 0x01	; 1
    2e62:	f1 f7       	brne	.-4      	; 0x2e60 <Enable_bit+0xe>
    2e64:	00 c0       	rjmp	.+0      	; 0x2e66 <Enable_bit+0x14>
    2e66:	00 00       	nop
	_delay_ms(2);
	DIO_vwrite_pin_value(portname_control , EN , 0);
    2e68:	81 e6       	ldi	r24, 0x61	; 97
    2e6a:	60 e0       	ldi	r22, 0x00	; 0
    2e6c:	40 e0       	ldi	r20, 0x00	; 0
    2e6e:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
    2e72:	8f e9       	ldi	r24, 0x9F	; 159
    2e74:	9f e0       	ldi	r25, 0x0F	; 15
    2e76:	01 97       	sbiw	r24, 0x01	; 1
    2e78:	f1 f7       	brne	.-4      	; 0x2e76 <Enable_bit+0x24>
    2e7a:	00 c0       	rjmp	.+0      	; 0x2e7c <Enable_bit+0x2a>
    2e7c:	00 00       	nop
	_delay_ms(2);
}
    2e7e:	08 95       	ret

00002e80 <LCD_vinit>:

/********************************* driver_LCD **************************************/

/********* initialization_lcd ********/
void LCD_vinit()
{
    2e80:	cf 93       	push	r28
    2e82:	df 93       	push	r29
    2e84:	8f ef       	ldi	r24, 0xFF	; 255
    2e86:	90 e7       	ldi	r25, 0x70	; 112
    2e88:	a2 e0       	ldi	r26, 0x02	; 2
    2e8a:	81 50       	subi	r24, 0x01	; 1
    2e8c:	90 40       	sbci	r25, 0x00	; 0
    2e8e:	a0 40       	sbci	r26, 0x00	; 0
    2e90:	e1 f7       	brne	.-8      	; 0x2e8a <LCD_vinit+0xa>
    2e92:	00 c0       	rjmp	.+0      	; 0x2e94 <LCD_vinit+0x14>
    2e94:	00 00       	nop
	LCD_vsend_cmd(Entry_Mode_increase_AC_no_shift);//increase cursor step
	_delay_ms(10);
	
	/******* 4-bit mode ********/
	#elif defined Four_Bit_Mode
	DIO_vset_pin_direction(portname_dataline , pin_nibble   , 1);
    2e96:	81 e6       	ldi	r24, 0x61	; 97
    2e98:	64 e0       	ldi	r22, 0x04	; 4
    2e9a:	41 e0       	ldi	r20, 0x01	; 1
    2e9c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	DIO_vset_pin_direction(portname_dataline , pin_nibble+1 , 1);
    2ea0:	81 e6       	ldi	r24, 0x61	; 97
    2ea2:	65 e0       	ldi	r22, 0x05	; 5
    2ea4:	41 e0       	ldi	r20, 0x01	; 1
    2ea6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	DIO_vset_pin_direction(portname_dataline , pin_nibble+2 , 1);
    2eaa:	81 e6       	ldi	r24, 0x61	; 97
    2eac:	66 e0       	ldi	r22, 0x06	; 6
    2eae:	41 e0       	ldi	r20, 0x01	; 1
    2eb0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	DIO_vset_pin_direction(portname_dataline , pin_nibble+3 , 1);
    2eb4:	81 e6       	ldi	r24, 0x61	; 97
    2eb6:	67 e0       	ldi	r22, 0x07	; 7
    2eb8:	41 e0       	ldi	r20, 0x01	; 1
    2eba:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	DIO_vset_pin_direction(portname_control   , EN , 1);
    2ebe:	81 e6       	ldi	r24, 0x61	; 97
    2ec0:	60 e0       	ldi	r22, 0x00	; 0
    2ec2:	41 e0       	ldi	r20, 0x01	; 1
    2ec4:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	DIO_vset_pin_direction(portname_control   , RW , 1);
    2ec8:	81 e6       	ldi	r24, 0x61	; 97
    2eca:	61 e0       	ldi	r22, 0x01	; 1
    2ecc:	41 e0       	ldi	r20, 0x01	; 1
    2ece:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	DIO_vset_pin_direction(portname_control   , RS , 1);
    2ed2:	81 e6       	ldi	r24, 0x61	; 97
    2ed4:	62 e0       	ldi	r22, 0x02	; 2
    2ed6:	41 e0       	ldi	r20, 0x01	; 1
    2ed8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_vset_pin_direction>
	// enable write on lcd
	DIO_vwrite_pin_value(portname_control , RW , 0);
    2edc:	81 e6       	ldi	r24, 0x61	; 97
    2ede:	61 e0       	ldi	r22, 0x01	; 1
    2ee0:	40 e0       	ldi	r20, 0x00	; 0
    2ee2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	// command instructions
	LCD_vsend_cmd(Return_Home); //return home
    2ee6:	cc ed       	ldi	r28, 0xDC	; 220
    2ee8:	d7 e1       	ldi	r29, 0x17	; 23
    2eea:	82 e0       	ldi	r24, 0x02	; 2
    2eec:	90 e0       	ldi	r25, 0x00	; 0
    2eee:	fe 01       	movw	r30, r28
    2ef0:	09 95       	icall
    2ef2:	af e1       	ldi	r26, 0x1F	; 31
    2ef4:	be e4       	ldi	r27, 0x4E	; 78
    2ef6:	11 97       	sbiw	r26, 0x01	; 1
    2ef8:	f1 f7       	brne	.-4      	; 0x2ef6 <LCD_vinit+0x76>
    2efa:	00 c0       	rjmp	.+0      	; 0x2efc <LCD_vinit+0x7c>
    2efc:	00 00       	nop
	_delay_ms(10);
	LCD_vsend_cmd(Four_Bit);//4bit-mode
    2efe:	88 e2       	ldi	r24, 0x28	; 40
    2f00:	90 e0       	ldi	r25, 0x00	; 0
    2f02:	fe 01       	movw	r30, r28
    2f04:	09 95       	icall
    2f06:	8f e1       	ldi	r24, 0x1F	; 31
    2f08:	9e e4       	ldi	r25, 0x4E	; 78
    2f0a:	01 97       	sbiw	r24, 0x01	; 1
    2f0c:	f1 f7       	brne	.-4      	; 0x2f0a <LCD_vinit+0x8a>
    2f0e:	00 c0       	rjmp	.+0      	; 0x2f10 <LCD_vinit+0x90>
    2f10:	00 00       	nop
	_delay_ms(10);
	LCD_vsend_cmd(Disblay_On_Cursor_Off);//appear cursor and display
    2f12:	8c e0       	ldi	r24, 0x0C	; 12
    2f14:	90 e0       	ldi	r25, 0x00	; 0
    2f16:	fe 01       	movw	r30, r28
    2f18:	09 95       	icall
    2f1a:	af e1       	ldi	r26, 0x1F	; 31
    2f1c:	be e4       	ldi	r27, 0x4E	; 78
    2f1e:	11 97       	sbiw	r26, 0x01	; 1
    2f20:	f1 f7       	brne	.-4      	; 0x2f1e <LCD_vinit+0x9e>
    2f22:	00 c0       	rjmp	.+0      	; 0x2f24 <LCD_vinit+0xa4>
    2f24:	00 00       	nop
	_delay_ms(10);
	LCD_vsend_cmd(Clear_Screen);//clear lcd
    2f26:	81 e0       	ldi	r24, 0x01	; 1
    2f28:	90 e0       	ldi	r25, 0x00	; 0
    2f2a:	fe 01       	movw	r30, r28
    2f2c:	09 95       	icall
    2f2e:	8f e1       	ldi	r24, 0x1F	; 31
    2f30:	9e e4       	ldi	r25, 0x4E	; 78
    2f32:	01 97       	sbiw	r24, 0x01	; 1
    2f34:	f1 f7       	brne	.-4      	; 0x2f32 <LCD_vinit+0xb2>
    2f36:	00 c0       	rjmp	.+0      	; 0x2f38 <LCD_vinit+0xb8>
    2f38:	00 00       	nop
	_delay_ms(10);
	LCD_vsend_cmd(Entry_Mode_increase_AC_no_shift);//increase cursor step
    2f3a:	86 e0       	ldi	r24, 0x06	; 6
    2f3c:	90 e0       	ldi	r25, 0x00	; 0
    2f3e:	fe 01       	movw	r30, r28
    2f40:	09 95       	icall
    2f42:	af e1       	ldi	r26, 0x1F	; 31
    2f44:	be e4       	ldi	r27, 0x4E	; 78
    2f46:	11 97       	sbiw	r26, 0x01	; 1
    2f48:	f1 f7       	brne	.-4      	; 0x2f46 <LCD_vinit+0xc6>
    2f4a:	00 c0       	rjmp	.+0      	; 0x2f4c <LCD_vinit+0xcc>
    2f4c:	00 00       	nop
	_delay_ms(10);
	#endif
	
}
    2f4e:	df 91       	pop	r29
    2f50:	cf 91       	pop	r28
    2f52:	08 95       	ret

00002f54 <LCD_vsend_char>:
	_delay_ms(2);
}

/********* send_char_lcd ********/
void LCD_vsend_char(char char_send)
{
    2f54:	cf 93       	push	r28
    2f56:	c8 2f       	mov	r28, r24
	Enable_bit();
	
	/******* 4-bit mode ********/
	#elif defined Four_Bit_Mode
	//send MSB
	DIO_vhigh_nibble_write(portname_dataline , char_send >> 4);
    2f58:	68 2f       	mov	r22, r24
    2f5a:	62 95       	swap	r22
    2f5c:	6f 70       	andi	r22, 0x0F	; 15
    2f5e:	81 e6       	ldi	r24, 0x61	; 97
    2f60:	0e 94 69 03 	call	0x6d2	; 0x6d2 <DIO_vhigh_nibble_write>
	DIO_vwrite_pin_value(portname_control , RS , 1);
    2f64:	81 e6       	ldi	r24, 0x61	; 97
    2f66:	62 e0       	ldi	r22, 0x02	; 2
    2f68:	41 e0       	ldi	r20, 0x01	; 1
    2f6a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	Enable_bit();
    2f6e:	0e 94 29 17 	call	0x2e52	; 0x2e52 <Enable_bit>
	//send LSB
	DIO_vhigh_nibble_write(portname_dataline , char_send);
    2f72:	81 e6       	ldi	r24, 0x61	; 97
    2f74:	6c 2f       	mov	r22, r28
    2f76:	0e 94 69 03 	call	0x6d2	; 0x6d2 <DIO_vhigh_nibble_write>
	DIO_vwrite_pin_value(portname_control , RS , 1);
    2f7a:	81 e6       	ldi	r24, 0x61	; 97
    2f7c:	62 e0       	ldi	r22, 0x02	; 2
    2f7e:	41 e0       	ldi	r20, 0x01	; 1
    2f80:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	Enable_bit();
    2f84:	0e 94 29 17 	call	0x2e52	; 0x2e52 <Enable_bit>
    2f88:	8f e1       	ldi	r24, 0x1F	; 31
    2f8a:	9e e4       	ldi	r25, 0x4E	; 78
    2f8c:	01 97       	sbiw	r24, 0x01	; 1
    2f8e:	f1 f7       	brne	.-4      	; 0x2f8c <LCD_vsend_char+0x38>
    2f90:	00 c0       	rjmp	.+0      	; 0x2f92 <LCD_vsend_char+0x3e>
    2f92:	00 00       	nop
	#endif
	_delay_ms(10);
}
    2f94:	cf 91       	pop	r28
    2f96:	08 95       	ret

00002f98 <LCD_u8read_busy_flag>:

/************** busy_flag ******************/
unsigned char LCD_u8read_busy_flag(void)
{
	DIO_vwrite_pin_value(portname_control , RW , 1); // read
    2f98:	81 e6       	ldi	r24, 0x61	; 97
    2f9a:	61 e0       	ldi	r22, 0x01	; 1
    2f9c:	41 e0       	ldi	r20, 0x01	; 1
    2f9e:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	DIO_vwrite_pin_value(portname_control , RS , 0);
    2fa2:	81 e6       	ldi	r24, 0x61	; 97
    2fa4:	62 e0       	ldi	r22, 0x02	; 2
    2fa6:	40 e0       	ldi	r20, 0x00	; 0
    2fa8:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	while(BIT_IS_SET(portname_dataline , 7));
	DIO_vwrite_pin_value(portname_control , RW , 0); // write
    2fac:	81 e6       	ldi	r24, 0x61	; 97
    2fae:	61 e0       	ldi	r22, 0x01	; 1
    2fb0:	40 e0       	ldi	r20, 0x00	; 0
    2fb2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
}
    2fb6:	08 95       	ret

00002fb8 <LCD_vsend_cmd>:

/********* send_command_lcd ********/
void LCD_vsend_cmd(char cmd_send)
{
    2fb8:	cf 93       	push	r28
    2fba:	c8 2f       	mov	r28, r24
	Enable_bit();
	
	/******* 4-bit mode ********/
	#elif defined Four_Bit_Mode
	//send MSB
	DIO_vhigh_nibble_write(portname_dataline , cmd_send >> 4);
    2fbc:	68 2f       	mov	r22, r24
    2fbe:	62 95       	swap	r22
    2fc0:	6f 70       	andi	r22, 0x0F	; 15
    2fc2:	81 e6       	ldi	r24, 0x61	; 97
    2fc4:	0e 94 69 03 	call	0x6d2	; 0x6d2 <DIO_vhigh_nibble_write>
	DIO_vwrite_pin_value(portname_control , RS , 0);
    2fc8:	81 e6       	ldi	r24, 0x61	; 97
    2fca:	62 e0       	ldi	r22, 0x02	; 2
    2fcc:	40 e0       	ldi	r20, 0x00	; 0
    2fce:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	Enable_bit();
    2fd2:	0e 94 29 17 	call	0x2e52	; 0x2e52 <Enable_bit>
	//send LSB
	DIO_vhigh_nibble_write(portname_dataline , cmd_send);
    2fd6:	81 e6       	ldi	r24, 0x61	; 97
    2fd8:	6c 2f       	mov	r22, r28
    2fda:	0e 94 69 03 	call	0x6d2	; 0x6d2 <DIO_vhigh_nibble_write>
	DIO_vwrite_pin_value(portname_control , RS , 0);
    2fde:	81 e6       	ldi	r24, 0x61	; 97
    2fe0:	62 e0       	ldi	r22, 0x02	; 2
    2fe2:	40 e0       	ldi	r20, 0x00	; 0
    2fe4:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_vwrite_pin_value>
	Enable_bit();
    2fe8:	0e 94 29 17 	call	0x2e52	; 0x2e52 <Enable_bit>
	#endif
	LCD_u8read_busy_flag();
    2fec:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <LCD_u8read_busy_flag>
	//_delay_ms(10);
}
    2ff0:	cf 91       	pop	r28
    2ff2:	08 95       	ret

00002ff4 <LCD_vmove_cursor>:

/********* move_cursor_lcd ********/
void LCD_vmove_cursor (char row , char column)
{
	char cmd;
	if (row>4 || row<1  ||  column>16 || column<1)
    2ff4:	28 2f       	mov	r18, r24
    2ff6:	21 50       	subi	r18, 0x01	; 1
    2ff8:	24 30       	cpi	r18, 0x04	; 4
    2ffa:	c0 f4       	brcc	.+48     	; 0x302c <LCD_vmove_cursor+0x38>
    2ffc:	61 31       	cpi	r22, 0x11	; 17
    2ffe:	c0 f4       	brcc	.+48     	; 0x3030 <LCD_vmove_cursor+0x3c>
    3000:	66 23       	and	r22, r22
    3002:	c1 f0       	breq	.+48     	; 0x3034 <LCD_vmove_cursor+0x40>
	{
		cmd = 0x80;
	} 
	else if(row == 1)
    3004:	81 30       	cpi	r24, 0x01	; 1
    3006:	19 f4       	brne	.+6      	; 0x300e <LCD_vmove_cursor+0x1a>
	{
		cmd = (0x80 + column -1);
    3008:	96 2f       	mov	r25, r22
    300a:	91 58       	subi	r25, 0x81	; 129
    300c:	14 c0       	rjmp	.+40     	; 0x3036 <LCD_vmove_cursor+0x42>
	}
	else if (row == 2)
    300e:	82 30       	cpi	r24, 0x02	; 2
    3010:	19 f4       	brne	.+6      	; 0x3018 <LCD_vmove_cursor+0x24>
	{
		cmd = (0xC0 + column -1);
    3012:	96 2f       	mov	r25, r22
    3014:	91 54       	subi	r25, 0x41	; 65
    3016:	0f c0       	rjmp	.+30     	; 0x3036 <LCD_vmove_cursor+0x42>
	}
    else if (row == 3)
    3018:	83 30       	cpi	r24, 0x03	; 3
    301a:	19 f4       	brne	.+6      	; 0x3022 <LCD_vmove_cursor+0x2e>
    {
        cmd = (0x90 + column -1);
    301c:	96 2f       	mov	r25, r22
    301e:	91 57       	subi	r25, 0x71	; 113
    3020:	0a c0       	rjmp	.+20     	; 0x3036 <LCD_vmove_cursor+0x42>
    }
    else if (row == 4)
    3022:	84 30       	cpi	r24, 0x04	; 4
    3024:	41 f4       	brne	.+16     	; 0x3036 <LCD_vmove_cursor+0x42>
    {
        cmd = (0xD0 + column -1);
    3026:	96 2f       	mov	r25, r22
    3028:	91 53       	subi	r25, 0x31	; 49
    302a:	05 c0       	rjmp	.+10     	; 0x3036 <LCD_vmove_cursor+0x42>
void LCD_vmove_cursor (char row , char column)
{
	char cmd;
	if (row>4 || row<1  ||  column>16 || column<1)
	{
		cmd = 0x80;
    302c:	90 e8       	ldi	r25, 0x80	; 128
    302e:	03 c0       	rjmp	.+6      	; 0x3036 <LCD_vmove_cursor+0x42>
    3030:	90 e8       	ldi	r25, 0x80	; 128
    3032:	01 c0       	rjmp	.+2      	; 0x3036 <LCD_vmove_cursor+0x42>
    3034:	90 e8       	ldi	r25, 0x80	; 128
    }
    else if (row == 4)
    {
        cmd = (0xD0 + column -1);
    }
	LCD_vsend_cmd(cmd);
    3036:	89 2f       	mov	r24, r25
    3038:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <LCD_vsend_cmd>
    303c:	8f e1       	ldi	r24, 0x1F	; 31
    303e:	9e e4       	ldi	r25, 0x4E	; 78
    3040:	01 97       	sbiw	r24, 0x01	; 1
    3042:	f1 f7       	brne	.-4      	; 0x3040 <LCD_vmove_cursor+0x4c>
    3044:	00 c0       	rjmp	.+0      	; 0x3046 <LCD_vmove_cursor+0x52>
    3046:	00 00       	nop
	_delay_ms(10);
}
    3048:	08 95       	ret

0000304a <LCD_vClearScreen>:
    _delay_ms(10);
}
/*********** clear_lcd **********/
void LCD_vClearScreen(void)
{
	LCD_vsend_cmd(Clear_Screen);
    304a:	81 e0       	ldi	r24, 0x01	; 1
    304c:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <LCD_vsend_cmd>
    3050:	8f e1       	ldi	r24, 0x1F	; 31
    3052:	9e e4       	ldi	r25, 0x4E	; 78
    3054:	01 97       	sbiw	r24, 0x01	; 1
    3056:	f1 f7       	brne	.-4      	; 0x3054 <LCD_vClearScreen+0xa>
    3058:	00 c0       	rjmp	.+0      	; 0x305a <LCD_vClearScreen+0x10>
    305a:	00 00       	nop
	_delay_ms(10);
}
    305c:	08 95       	ret

0000305e <LCD_vsend_string>:
}


/********* send_string_lcd ********/
void LCD_vsend_string(char *ptr)
{
    305e:	ef 92       	push	r14
    3060:	ff 92       	push	r15
    3062:	0f 93       	push	r16
    3064:	1f 93       	push	r17
    3066:	cf 93       	push	r28
    3068:	df 93       	push	r29
    int count=0;
    306a:	08 2f       	mov	r16, r24
    306c:	19 2f       	mov	r17, r25
    306e:	c0 e0       	ldi	r28, 0x00	; 0
    3070:	d0 e0       	ldi	r29, 0x00	; 0
        }
        else if (count == 32)
        {
            LCD_vClearScreen();
            LCD_vmove_cursor(1,1);
            count = 0;
    3072:	ee 24       	eor	r14, r14
    3074:	ff 24       	eor	r15, r15

/********* send_string_lcd ********/
void LCD_vsend_string(char *ptr)
{
    int count=0;
	while(*ptr != 0)
    3076:	19 c0       	rjmp	.+50     	; 0x30aa <LCD_vsend_string+0x4c>
	{
        count++;
    3078:	21 96       	adiw	r28, 0x01	; 1
		LCD_vsend_char(*ptr++);
    307a:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <LCD_vsend_char>
        if (count == 16)
    307e:	c0 31       	cpi	r28, 0x10	; 16
    3080:	d1 05       	cpc	r29, r1
    3082:	39 f4       	brne	.+14     	; 0x3092 <LCD_vsend_string+0x34>
        {
            LCD_vmove_cursor(2,1);
    3084:	82 e0       	ldi	r24, 0x02	; 2
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	61 e0       	ldi	r22, 0x01	; 1
    308a:	70 e0       	ldi	r23, 0x00	; 0
    308c:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <LCD_vmove_cursor>
    3090:	0c c0       	rjmp	.+24     	; 0x30aa <LCD_vsend_string+0x4c>

        }
        else if (count == 32)
    3092:	c0 32       	cpi	r28, 0x20	; 32
    3094:	d1 05       	cpc	r29, r1
    3096:	49 f4       	brne	.+18     	; 0x30aa <LCD_vsend_string+0x4c>
        {
            LCD_vClearScreen();
    3098:	0e 94 25 18 	call	0x304a	; 0x304a <LCD_vClearScreen>
            LCD_vmove_cursor(1,1);
    309c:	81 e0       	ldi	r24, 0x01	; 1
    309e:	90 e0       	ldi	r25, 0x00	; 0
    30a0:	61 e0       	ldi	r22, 0x01	; 1
    30a2:	70 e0       	ldi	r23, 0x00	; 0
    30a4:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <LCD_vmove_cursor>
            count = 0;
    30a8:	e7 01       	movw	r28, r14

/********* send_string_lcd ********/
void LCD_vsend_string(char *ptr)
{
    int count=0;
	while(*ptr != 0)
    30aa:	f8 01       	movw	r30, r16
    30ac:	81 91       	ld	r24, Z+
    30ae:	8f 01       	movw	r16, r30
    30b0:	88 23       	and	r24, r24
    30b2:	11 f7       	brne	.-60     	; 0x3078 <LCD_vsend_string+0x1a>
    30b4:	8f e1       	ldi	r24, 0x1F	; 31
    30b6:	9e e4       	ldi	r25, 0x4E	; 78
    30b8:	01 97       	sbiw	r24, 0x01	; 1
    30ba:	f1 f7       	brne	.-4      	; 0x30b8 <LCD_vsend_string+0x5a>
    30bc:	00 c0       	rjmp	.+0      	; 0x30be <LCD_vsend_string+0x60>
    30be:	00 00       	nop
            LCD_vmove_cursor(1,1);
            count = 0;
        }
	}
	_delay_ms(10);
}
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	1f 91       	pop	r17
    30c6:	0f 91       	pop	r16
    30c8:	ff 90       	pop	r15
    30ca:	ef 90       	pop	r14
    30cc:	08 95       	ret

000030ce <LCD_vsend_number>:

/********* send_number_lcd ********/
void LCD_vsend_number (int num)
{
    30ce:	cf 93       	push	r28
    30d0:	df 93       	push	r29
    30d2:	cd b7       	in	r28, 0x3d	; 61
    30d4:	de b7       	in	r29, 0x3e	; 62
    30d6:	2a 97       	sbiw	r28, 0x0a	; 10
    30d8:	0f b6       	in	r0, 0x3f	; 63
    30da:	f8 94       	cli
    30dc:	de bf       	out	0x3e, r29	; 62
    30de:	0f be       	out	0x3f, r0	; 63
    30e0:	cd bf       	out	0x3d, r28	; 61
    char str[10];
    char * sign = (num < 0) ? "-" : "" ;
    30e2:	99 23       	and	r25, r25
    30e4:	1c f4       	brge	.+6      	; 0x30ec <LCD_vsend_number+0x1e>
    30e6:	47 e7       	ldi	r20, 0x77	; 119
    30e8:	50 e0       	ldi	r21, 0x00	; 0
    30ea:	02 c0       	rjmp	.+4      	; 0x30f0 <LCD_vsend_number+0x22>
    30ec:	49 e7       	ldi	r20, 0x79	; 121
    30ee:	50 e0       	ldi	r21, 0x00	; 0
    int val = (num < 0) ? -1*num : num ;

    sprintf(str , "%s%d" , sign , val);
    30f0:	2d b7       	in	r18, 0x3d	; 61
    30f2:	3e b7       	in	r19, 0x3e	; 62
    30f4:	28 50       	subi	r18, 0x08	; 8
    30f6:	30 40       	sbci	r19, 0x00	; 0
    30f8:	0f b6       	in	r0, 0x3f	; 63
    30fa:	f8 94       	cli
    30fc:	3e bf       	out	0x3e, r19	; 62
    30fe:	0f be       	out	0x3f, r0	; 63
    3100:	2d bf       	out	0x3d, r18	; 61
    3102:	ed b7       	in	r30, 0x3d	; 61
    3104:	fe b7       	in	r31, 0x3e	; 62
    3106:	31 96       	adiw	r30, 0x01	; 1
    3108:	9e 01       	movw	r18, r28
    310a:	2f 5f       	subi	r18, 0xFF	; 255
    310c:	3f 4f       	sbci	r19, 0xFF	; 255
    310e:	ad b7       	in	r26, 0x3d	; 61
    3110:	be b7       	in	r27, 0x3e	; 62
    3112:	12 96       	adiw	r26, 0x02	; 2
    3114:	3c 93       	st	X, r19
    3116:	2e 93       	st	-X, r18
    3118:	11 97       	sbiw	r26, 0x01	; 1
    311a:	2a e7       	ldi	r18, 0x7A	; 122
    311c:	30 e0       	ldi	r19, 0x00	; 0
    311e:	33 83       	std	Z+3, r19	; 0x03
    3120:	22 83       	std	Z+2, r18	; 0x02
    3122:	55 83       	std	Z+5, r21	; 0x05
    3124:	44 83       	std	Z+4, r20	; 0x04
/********* send_number_lcd ********/
void LCD_vsend_number (int num)
{
    char str[10];
    char * sign = (num < 0) ? "-" : "" ;
    int val = (num < 0) ? -1*num : num ;
    3126:	9c 01       	movw	r18, r24
    3128:	99 23       	and	r25, r25
    312a:	24 f4       	brge	.+8      	; 0x3134 <LCD_vsend_number+0x66>
    312c:	22 27       	eor	r18, r18
    312e:	33 27       	eor	r19, r19
    3130:	28 1b       	sub	r18, r24
    3132:	39 0b       	sbc	r19, r25

    sprintf(str , "%s%d" , sign , val);
    3134:	37 83       	std	Z+7, r19	; 0x07
    3136:	26 83       	std	Z+6, r18	; 0x06
    3138:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <sprintf>
    LCD_vsend_string(str);
    313c:	2d b7       	in	r18, 0x3d	; 61
    313e:	3e b7       	in	r19, 0x3e	; 62
    3140:	28 5f       	subi	r18, 0xF8	; 248
    3142:	3f 4f       	sbci	r19, 0xFF	; 255
    3144:	0f b6       	in	r0, 0x3f	; 63
    3146:	f8 94       	cli
    3148:	3e bf       	out	0x3e, r19	; 62
    314a:	0f be       	out	0x3f, r0	; 63
    314c:	2d bf       	out	0x3d, r18	; 61
    314e:	ce 01       	movw	r24, r28
    3150:	01 96       	adiw	r24, 0x01	; 1
    3152:	0e 94 2f 18 	call	0x305e	; 0x305e <LCD_vsend_string>
    3156:	8f e1       	ldi	r24, 0x1F	; 31
    3158:	9e e4       	ldi	r25, 0x4E	; 78
    315a:	01 97       	sbiw	r24, 0x01	; 1
    315c:	f1 f7       	brne	.-4      	; 0x315a <LCD_vsend_number+0x8c>
    315e:	00 c0       	rjmp	.+0      	; 0x3160 <LCD_vsend_number+0x92>
    3160:	00 00       	nop
    _delay_ms(10);
}
    3162:	2a 96       	adiw	r28, 0x0a	; 10
    3164:	0f b6       	in	r0, 0x3f	; 63
    3166:	f8 94       	cli
    3168:	de bf       	out	0x3e, r29	; 62
    316a:	0f be       	out	0x3f, r0	; 63
    316c:	cd bf       	out	0x3d, r28	; 61
    316e:	df 91       	pop	r29
    3170:	cf 91       	pop	r28
    3172:	08 95       	ret

00003174 <LCD_vsend_real_number>:
/********* send_real_num_lcd ********/
void LCD_vsend_real_number (float num)
{
    3174:	af 92       	push	r10
    3176:	bf 92       	push	r11
    3178:	cf 92       	push	r12
    317a:	df 92       	push	r13
    317c:	ef 92       	push	r14
    317e:	ff 92       	push	r15
    3180:	0f 93       	push	r16
    3182:	1f 93       	push	r17
    3184:	cf 93       	push	r28
    3186:	df 93       	push	r29
    3188:	cd b7       	in	r28, 0x3d	; 61
    318a:	de b7       	in	r29, 0x3e	; 62
    318c:	2a 97       	sbiw	r28, 0x0a	; 10
    318e:	0f b6       	in	r0, 0x3f	; 63
    3190:	f8 94       	cli
    3192:	de bf       	out	0x3e, r29	; 62
    3194:	0f be       	out	0x3f, r0	; 63
    3196:	cd bf       	out	0x3d, r28	; 61
    3198:	6b 01       	movw	r12, r22
    319a:	7c 01       	movw	r14, r24
    char str[10];

    char *sign = (num < 0) ? "-" : "" ;
    319c:	20 e0       	ldi	r18, 0x00	; 0
    319e:	30 e0       	ldi	r19, 0x00	; 0
    31a0:	a9 01       	movw	r20, r18
    31a2:	0e 94 19 1a 	call	0x3432	; 0x3432 <__cmpsf2>
    31a6:	88 23       	and	r24, r24
    31a8:	0c f0       	brlt	.+2      	; 0x31ac <LCD_vsend_real_number+0x38>
    31aa:	64 c0       	rjmp	.+200    	; 0x3274 <LCD_vsend_real_number+0x100>
    int real_val = (num < 0) ? -1*num : num ;
    31ac:	f7 fa       	bst	r15, 7
    31ae:	f0 94       	com	r15
    31b0:	f7 f8       	bld	r15, 7
    31b2:	f0 94       	com	r15
    31b4:	c7 01       	movw	r24, r14
    31b6:	b6 01       	movw	r22, r12
    31b8:	0e 94 1d 1a 	call	0x343a	; 0x343a <__fixsfsi>
    31bc:	dc 01       	movw	r26, r24
    31be:	cb 01       	movw	r24, r22
    31c0:	5c 01       	movw	r10, r24
    int float_val = (num < 0) ? ((-num - real_val )*100) : ((num - real_val )*100);
    31c2:	b5 01       	movw	r22, r10
    31c4:	88 27       	eor	r24, r24
    31c6:	77 fd       	sbrc	r23, 7
    31c8:	80 95       	com	r24
    31ca:	98 2f       	mov	r25, r24
    31cc:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <__floatsisf>
    31d0:	9b 01       	movw	r18, r22
    31d2:	ac 01       	movw	r20, r24
    31d4:	c7 01       	movw	r24, r14
    31d6:	b6 01       	movw	r22, r12
    31d8:	0e 94 b4 19 	call	0x3368	; 0x3368 <__subsf3>
    31dc:	20 e0       	ldi	r18, 0x00	; 0
    31de:	30 e0       	ldi	r19, 0x00	; 0
    31e0:	48 ec       	ldi	r20, 0xC8	; 200
    31e2:	52 e4       	ldi	r21, 0x42	; 66
    31e4:	0e 94 00 1b 	call	0x3600	; 0x3600 <__mulsf3>
    31e8:	0e 94 1d 1a 	call	0x343a	; 0x343a <__fixsfsi>
/********* send_real_num_lcd ********/
void LCD_vsend_real_number (float num)
{
    char str[10];

    char *sign = (num < 0) ? "-" : "" ;
    31ec:	27 e7       	ldi	r18, 0x77	; 119
    31ee:	30 e0       	ldi	r19, 0x00	; 0
    int real_val = (num < 0) ? -1*num : num ;
    int float_val = (num < 0) ? ((-num - real_val )*100) : ((num - real_val )*100);

    sprintf(str , "%s%d.%.2d" , sign , real_val , float_val);
    31f0:	8d b7       	in	r24, 0x3d	; 61
    31f2:	9e b7       	in	r25, 0x3e	; 62
    31f4:	0a 97       	sbiw	r24, 0x0a	; 10
    31f6:	0f b6       	in	r0, 0x3f	; 63
    31f8:	f8 94       	cli
    31fa:	9e bf       	out	0x3e, r25	; 62
    31fc:	0f be       	out	0x3f, r0	; 63
    31fe:	8d bf       	out	0x3d, r24	; 61
    3200:	ed b7       	in	r30, 0x3d	; 61
    3202:	fe b7       	in	r31, 0x3e	; 62
    3204:	31 96       	adiw	r30, 0x01	; 1
    3206:	8e 01       	movw	r16, r28
    3208:	0f 5f       	subi	r16, 0xFF	; 255
    320a:	1f 4f       	sbci	r17, 0xFF	; 255
    320c:	ad b7       	in	r26, 0x3d	; 61
    320e:	be b7       	in	r27, 0x3e	; 62
    3210:	12 96       	adiw	r26, 0x02	; 2
    3212:	1c 93       	st	X, r17
    3214:	0e 93       	st	-X, r16
    3216:	11 97       	sbiw	r26, 0x01	; 1
    3218:	8f e7       	ldi	r24, 0x7F	; 127
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	93 83       	std	Z+3, r25	; 0x03
    321e:	82 83       	std	Z+2, r24	; 0x02
    3220:	35 83       	std	Z+5, r19	; 0x05
    3222:	24 83       	std	Z+4, r18	; 0x04
    3224:	b7 82       	std	Z+7, r11	; 0x07
    3226:	a6 82       	std	Z+6, r10	; 0x06
    3228:	71 87       	std	Z+9, r23	; 0x09
    322a:	60 87       	std	Z+8, r22	; 0x08
    322c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <sprintf>
    LCD_vsend_string(str);
    3230:	8d b7       	in	r24, 0x3d	; 61
    3232:	9e b7       	in	r25, 0x3e	; 62
    3234:	0a 96       	adiw	r24, 0x0a	; 10
    3236:	0f b6       	in	r0, 0x3f	; 63
    3238:	f8 94       	cli
    323a:	9e bf       	out	0x3e, r25	; 62
    323c:	0f be       	out	0x3f, r0	; 63
    323e:	8d bf       	out	0x3d, r24	; 61
    3240:	c8 01       	movw	r24, r16
    3242:	0e 94 2f 18 	call	0x305e	; 0x305e <LCD_vsend_string>
    3246:	af e1       	ldi	r26, 0x1F	; 31
    3248:	be e4       	ldi	r27, 0x4E	; 78
    324a:	11 97       	sbiw	r26, 0x01	; 1
    324c:	f1 f7       	brne	.-4      	; 0x324a <LCD_vsend_real_number+0xd6>
    324e:	00 c0       	rjmp	.+0      	; 0x3250 <LCD_vsend_real_number+0xdc>
    3250:	00 00       	nop
    _delay_ms(10);
}
    3252:	2a 96       	adiw	r28, 0x0a	; 10
    3254:	0f b6       	in	r0, 0x3f	; 63
    3256:	f8 94       	cli
    3258:	de bf       	out	0x3e, r29	; 62
    325a:	0f be       	out	0x3f, r0	; 63
    325c:	cd bf       	out	0x3d, r28	; 61
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	1f 91       	pop	r17
    3264:	0f 91       	pop	r16
    3266:	ff 90       	pop	r15
    3268:	ef 90       	pop	r14
    326a:	df 90       	pop	r13
    326c:	cf 90       	pop	r12
    326e:	bf 90       	pop	r11
    3270:	af 90       	pop	r10
    3272:	08 95       	ret
void LCD_vsend_real_number (float num)
{
    char str[10];

    char *sign = (num < 0) ? "-" : "" ;
    int real_val = (num < 0) ? -1*num : num ;
    3274:	c7 01       	movw	r24, r14
    3276:	b6 01       	movw	r22, r12
    3278:	0e 94 1d 1a 	call	0x343a	; 0x343a <__fixsfsi>
    327c:	dc 01       	movw	r26, r24
    327e:	cb 01       	movw	r24, r22
    3280:	5c 01       	movw	r10, r24
    int float_val = (num < 0) ? ((-num - real_val )*100) : ((num - real_val )*100);
    3282:	b5 01       	movw	r22, r10
    3284:	88 27       	eor	r24, r24
    3286:	77 fd       	sbrc	r23, 7
    3288:	80 95       	com	r24
    328a:	98 2f       	mov	r25, r24
    328c:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <__floatsisf>
    3290:	9b 01       	movw	r18, r22
    3292:	ac 01       	movw	r20, r24
    3294:	c7 01       	movw	r24, r14
    3296:	b6 01       	movw	r22, r12
    3298:	0e 94 b4 19 	call	0x3368	; 0x3368 <__subsf3>
    329c:	20 e0       	ldi	r18, 0x00	; 0
    329e:	30 e0       	ldi	r19, 0x00	; 0
    32a0:	48 ec       	ldi	r20, 0xC8	; 200
    32a2:	52 e4       	ldi	r21, 0x42	; 66
    32a4:	0e 94 00 1b 	call	0x3600	; 0x3600 <__mulsf3>
    32a8:	0e 94 1d 1a 	call	0x343a	; 0x343a <__fixsfsi>
/********* send_real_num_lcd ********/
void LCD_vsend_real_number (float num)
{
    char str[10];

    char *sign = (num < 0) ? "-" : "" ;
    32ac:	29 e7       	ldi	r18, 0x79	; 121
    32ae:	30 e0       	ldi	r19, 0x00	; 0
    32b0:	9f cf       	rjmp	.-194    	; 0x31f0 <LCD_vsend_real_number+0x7c>

000032b2 <LCD>:
    }
}

//TASK_2
void LCD(void *pv)
{
    32b2:	cf 93       	push	r28
    32b4:	df 93       	push	r29
    32b6:	0f 92       	push	r0
    32b8:	cd b7       	in	r28, 0x3d	; 61
    32ba:	de b7       	in	r29, 0x3e	; 62
    uint8_t Display_Data;
    while(1)
    {
        // wait for 1s in wait_state if queue empty
        xQueueReceive(my_queue,&Display_Data,1000);
    32bc:	80 91 54 04 	lds	r24, 0x0454
    32c0:	90 91 55 04 	lds	r25, 0x0455
    32c4:	be 01       	movw	r22, r28
    32c6:	6f 5f       	subi	r22, 0xFF	; 255
    32c8:	7f 4f       	sbci	r23, 0xFF	; 255
    32ca:	48 ee       	ldi	r20, 0xE8	; 232
    32cc:	53 e0       	ldi	r21, 0x03	; 3
    32ce:	20 e0       	ldi	r18, 0x00	; 0
    32d0:	0e 94 93 0a 	call	0x1526	; 0x1526 <xQueueGenericReceive>
        LCD_vsend_number(Display_Data);
    32d4:	89 81       	ldd	r24, Y+1	; 0x01
    32d6:	90 e0       	ldi	r25, 0x00	; 0
    32d8:	0e 94 67 18 	call	0x30ce	; 0x30ce <LCD_vsend_number>
    32dc:	ef cf       	rjmp	.-34     	; 0x32bc <LCD+0xa>

000032de <keypad>:
    }
}

//TASK_1
void keypad(void *pv)
{
    32de:	cf 93       	push	r28
    32e0:	df 93       	push	r29
    32e2:	0f 92       	push	r0
    32e4:	cd b7       	in	r28, 0x3d	; 61
    32e6:	de b7       	in	r29, 0x3e	; 62
    uint8_t Data_Keyapd;
    while(1)
    {
        // Read From Keypad
        Data_Keyapd=Keypad_u8read();
    32e8:	0e 94 84 16 	call	0x2d08	; 0x2d08 <Keypad_u8read>
    32ec:	89 83       	std	Y+1, r24	; 0x01
        if(Data_Keyapd!=NOT_PRESSED)
    32ee:	8f 3f       	cpi	r24, 0xFF	; 255
    32f0:	d9 f3       	breq	.-10     	; 0x32e8 <keypad+0xa>
        {
            // wait for 1s in wait_state if queue full
            xQueueSend(my_queue,&Data_Keyapd,1000);
    32f2:	80 91 54 04 	lds	r24, 0x0454
    32f6:	90 91 55 04 	lds	r25, 0x0455
    32fa:	be 01       	movw	r22, r28
    32fc:	6f 5f       	subi	r22, 0xFF	; 255
    32fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3300:	48 ee       	ldi	r20, 0xE8	; 232
    3302:	53 e0       	ldi	r21, 0x03	; 3
    3304:	20 e0       	ldi	r18, 0x00	; 0
    3306:	0e 94 70 09 	call	0x12e0	; 0x12e0 <xQueueGenericSend>
            // exit from run_state to wait_state until .3s
            vTaskDelay(300);
    330a:	8c e2       	ldi	r24, 0x2C	; 44
    330c:	91 e0       	ldi	r25, 0x01	; 1
    330e:	0e 94 32 11 	call	0x2264	; 0x2264 <vTaskDelay>
    3312:	ea cf       	rjmp	.-44     	; 0x32e8 <keypad+0xa>

00003314 <main>:
void LCD(void *pv);

QueueHandle_t my_queue ; //Void Pointer
int main(void)
{
    Keypad_vinit();
    3314:	0e 94 47 16 	call	0x2c8e	; 0x2c8e <Keypad_vinit>
    LCD_vinit();
    3318:	0e 94 40 17 	call	0x2e80	; 0x2e80 <LCD_vinit>

    // Create Tasks
    xTaskCreate(keypad,"Handle_1",100,NULL,2,NULL); // High Priority Task
    331c:	8f e6       	ldi	r24, 0x6F	; 111
    331e:	99 e1       	ldi	r25, 0x19	; 25
    3320:	69 e8       	ldi	r22, 0x89	; 137
    3322:	70 e0       	ldi	r23, 0x00	; 0
    3324:	44 e6       	ldi	r20, 0x64	; 100
    3326:	50 e0       	ldi	r21, 0x00	; 0
    3328:	20 e0       	ldi	r18, 0x00	; 0
    332a:	30 e0       	ldi	r19, 0x00	; 0
    332c:	02 e0       	ldi	r16, 0x02	; 2
    332e:	ee 24       	eor	r14, r14
    3330:	ff 24       	eor	r15, r15
    3332:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <xTaskCreate>
    xTaskCreate(LCD,"Handle_2",100,NULL,1,NULL);    // Low Priority  Task
    3336:	89 e5       	ldi	r24, 0x59	; 89
    3338:	99 e1       	ldi	r25, 0x19	; 25
    333a:	62 e9       	ldi	r22, 0x92	; 146
    333c:	70 e0       	ldi	r23, 0x00	; 0
    333e:	44 e6       	ldi	r20, 0x64	; 100
    3340:	50 e0       	ldi	r21, 0x00	; 0
    3342:	20 e0       	ldi	r18, 0x00	; 0
    3344:	30 e0       	ldi	r19, 0x00	; 0
    3346:	01 e0       	ldi	r16, 0x01	; 1
    3348:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <xTaskCreate>

    // Create Queue With 5_Item (5Byte)
    my_queue=xQueueCreate(5,sizeof(uint8_t));
    334c:	85 e0       	ldi	r24, 0x05	; 5
    334e:	61 e0       	ldi	r22, 0x01	; 1
    3350:	40 e0       	ldi	r20, 0x00	; 0
    3352:	0e 94 47 09 	call	0x128e	; 0x128e <xQueueGenericCreate>
    3356:	90 93 55 04 	sts	0x0455, r25
    335a:	80 93 54 04 	sts	0x0454, r24

    //Start scheduler
    vTaskStartScheduler();
    335e:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vTaskStartScheduler>
    
    while(1)
    {
        // Will Ignore Clear Screen As Run in High Priority For Tasks
        LCD_vClearScreen();
    3362:	0e 94 25 18 	call	0x304a	; 0x304a <LCD_vClearScreen>
    3366:	fd cf       	rjmp	.-6      	; 0x3362 <main+0x4e>

00003368 <__subsf3>:
    3368:	50 58       	subi	r21, 0x80	; 128

0000336a <__addsf3>:
    336a:	bb 27       	eor	r27, r27
    336c:	aa 27       	eor	r26, r26
    336e:	0e d0       	rcall	.+28     	; 0x338c <__addsf3x>
    3370:	0d c1       	rjmp	.+538    	; 0x358c <__fp_round>
    3372:	fe d0       	rcall	.+508    	; 0x3570 <__fp_pscA>
    3374:	30 f0       	brcs	.+12     	; 0x3382 <__addsf3+0x18>
    3376:	03 d1       	rcall	.+518    	; 0x357e <__fp_pscB>
    3378:	20 f0       	brcs	.+8      	; 0x3382 <__addsf3+0x18>
    337a:	31 f4       	brne	.+12     	; 0x3388 <__addsf3+0x1e>
    337c:	9f 3f       	cpi	r25, 0xFF	; 255
    337e:	11 f4       	brne	.+4      	; 0x3384 <__addsf3+0x1a>
    3380:	1e f4       	brtc	.+6      	; 0x3388 <__addsf3+0x1e>
    3382:	f3 c0       	rjmp	.+486    	; 0x356a <__fp_nan>
    3384:	0e f4       	brtc	.+2      	; 0x3388 <__addsf3+0x1e>
    3386:	e0 95       	com	r30
    3388:	e7 fb       	bst	r30, 7
    338a:	e9 c0       	rjmp	.+466    	; 0x355e <__fp_inf>

0000338c <__addsf3x>:
    338c:	e9 2f       	mov	r30, r25
    338e:	0f d1       	rcall	.+542    	; 0x35ae <__fp_split3>
    3390:	80 f3       	brcs	.-32     	; 0x3372 <__addsf3+0x8>
    3392:	ba 17       	cp	r27, r26
    3394:	62 07       	cpc	r22, r18
    3396:	73 07       	cpc	r23, r19
    3398:	84 07       	cpc	r24, r20
    339a:	95 07       	cpc	r25, r21
    339c:	18 f0       	brcs	.+6      	; 0x33a4 <__addsf3x+0x18>
    339e:	71 f4       	brne	.+28     	; 0x33bc <__addsf3x+0x30>
    33a0:	9e f5       	brtc	.+102    	; 0x3408 <__addsf3x+0x7c>
    33a2:	27 c1       	rjmp	.+590    	; 0x35f2 <__fp_zero>
    33a4:	0e f4       	brtc	.+2      	; 0x33a8 <__addsf3x+0x1c>
    33a6:	e0 95       	com	r30
    33a8:	0b 2e       	mov	r0, r27
    33aa:	ba 2f       	mov	r27, r26
    33ac:	a0 2d       	mov	r26, r0
    33ae:	0b 01       	movw	r0, r22
    33b0:	b9 01       	movw	r22, r18
    33b2:	90 01       	movw	r18, r0
    33b4:	0c 01       	movw	r0, r24
    33b6:	ca 01       	movw	r24, r20
    33b8:	a0 01       	movw	r20, r0
    33ba:	11 24       	eor	r1, r1
    33bc:	ff 27       	eor	r31, r31
    33be:	59 1b       	sub	r21, r25
    33c0:	99 f0       	breq	.+38     	; 0x33e8 <__addsf3x+0x5c>
    33c2:	59 3f       	cpi	r21, 0xF9	; 249
    33c4:	50 f4       	brcc	.+20     	; 0x33da <__addsf3x+0x4e>
    33c6:	50 3e       	cpi	r21, 0xE0	; 224
    33c8:	68 f1       	brcs	.+90     	; 0x3424 <__addsf3x+0x98>
    33ca:	1a 16       	cp	r1, r26
    33cc:	f0 40       	sbci	r31, 0x00	; 0
    33ce:	a2 2f       	mov	r26, r18
    33d0:	23 2f       	mov	r18, r19
    33d2:	34 2f       	mov	r19, r20
    33d4:	44 27       	eor	r20, r20
    33d6:	58 5f       	subi	r21, 0xF8	; 248
    33d8:	f3 cf       	rjmp	.-26     	; 0x33c0 <__addsf3x+0x34>
    33da:	46 95       	lsr	r20
    33dc:	37 95       	ror	r19
    33de:	27 95       	ror	r18
    33e0:	a7 95       	ror	r26
    33e2:	f0 40       	sbci	r31, 0x00	; 0
    33e4:	53 95       	inc	r21
    33e6:	c9 f7       	brne	.-14     	; 0x33da <__addsf3x+0x4e>
    33e8:	7e f4       	brtc	.+30     	; 0x3408 <__addsf3x+0x7c>
    33ea:	1f 16       	cp	r1, r31
    33ec:	ba 0b       	sbc	r27, r26
    33ee:	62 0b       	sbc	r22, r18
    33f0:	73 0b       	sbc	r23, r19
    33f2:	84 0b       	sbc	r24, r20
    33f4:	ba f0       	brmi	.+46     	; 0x3424 <__addsf3x+0x98>
    33f6:	91 50       	subi	r25, 0x01	; 1
    33f8:	a1 f0       	breq	.+40     	; 0x3422 <__addsf3x+0x96>
    33fa:	ff 0f       	add	r31, r31
    33fc:	bb 1f       	adc	r27, r27
    33fe:	66 1f       	adc	r22, r22
    3400:	77 1f       	adc	r23, r23
    3402:	88 1f       	adc	r24, r24
    3404:	c2 f7       	brpl	.-16     	; 0x33f6 <__addsf3x+0x6a>
    3406:	0e c0       	rjmp	.+28     	; 0x3424 <__addsf3x+0x98>
    3408:	ba 0f       	add	r27, r26
    340a:	62 1f       	adc	r22, r18
    340c:	73 1f       	adc	r23, r19
    340e:	84 1f       	adc	r24, r20
    3410:	48 f4       	brcc	.+18     	; 0x3424 <__addsf3x+0x98>
    3412:	87 95       	ror	r24
    3414:	77 95       	ror	r23
    3416:	67 95       	ror	r22
    3418:	b7 95       	ror	r27
    341a:	f7 95       	ror	r31
    341c:	9e 3f       	cpi	r25, 0xFE	; 254
    341e:	08 f0       	brcs	.+2      	; 0x3422 <__addsf3x+0x96>
    3420:	b3 cf       	rjmp	.-154    	; 0x3388 <__addsf3+0x1e>
    3422:	93 95       	inc	r25
    3424:	88 0f       	add	r24, r24
    3426:	08 f0       	brcs	.+2      	; 0x342a <__addsf3x+0x9e>
    3428:	99 27       	eor	r25, r25
    342a:	ee 0f       	add	r30, r30
    342c:	97 95       	ror	r25
    342e:	87 95       	ror	r24
    3430:	08 95       	ret

00003432 <__cmpsf2>:
    3432:	71 d0       	rcall	.+226    	; 0x3516 <__fp_cmp>
    3434:	08 f4       	brcc	.+2      	; 0x3438 <__cmpsf2+0x6>
    3436:	81 e0       	ldi	r24, 0x01	; 1
    3438:	08 95       	ret

0000343a <__fixsfsi>:
    343a:	04 d0       	rcall	.+8      	; 0x3444 <__fixunssfsi>
    343c:	68 94       	set
    343e:	b1 11       	cpse	r27, r1
    3440:	d9 c0       	rjmp	.+434    	; 0x35f4 <__fp_szero>
    3442:	08 95       	ret

00003444 <__fixunssfsi>:
    3444:	bc d0       	rcall	.+376    	; 0x35be <__fp_splitA>
    3446:	88 f0       	brcs	.+34     	; 0x346a <__fixunssfsi+0x26>
    3448:	9f 57       	subi	r25, 0x7F	; 127
    344a:	90 f0       	brcs	.+36     	; 0x3470 <__fixunssfsi+0x2c>
    344c:	b9 2f       	mov	r27, r25
    344e:	99 27       	eor	r25, r25
    3450:	b7 51       	subi	r27, 0x17	; 23
    3452:	a0 f0       	brcs	.+40     	; 0x347c <__fixunssfsi+0x38>
    3454:	d1 f0       	breq	.+52     	; 0x348a <__fixunssfsi+0x46>
    3456:	66 0f       	add	r22, r22
    3458:	77 1f       	adc	r23, r23
    345a:	88 1f       	adc	r24, r24
    345c:	99 1f       	adc	r25, r25
    345e:	1a f0       	brmi	.+6      	; 0x3466 <__fixunssfsi+0x22>
    3460:	ba 95       	dec	r27
    3462:	c9 f7       	brne	.-14     	; 0x3456 <__fixunssfsi+0x12>
    3464:	12 c0       	rjmp	.+36     	; 0x348a <__fixunssfsi+0x46>
    3466:	b1 30       	cpi	r27, 0x01	; 1
    3468:	81 f0       	breq	.+32     	; 0x348a <__fixunssfsi+0x46>
    346a:	c3 d0       	rcall	.+390    	; 0x35f2 <__fp_zero>
    346c:	b1 e0       	ldi	r27, 0x01	; 1
    346e:	08 95       	ret
    3470:	c0 c0       	rjmp	.+384    	; 0x35f2 <__fp_zero>
    3472:	67 2f       	mov	r22, r23
    3474:	78 2f       	mov	r23, r24
    3476:	88 27       	eor	r24, r24
    3478:	b8 5f       	subi	r27, 0xF8	; 248
    347a:	39 f0       	breq	.+14     	; 0x348a <__fixunssfsi+0x46>
    347c:	b9 3f       	cpi	r27, 0xF9	; 249
    347e:	cc f3       	brlt	.-14     	; 0x3472 <__fixunssfsi+0x2e>
    3480:	86 95       	lsr	r24
    3482:	77 95       	ror	r23
    3484:	67 95       	ror	r22
    3486:	b3 95       	inc	r27
    3488:	d9 f7       	brne	.-10     	; 0x3480 <__fixunssfsi+0x3c>
    348a:	3e f4       	brtc	.+14     	; 0x349a <__fixunssfsi+0x56>
    348c:	90 95       	com	r25
    348e:	80 95       	com	r24
    3490:	70 95       	com	r23
    3492:	61 95       	neg	r22
    3494:	7f 4f       	sbci	r23, 0xFF	; 255
    3496:	8f 4f       	sbci	r24, 0xFF	; 255
    3498:	9f 4f       	sbci	r25, 0xFF	; 255
    349a:	08 95       	ret

0000349c <__floatunsisf>:
    349c:	e8 94       	clt
    349e:	09 c0       	rjmp	.+18     	; 0x34b2 <__floatsisf+0x12>

000034a0 <__floatsisf>:
    34a0:	97 fb       	bst	r25, 7
    34a2:	3e f4       	brtc	.+14     	; 0x34b2 <__floatsisf+0x12>
    34a4:	90 95       	com	r25
    34a6:	80 95       	com	r24
    34a8:	70 95       	com	r23
    34aa:	61 95       	neg	r22
    34ac:	7f 4f       	sbci	r23, 0xFF	; 255
    34ae:	8f 4f       	sbci	r24, 0xFF	; 255
    34b0:	9f 4f       	sbci	r25, 0xFF	; 255
    34b2:	99 23       	and	r25, r25
    34b4:	a9 f0       	breq	.+42     	; 0x34e0 <__floatsisf+0x40>
    34b6:	f9 2f       	mov	r31, r25
    34b8:	96 e9       	ldi	r25, 0x96	; 150
    34ba:	bb 27       	eor	r27, r27
    34bc:	93 95       	inc	r25
    34be:	f6 95       	lsr	r31
    34c0:	87 95       	ror	r24
    34c2:	77 95       	ror	r23
    34c4:	67 95       	ror	r22
    34c6:	b7 95       	ror	r27
    34c8:	f1 11       	cpse	r31, r1
    34ca:	f8 cf       	rjmp	.-16     	; 0x34bc <__floatsisf+0x1c>
    34cc:	fa f4       	brpl	.+62     	; 0x350c <__floatsisf+0x6c>
    34ce:	bb 0f       	add	r27, r27
    34d0:	11 f4       	brne	.+4      	; 0x34d6 <__floatsisf+0x36>
    34d2:	60 ff       	sbrs	r22, 0
    34d4:	1b c0       	rjmp	.+54     	; 0x350c <__floatsisf+0x6c>
    34d6:	6f 5f       	subi	r22, 0xFF	; 255
    34d8:	7f 4f       	sbci	r23, 0xFF	; 255
    34da:	8f 4f       	sbci	r24, 0xFF	; 255
    34dc:	9f 4f       	sbci	r25, 0xFF	; 255
    34de:	16 c0       	rjmp	.+44     	; 0x350c <__floatsisf+0x6c>
    34e0:	88 23       	and	r24, r24
    34e2:	11 f0       	breq	.+4      	; 0x34e8 <__floatsisf+0x48>
    34e4:	96 e9       	ldi	r25, 0x96	; 150
    34e6:	11 c0       	rjmp	.+34     	; 0x350a <__floatsisf+0x6a>
    34e8:	77 23       	and	r23, r23
    34ea:	21 f0       	breq	.+8      	; 0x34f4 <__floatsisf+0x54>
    34ec:	9e e8       	ldi	r25, 0x8E	; 142
    34ee:	87 2f       	mov	r24, r23
    34f0:	76 2f       	mov	r23, r22
    34f2:	05 c0       	rjmp	.+10     	; 0x34fe <__floatsisf+0x5e>
    34f4:	66 23       	and	r22, r22
    34f6:	71 f0       	breq	.+28     	; 0x3514 <__floatsisf+0x74>
    34f8:	96 e8       	ldi	r25, 0x86	; 134
    34fa:	86 2f       	mov	r24, r22
    34fc:	70 e0       	ldi	r23, 0x00	; 0
    34fe:	60 e0       	ldi	r22, 0x00	; 0
    3500:	2a f0       	brmi	.+10     	; 0x350c <__floatsisf+0x6c>
    3502:	9a 95       	dec	r25
    3504:	66 0f       	add	r22, r22
    3506:	77 1f       	adc	r23, r23
    3508:	88 1f       	adc	r24, r24
    350a:	da f7       	brpl	.-10     	; 0x3502 <__floatsisf+0x62>
    350c:	88 0f       	add	r24, r24
    350e:	96 95       	lsr	r25
    3510:	87 95       	ror	r24
    3512:	97 f9       	bld	r25, 7
    3514:	08 95       	ret

00003516 <__fp_cmp>:
    3516:	99 0f       	add	r25, r25
    3518:	00 08       	sbc	r0, r0
    351a:	55 0f       	add	r21, r21
    351c:	aa 0b       	sbc	r26, r26
    351e:	e0 e8       	ldi	r30, 0x80	; 128
    3520:	fe ef       	ldi	r31, 0xFE	; 254
    3522:	16 16       	cp	r1, r22
    3524:	17 06       	cpc	r1, r23
    3526:	e8 07       	cpc	r30, r24
    3528:	f9 07       	cpc	r31, r25
    352a:	c0 f0       	brcs	.+48     	; 0x355c <__fp_cmp+0x46>
    352c:	12 16       	cp	r1, r18
    352e:	13 06       	cpc	r1, r19
    3530:	e4 07       	cpc	r30, r20
    3532:	f5 07       	cpc	r31, r21
    3534:	98 f0       	brcs	.+38     	; 0x355c <__fp_cmp+0x46>
    3536:	62 1b       	sub	r22, r18
    3538:	73 0b       	sbc	r23, r19
    353a:	84 0b       	sbc	r24, r20
    353c:	95 0b       	sbc	r25, r21
    353e:	39 f4       	brne	.+14     	; 0x354e <__fp_cmp+0x38>
    3540:	0a 26       	eor	r0, r26
    3542:	61 f0       	breq	.+24     	; 0x355c <__fp_cmp+0x46>
    3544:	23 2b       	or	r18, r19
    3546:	24 2b       	or	r18, r20
    3548:	25 2b       	or	r18, r21
    354a:	21 f4       	brne	.+8      	; 0x3554 <__fp_cmp+0x3e>
    354c:	08 95       	ret
    354e:	0a 26       	eor	r0, r26
    3550:	09 f4       	brne	.+2      	; 0x3554 <__fp_cmp+0x3e>
    3552:	a1 40       	sbci	r26, 0x01	; 1
    3554:	a6 95       	lsr	r26
    3556:	8f ef       	ldi	r24, 0xFF	; 255
    3558:	81 1d       	adc	r24, r1
    355a:	81 1d       	adc	r24, r1
    355c:	08 95       	ret

0000355e <__fp_inf>:
    355e:	97 f9       	bld	r25, 7
    3560:	9f 67       	ori	r25, 0x7F	; 127
    3562:	80 e8       	ldi	r24, 0x80	; 128
    3564:	70 e0       	ldi	r23, 0x00	; 0
    3566:	60 e0       	ldi	r22, 0x00	; 0
    3568:	08 95       	ret

0000356a <__fp_nan>:
    356a:	9f ef       	ldi	r25, 0xFF	; 255
    356c:	80 ec       	ldi	r24, 0xC0	; 192
    356e:	08 95       	ret

00003570 <__fp_pscA>:
    3570:	00 24       	eor	r0, r0
    3572:	0a 94       	dec	r0
    3574:	16 16       	cp	r1, r22
    3576:	17 06       	cpc	r1, r23
    3578:	18 06       	cpc	r1, r24
    357a:	09 06       	cpc	r0, r25
    357c:	08 95       	ret

0000357e <__fp_pscB>:
    357e:	00 24       	eor	r0, r0
    3580:	0a 94       	dec	r0
    3582:	12 16       	cp	r1, r18
    3584:	13 06       	cpc	r1, r19
    3586:	14 06       	cpc	r1, r20
    3588:	05 06       	cpc	r0, r21
    358a:	08 95       	ret

0000358c <__fp_round>:
    358c:	09 2e       	mov	r0, r25
    358e:	03 94       	inc	r0
    3590:	00 0c       	add	r0, r0
    3592:	11 f4       	brne	.+4      	; 0x3598 <__fp_round+0xc>
    3594:	88 23       	and	r24, r24
    3596:	52 f0       	brmi	.+20     	; 0x35ac <__fp_round+0x20>
    3598:	bb 0f       	add	r27, r27
    359a:	40 f4       	brcc	.+16     	; 0x35ac <__fp_round+0x20>
    359c:	bf 2b       	or	r27, r31
    359e:	11 f4       	brne	.+4      	; 0x35a4 <__fp_round+0x18>
    35a0:	60 ff       	sbrs	r22, 0
    35a2:	04 c0       	rjmp	.+8      	; 0x35ac <__fp_round+0x20>
    35a4:	6f 5f       	subi	r22, 0xFF	; 255
    35a6:	7f 4f       	sbci	r23, 0xFF	; 255
    35a8:	8f 4f       	sbci	r24, 0xFF	; 255
    35aa:	9f 4f       	sbci	r25, 0xFF	; 255
    35ac:	08 95       	ret

000035ae <__fp_split3>:
    35ae:	57 fd       	sbrc	r21, 7
    35b0:	90 58       	subi	r25, 0x80	; 128
    35b2:	44 0f       	add	r20, r20
    35b4:	55 1f       	adc	r21, r21
    35b6:	59 f0       	breq	.+22     	; 0x35ce <__fp_splitA+0x10>
    35b8:	5f 3f       	cpi	r21, 0xFF	; 255
    35ba:	71 f0       	breq	.+28     	; 0x35d8 <__fp_splitA+0x1a>
    35bc:	47 95       	ror	r20

000035be <__fp_splitA>:
    35be:	88 0f       	add	r24, r24
    35c0:	97 fb       	bst	r25, 7
    35c2:	99 1f       	adc	r25, r25
    35c4:	61 f0       	breq	.+24     	; 0x35de <__fp_splitA+0x20>
    35c6:	9f 3f       	cpi	r25, 0xFF	; 255
    35c8:	79 f0       	breq	.+30     	; 0x35e8 <__fp_splitA+0x2a>
    35ca:	87 95       	ror	r24
    35cc:	08 95       	ret
    35ce:	12 16       	cp	r1, r18
    35d0:	13 06       	cpc	r1, r19
    35d2:	14 06       	cpc	r1, r20
    35d4:	55 1f       	adc	r21, r21
    35d6:	f2 cf       	rjmp	.-28     	; 0x35bc <__fp_split3+0xe>
    35d8:	46 95       	lsr	r20
    35da:	f1 df       	rcall	.-30     	; 0x35be <__fp_splitA>
    35dc:	08 c0       	rjmp	.+16     	; 0x35ee <__fp_splitA+0x30>
    35de:	16 16       	cp	r1, r22
    35e0:	17 06       	cpc	r1, r23
    35e2:	18 06       	cpc	r1, r24
    35e4:	99 1f       	adc	r25, r25
    35e6:	f1 cf       	rjmp	.-30     	; 0x35ca <__fp_splitA+0xc>
    35e8:	86 95       	lsr	r24
    35ea:	71 05       	cpc	r23, r1
    35ec:	61 05       	cpc	r22, r1
    35ee:	08 94       	sec
    35f0:	08 95       	ret

000035f2 <__fp_zero>:
    35f2:	e8 94       	clt

000035f4 <__fp_szero>:
    35f4:	bb 27       	eor	r27, r27
    35f6:	66 27       	eor	r22, r22
    35f8:	77 27       	eor	r23, r23
    35fa:	cb 01       	movw	r24, r22
    35fc:	97 f9       	bld	r25, 7
    35fe:	08 95       	ret

00003600 <__mulsf3>:
    3600:	0b d0       	rcall	.+22     	; 0x3618 <__mulsf3x>
    3602:	c4 cf       	rjmp	.-120    	; 0x358c <__fp_round>
    3604:	b5 df       	rcall	.-150    	; 0x3570 <__fp_pscA>
    3606:	28 f0       	brcs	.+10     	; 0x3612 <__mulsf3+0x12>
    3608:	ba df       	rcall	.-140    	; 0x357e <__fp_pscB>
    360a:	18 f0       	brcs	.+6      	; 0x3612 <__mulsf3+0x12>
    360c:	95 23       	and	r25, r21
    360e:	09 f0       	breq	.+2      	; 0x3612 <__mulsf3+0x12>
    3610:	a6 cf       	rjmp	.-180    	; 0x355e <__fp_inf>
    3612:	ab cf       	rjmp	.-170    	; 0x356a <__fp_nan>
    3614:	11 24       	eor	r1, r1
    3616:	ee cf       	rjmp	.-36     	; 0x35f4 <__fp_szero>

00003618 <__mulsf3x>:
    3618:	ca df       	rcall	.-108    	; 0x35ae <__fp_split3>
    361a:	a0 f3       	brcs	.-24     	; 0x3604 <__mulsf3+0x4>

0000361c <__mulsf3_pse>:
    361c:	95 9f       	mul	r25, r21
    361e:	d1 f3       	breq	.-12     	; 0x3614 <__mulsf3+0x14>
    3620:	95 0f       	add	r25, r21
    3622:	50 e0       	ldi	r21, 0x00	; 0
    3624:	55 1f       	adc	r21, r21
    3626:	62 9f       	mul	r22, r18
    3628:	f0 01       	movw	r30, r0
    362a:	72 9f       	mul	r23, r18
    362c:	bb 27       	eor	r27, r27
    362e:	f0 0d       	add	r31, r0
    3630:	b1 1d       	adc	r27, r1
    3632:	63 9f       	mul	r22, r19
    3634:	aa 27       	eor	r26, r26
    3636:	f0 0d       	add	r31, r0
    3638:	b1 1d       	adc	r27, r1
    363a:	aa 1f       	adc	r26, r26
    363c:	64 9f       	mul	r22, r20
    363e:	66 27       	eor	r22, r22
    3640:	b0 0d       	add	r27, r0
    3642:	a1 1d       	adc	r26, r1
    3644:	66 1f       	adc	r22, r22
    3646:	82 9f       	mul	r24, r18
    3648:	22 27       	eor	r18, r18
    364a:	b0 0d       	add	r27, r0
    364c:	a1 1d       	adc	r26, r1
    364e:	62 1f       	adc	r22, r18
    3650:	73 9f       	mul	r23, r19
    3652:	b0 0d       	add	r27, r0
    3654:	a1 1d       	adc	r26, r1
    3656:	62 1f       	adc	r22, r18
    3658:	83 9f       	mul	r24, r19
    365a:	a0 0d       	add	r26, r0
    365c:	61 1d       	adc	r22, r1
    365e:	22 1f       	adc	r18, r18
    3660:	74 9f       	mul	r23, r20
    3662:	33 27       	eor	r19, r19
    3664:	a0 0d       	add	r26, r0
    3666:	61 1d       	adc	r22, r1
    3668:	23 1f       	adc	r18, r19
    366a:	84 9f       	mul	r24, r20
    366c:	60 0d       	add	r22, r0
    366e:	21 1d       	adc	r18, r1
    3670:	82 2f       	mov	r24, r18
    3672:	76 2f       	mov	r23, r22
    3674:	6a 2f       	mov	r22, r26
    3676:	11 24       	eor	r1, r1
    3678:	9f 57       	subi	r25, 0x7F	; 127
    367a:	50 40       	sbci	r21, 0x00	; 0
    367c:	8a f0       	brmi	.+34     	; 0x36a0 <__mulsf3_pse+0x84>
    367e:	e1 f0       	breq	.+56     	; 0x36b8 <__mulsf3_pse+0x9c>
    3680:	88 23       	and	r24, r24
    3682:	4a f0       	brmi	.+18     	; 0x3696 <__mulsf3_pse+0x7a>
    3684:	ee 0f       	add	r30, r30
    3686:	ff 1f       	adc	r31, r31
    3688:	bb 1f       	adc	r27, r27
    368a:	66 1f       	adc	r22, r22
    368c:	77 1f       	adc	r23, r23
    368e:	88 1f       	adc	r24, r24
    3690:	91 50       	subi	r25, 0x01	; 1
    3692:	50 40       	sbci	r21, 0x00	; 0
    3694:	a9 f7       	brne	.-22     	; 0x3680 <__mulsf3_pse+0x64>
    3696:	9e 3f       	cpi	r25, 0xFE	; 254
    3698:	51 05       	cpc	r21, r1
    369a:	70 f0       	brcs	.+28     	; 0x36b8 <__mulsf3_pse+0x9c>
    369c:	60 cf       	rjmp	.-320    	; 0x355e <__fp_inf>
    369e:	aa cf       	rjmp	.-172    	; 0x35f4 <__fp_szero>
    36a0:	5f 3f       	cpi	r21, 0xFF	; 255
    36a2:	ec f3       	brlt	.-6      	; 0x369e <__mulsf3_pse+0x82>
    36a4:	98 3e       	cpi	r25, 0xE8	; 232
    36a6:	dc f3       	brlt	.-10     	; 0x369e <__mulsf3_pse+0x82>
    36a8:	86 95       	lsr	r24
    36aa:	77 95       	ror	r23
    36ac:	67 95       	ror	r22
    36ae:	b7 95       	ror	r27
    36b0:	f7 95       	ror	r31
    36b2:	e7 95       	ror	r30
    36b4:	9f 5f       	subi	r25, 0xFF	; 255
    36b6:	c1 f7       	brne	.-16     	; 0x36a8 <__mulsf3_pse+0x8c>
    36b8:	fe 2b       	or	r31, r30
    36ba:	88 0f       	add	r24, r24
    36bc:	91 1d       	adc	r25, r1
    36be:	96 95       	lsr	r25
    36c0:	87 95       	ror	r24
    36c2:	97 f9       	bld	r25, 7
    36c4:	08 95       	ret

000036c6 <memcpy>:
    36c6:	fb 01       	movw	r30, r22
    36c8:	dc 01       	movw	r26, r24
    36ca:	02 c0       	rjmp	.+4      	; 0x36d0 <memcpy+0xa>
    36cc:	01 90       	ld	r0, Z+
    36ce:	0d 92       	st	X+, r0
    36d0:	41 50       	subi	r20, 0x01	; 1
    36d2:	50 40       	sbci	r21, 0x00	; 0
    36d4:	d8 f7       	brcc	.-10     	; 0x36cc <memcpy+0x6>
    36d6:	08 95       	ret

000036d8 <sprintf>:
    36d8:	ae e0       	ldi	r26, 0x0E	; 14
    36da:	b0 e0       	ldi	r27, 0x00	; 0
    36dc:	e2 e7       	ldi	r30, 0x72	; 114
    36de:	fb e1       	ldi	r31, 0x1B	; 27
    36e0:	0c 94 1a 1e 	jmp	0x3c34	; 0x3c34 <__prologue_saves__+0x1c>
    36e4:	0d 89       	ldd	r16, Y+21	; 0x15
    36e6:	1e 89       	ldd	r17, Y+22	; 0x16
    36e8:	86 e0       	ldi	r24, 0x06	; 6
    36ea:	8c 83       	std	Y+4, r24	; 0x04
    36ec:	1a 83       	std	Y+2, r17	; 0x02
    36ee:	09 83       	std	Y+1, r16	; 0x01
    36f0:	8f ef       	ldi	r24, 0xFF	; 255
    36f2:	9f e7       	ldi	r25, 0x7F	; 127
    36f4:	9e 83       	std	Y+6, r25	; 0x06
    36f6:	8d 83       	std	Y+5, r24	; 0x05
    36f8:	ae 01       	movw	r20, r28
    36fa:	47 5e       	subi	r20, 0xE7	; 231
    36fc:	5f 4f       	sbci	r21, 0xFF	; 255
    36fe:	ce 01       	movw	r24, r28
    3700:	01 96       	adiw	r24, 0x01	; 1
    3702:	6f 89       	ldd	r22, Y+23	; 0x17
    3704:	78 8d       	ldd	r23, Y+24	; 0x18
    3706:	0e 94 8e 1b 	call	0x371c	; 0x371c <vfprintf>
    370a:	ef 81       	ldd	r30, Y+7	; 0x07
    370c:	f8 85       	ldd	r31, Y+8	; 0x08
    370e:	e0 0f       	add	r30, r16
    3710:	f1 1f       	adc	r31, r17
    3712:	10 82       	st	Z, r1
    3714:	2e 96       	adiw	r28, 0x0e	; 14
    3716:	e4 e0       	ldi	r30, 0x04	; 4
    3718:	0c 94 36 1e 	jmp	0x3c6c	; 0x3c6c <__epilogue_restores__+0x1c>

0000371c <vfprintf>:
    371c:	ad e0       	ldi	r26, 0x0D	; 13
    371e:	b0 e0       	ldi	r27, 0x00	; 0
    3720:	e4 e9       	ldi	r30, 0x94	; 148
    3722:	fb e1       	ldi	r31, 0x1B	; 27
    3724:	0c 94 0c 1e 	jmp	0x3c18	; 0x3c18 <__prologue_saves__>
    3728:	3c 01       	movw	r6, r24
    372a:	7d 87       	std	Y+13, r23	; 0x0d
    372c:	6c 87       	std	Y+12, r22	; 0x0c
    372e:	5a 01       	movw	r10, r20
    3730:	fc 01       	movw	r30, r24
    3732:	17 82       	std	Z+7, r1	; 0x07
    3734:	16 82       	std	Z+6, r1	; 0x06
    3736:	83 81       	ldd	r24, Z+3	; 0x03
    3738:	81 ff       	sbrs	r24, 1
    373a:	c8 c1       	rjmp	.+912    	; 0x3acc <vfprintf+0x3b0>
    373c:	2e 01       	movw	r4, r28
    373e:	08 94       	sec
    3740:	41 1c       	adc	r4, r1
    3742:	51 1c       	adc	r5, r1
    3744:	f3 01       	movw	r30, r6
    3746:	93 81       	ldd	r25, Z+3	; 0x03
    3748:	ec 85       	ldd	r30, Y+12	; 0x0c
    374a:	fd 85       	ldd	r31, Y+13	; 0x0d
    374c:	93 fd       	sbrc	r25, 3
    374e:	85 91       	lpm	r24, Z+
    3750:	93 ff       	sbrs	r25, 3
    3752:	81 91       	ld	r24, Z+
    3754:	fd 87       	std	Y+13, r31	; 0x0d
    3756:	ec 87       	std	Y+12, r30	; 0x0c
    3758:	88 23       	and	r24, r24
    375a:	09 f4       	brne	.+2      	; 0x375e <vfprintf+0x42>
    375c:	b3 c1       	rjmp	.+870    	; 0x3ac4 <vfprintf+0x3a8>
    375e:	85 32       	cpi	r24, 0x25	; 37
    3760:	41 f4       	brne	.+16     	; 0x3772 <vfprintf+0x56>
    3762:	93 fd       	sbrc	r25, 3
    3764:	85 91       	lpm	r24, Z+
    3766:	93 ff       	sbrs	r25, 3
    3768:	81 91       	ld	r24, Z+
    376a:	fd 87       	std	Y+13, r31	; 0x0d
    376c:	ec 87       	std	Y+12, r30	; 0x0c
    376e:	85 32       	cpi	r24, 0x25	; 37
    3770:	29 f4       	brne	.+10     	; 0x377c <vfprintf+0x60>
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	b3 01       	movw	r22, r6
    3776:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    377a:	e4 cf       	rjmp	.-56     	; 0x3744 <vfprintf+0x28>
    377c:	ff 24       	eor	r15, r15
    377e:	ee 24       	eor	r14, r14
    3780:	10 e0       	ldi	r17, 0x00	; 0
    3782:	10 32       	cpi	r17, 0x20	; 32
    3784:	b0 f4       	brcc	.+44     	; 0x37b2 <vfprintf+0x96>
    3786:	8b 32       	cpi	r24, 0x2B	; 43
    3788:	69 f0       	breq	.+26     	; 0x37a4 <vfprintf+0x88>
    378a:	8c 32       	cpi	r24, 0x2C	; 44
    378c:	28 f4       	brcc	.+10     	; 0x3798 <vfprintf+0x7c>
    378e:	80 32       	cpi	r24, 0x20	; 32
    3790:	51 f0       	breq	.+20     	; 0x37a6 <vfprintf+0x8a>
    3792:	83 32       	cpi	r24, 0x23	; 35
    3794:	71 f4       	brne	.+28     	; 0x37b2 <vfprintf+0x96>
    3796:	0b c0       	rjmp	.+22     	; 0x37ae <vfprintf+0x92>
    3798:	8d 32       	cpi	r24, 0x2D	; 45
    379a:	39 f0       	breq	.+14     	; 0x37aa <vfprintf+0x8e>
    379c:	80 33       	cpi	r24, 0x30	; 48
    379e:	49 f4       	brne	.+18     	; 0x37b2 <vfprintf+0x96>
    37a0:	11 60       	ori	r17, 0x01	; 1
    37a2:	2c c0       	rjmp	.+88     	; 0x37fc <vfprintf+0xe0>
    37a4:	12 60       	ori	r17, 0x02	; 2
    37a6:	14 60       	ori	r17, 0x04	; 4
    37a8:	29 c0       	rjmp	.+82     	; 0x37fc <vfprintf+0xe0>
    37aa:	18 60       	ori	r17, 0x08	; 8
    37ac:	27 c0       	rjmp	.+78     	; 0x37fc <vfprintf+0xe0>
    37ae:	10 61       	ori	r17, 0x10	; 16
    37b0:	25 c0       	rjmp	.+74     	; 0x37fc <vfprintf+0xe0>
    37b2:	17 fd       	sbrc	r17, 7
    37b4:	2e c0       	rjmp	.+92     	; 0x3812 <vfprintf+0xf6>
    37b6:	28 2f       	mov	r18, r24
    37b8:	20 53       	subi	r18, 0x30	; 48
    37ba:	2a 30       	cpi	r18, 0x0A	; 10
    37bc:	98 f4       	brcc	.+38     	; 0x37e4 <vfprintf+0xc8>
    37be:	16 ff       	sbrs	r17, 6
    37c0:	08 c0       	rjmp	.+16     	; 0x37d2 <vfprintf+0xb6>
    37c2:	8f 2d       	mov	r24, r15
    37c4:	88 0f       	add	r24, r24
    37c6:	f8 2e       	mov	r15, r24
    37c8:	ff 0c       	add	r15, r15
    37ca:	ff 0c       	add	r15, r15
    37cc:	f8 0e       	add	r15, r24
    37ce:	f2 0e       	add	r15, r18
    37d0:	15 c0       	rjmp	.+42     	; 0x37fc <vfprintf+0xe0>
    37d2:	8e 2d       	mov	r24, r14
    37d4:	88 0f       	add	r24, r24
    37d6:	e8 2e       	mov	r14, r24
    37d8:	ee 0c       	add	r14, r14
    37da:	ee 0c       	add	r14, r14
    37dc:	e8 0e       	add	r14, r24
    37de:	e2 0e       	add	r14, r18
    37e0:	10 62       	ori	r17, 0x20	; 32
    37e2:	0c c0       	rjmp	.+24     	; 0x37fc <vfprintf+0xe0>
    37e4:	8e 32       	cpi	r24, 0x2E	; 46
    37e6:	21 f4       	brne	.+8      	; 0x37f0 <vfprintf+0xd4>
    37e8:	16 fd       	sbrc	r17, 6
    37ea:	6c c1       	rjmp	.+728    	; 0x3ac4 <vfprintf+0x3a8>
    37ec:	10 64       	ori	r17, 0x40	; 64
    37ee:	06 c0       	rjmp	.+12     	; 0x37fc <vfprintf+0xe0>
    37f0:	8c 36       	cpi	r24, 0x6C	; 108
    37f2:	11 f4       	brne	.+4      	; 0x37f8 <vfprintf+0xdc>
    37f4:	10 68       	ori	r17, 0x80	; 128
    37f6:	02 c0       	rjmp	.+4      	; 0x37fc <vfprintf+0xe0>
    37f8:	88 36       	cpi	r24, 0x68	; 104
    37fa:	59 f4       	brne	.+22     	; 0x3812 <vfprintf+0xf6>
    37fc:	ec 85       	ldd	r30, Y+12	; 0x0c
    37fe:	fd 85       	ldd	r31, Y+13	; 0x0d
    3800:	93 fd       	sbrc	r25, 3
    3802:	85 91       	lpm	r24, Z+
    3804:	93 ff       	sbrs	r25, 3
    3806:	81 91       	ld	r24, Z+
    3808:	fd 87       	std	Y+13, r31	; 0x0d
    380a:	ec 87       	std	Y+12, r30	; 0x0c
    380c:	88 23       	and	r24, r24
    380e:	09 f0       	breq	.+2      	; 0x3812 <vfprintf+0xf6>
    3810:	b8 cf       	rjmp	.-144    	; 0x3782 <vfprintf+0x66>
    3812:	98 2f       	mov	r25, r24
    3814:	95 54       	subi	r25, 0x45	; 69
    3816:	93 30       	cpi	r25, 0x03	; 3
    3818:	18 f0       	brcs	.+6      	; 0x3820 <vfprintf+0x104>
    381a:	90 52       	subi	r25, 0x20	; 32
    381c:	93 30       	cpi	r25, 0x03	; 3
    381e:	38 f4       	brcc	.+14     	; 0x382e <vfprintf+0x112>
    3820:	24 e0       	ldi	r18, 0x04	; 4
    3822:	30 e0       	ldi	r19, 0x00	; 0
    3824:	a2 0e       	add	r10, r18
    3826:	b3 1e       	adc	r11, r19
    3828:	3f e3       	ldi	r19, 0x3F	; 63
    382a:	39 83       	std	Y+1, r19	; 0x01
    382c:	0f c0       	rjmp	.+30     	; 0x384c <vfprintf+0x130>
    382e:	83 36       	cpi	r24, 0x63	; 99
    3830:	31 f0       	breq	.+12     	; 0x383e <vfprintf+0x122>
    3832:	83 37       	cpi	r24, 0x73	; 115
    3834:	81 f0       	breq	.+32     	; 0x3856 <vfprintf+0x13a>
    3836:	83 35       	cpi	r24, 0x53	; 83
    3838:	09 f0       	breq	.+2      	; 0x383c <vfprintf+0x120>
    383a:	5a c0       	rjmp	.+180    	; 0x38f0 <vfprintf+0x1d4>
    383c:	22 c0       	rjmp	.+68     	; 0x3882 <vfprintf+0x166>
    383e:	f5 01       	movw	r30, r10
    3840:	80 81       	ld	r24, Z
    3842:	89 83       	std	Y+1, r24	; 0x01
    3844:	22 e0       	ldi	r18, 0x02	; 2
    3846:	30 e0       	ldi	r19, 0x00	; 0
    3848:	a2 0e       	add	r10, r18
    384a:	b3 1e       	adc	r11, r19
    384c:	21 e0       	ldi	r18, 0x01	; 1
    384e:	c2 2e       	mov	r12, r18
    3850:	d1 2c       	mov	r13, r1
    3852:	42 01       	movw	r8, r4
    3854:	14 c0       	rjmp	.+40     	; 0x387e <vfprintf+0x162>
    3856:	92 e0       	ldi	r25, 0x02	; 2
    3858:	29 2e       	mov	r2, r25
    385a:	31 2c       	mov	r3, r1
    385c:	2a 0c       	add	r2, r10
    385e:	3b 1c       	adc	r3, r11
    3860:	f5 01       	movw	r30, r10
    3862:	80 80       	ld	r8, Z
    3864:	91 80       	ldd	r9, Z+1	; 0x01
    3866:	16 ff       	sbrs	r17, 6
    3868:	03 c0       	rjmp	.+6      	; 0x3870 <vfprintf+0x154>
    386a:	6f 2d       	mov	r22, r15
    386c:	70 e0       	ldi	r23, 0x00	; 0
    386e:	02 c0       	rjmp	.+4      	; 0x3874 <vfprintf+0x158>
    3870:	6f ef       	ldi	r22, 0xFF	; 255
    3872:	7f ef       	ldi	r23, 0xFF	; 255
    3874:	c4 01       	movw	r24, r8
    3876:	0e 94 77 1d 	call	0x3aee	; 0x3aee <strnlen>
    387a:	6c 01       	movw	r12, r24
    387c:	51 01       	movw	r10, r2
    387e:	1f 77       	andi	r17, 0x7F	; 127
    3880:	15 c0       	rjmp	.+42     	; 0x38ac <vfprintf+0x190>
    3882:	82 e0       	ldi	r24, 0x02	; 2
    3884:	28 2e       	mov	r2, r24
    3886:	31 2c       	mov	r3, r1
    3888:	2a 0c       	add	r2, r10
    388a:	3b 1c       	adc	r3, r11
    388c:	f5 01       	movw	r30, r10
    388e:	80 80       	ld	r8, Z
    3890:	91 80       	ldd	r9, Z+1	; 0x01
    3892:	16 ff       	sbrs	r17, 6
    3894:	03 c0       	rjmp	.+6      	; 0x389c <vfprintf+0x180>
    3896:	6f 2d       	mov	r22, r15
    3898:	70 e0       	ldi	r23, 0x00	; 0
    389a:	02 c0       	rjmp	.+4      	; 0x38a0 <vfprintf+0x184>
    389c:	6f ef       	ldi	r22, 0xFF	; 255
    389e:	7f ef       	ldi	r23, 0xFF	; 255
    38a0:	c4 01       	movw	r24, r8
    38a2:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <strnlen_P>
    38a6:	6c 01       	movw	r12, r24
    38a8:	10 68       	ori	r17, 0x80	; 128
    38aa:	51 01       	movw	r10, r2
    38ac:	13 fd       	sbrc	r17, 3
    38ae:	1c c0       	rjmp	.+56     	; 0x38e8 <vfprintf+0x1cc>
    38b0:	06 c0       	rjmp	.+12     	; 0x38be <vfprintf+0x1a2>
    38b2:	80 e2       	ldi	r24, 0x20	; 32
    38b4:	90 e0       	ldi	r25, 0x00	; 0
    38b6:	b3 01       	movw	r22, r6
    38b8:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    38bc:	ea 94       	dec	r14
    38be:	8e 2d       	mov	r24, r14
    38c0:	90 e0       	ldi	r25, 0x00	; 0
    38c2:	c8 16       	cp	r12, r24
    38c4:	d9 06       	cpc	r13, r25
    38c6:	a8 f3       	brcs	.-22     	; 0x38b2 <vfprintf+0x196>
    38c8:	0f c0       	rjmp	.+30     	; 0x38e8 <vfprintf+0x1cc>
    38ca:	f4 01       	movw	r30, r8
    38cc:	17 fd       	sbrc	r17, 7
    38ce:	85 91       	lpm	r24, Z+
    38d0:	17 ff       	sbrs	r17, 7
    38d2:	81 91       	ld	r24, Z+
    38d4:	4f 01       	movw	r8, r30
    38d6:	90 e0       	ldi	r25, 0x00	; 0
    38d8:	b3 01       	movw	r22, r6
    38da:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    38de:	e1 10       	cpse	r14, r1
    38e0:	ea 94       	dec	r14
    38e2:	08 94       	sec
    38e4:	c1 08       	sbc	r12, r1
    38e6:	d1 08       	sbc	r13, r1
    38e8:	c1 14       	cp	r12, r1
    38ea:	d1 04       	cpc	r13, r1
    38ec:	71 f7       	brne	.-36     	; 0x38ca <vfprintf+0x1ae>
    38ee:	e7 c0       	rjmp	.+462    	; 0x3abe <vfprintf+0x3a2>
    38f0:	84 36       	cpi	r24, 0x64	; 100
    38f2:	11 f0       	breq	.+4      	; 0x38f8 <vfprintf+0x1dc>
    38f4:	89 36       	cpi	r24, 0x69	; 105
    38f6:	51 f5       	brne	.+84     	; 0x394c <vfprintf+0x230>
    38f8:	f5 01       	movw	r30, r10
    38fa:	17 ff       	sbrs	r17, 7
    38fc:	07 c0       	rjmp	.+14     	; 0x390c <vfprintf+0x1f0>
    38fe:	80 81       	ld	r24, Z
    3900:	91 81       	ldd	r25, Z+1	; 0x01
    3902:	a2 81       	ldd	r26, Z+2	; 0x02
    3904:	b3 81       	ldd	r27, Z+3	; 0x03
    3906:	24 e0       	ldi	r18, 0x04	; 4
    3908:	30 e0       	ldi	r19, 0x00	; 0
    390a:	08 c0       	rjmp	.+16     	; 0x391c <vfprintf+0x200>
    390c:	80 81       	ld	r24, Z
    390e:	91 81       	ldd	r25, Z+1	; 0x01
    3910:	aa 27       	eor	r26, r26
    3912:	97 fd       	sbrc	r25, 7
    3914:	a0 95       	com	r26
    3916:	ba 2f       	mov	r27, r26
    3918:	22 e0       	ldi	r18, 0x02	; 2
    391a:	30 e0       	ldi	r19, 0x00	; 0
    391c:	a2 0e       	add	r10, r18
    391e:	b3 1e       	adc	r11, r19
    3920:	01 2f       	mov	r16, r17
    3922:	0f 76       	andi	r16, 0x6F	; 111
    3924:	b7 ff       	sbrs	r27, 7
    3926:	08 c0       	rjmp	.+16     	; 0x3938 <vfprintf+0x21c>
    3928:	b0 95       	com	r27
    392a:	a0 95       	com	r26
    392c:	90 95       	com	r25
    392e:	81 95       	neg	r24
    3930:	9f 4f       	sbci	r25, 0xFF	; 255
    3932:	af 4f       	sbci	r26, 0xFF	; 255
    3934:	bf 4f       	sbci	r27, 0xFF	; 255
    3936:	00 68       	ori	r16, 0x80	; 128
    3938:	bc 01       	movw	r22, r24
    393a:	cd 01       	movw	r24, r26
    393c:	a2 01       	movw	r20, r4
    393e:	2a e0       	ldi	r18, 0x0A	; 10
    3940:	30 e0       	ldi	r19, 0x00	; 0
    3942:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <__ultoa_invert>
    3946:	d8 2e       	mov	r13, r24
    3948:	d4 18       	sub	r13, r4
    394a:	3f c0       	rjmp	.+126    	; 0x39ca <vfprintf+0x2ae>
    394c:	85 37       	cpi	r24, 0x75	; 117
    394e:	21 f4       	brne	.+8      	; 0x3958 <vfprintf+0x23c>
    3950:	1f 7e       	andi	r17, 0xEF	; 239
    3952:	2a e0       	ldi	r18, 0x0A	; 10
    3954:	30 e0       	ldi	r19, 0x00	; 0
    3956:	20 c0       	rjmp	.+64     	; 0x3998 <vfprintf+0x27c>
    3958:	19 7f       	andi	r17, 0xF9	; 249
    395a:	8f 36       	cpi	r24, 0x6F	; 111
    395c:	a9 f0       	breq	.+42     	; 0x3988 <vfprintf+0x26c>
    395e:	80 37       	cpi	r24, 0x70	; 112
    3960:	20 f4       	brcc	.+8      	; 0x396a <vfprintf+0x24e>
    3962:	88 35       	cpi	r24, 0x58	; 88
    3964:	09 f0       	breq	.+2      	; 0x3968 <vfprintf+0x24c>
    3966:	ae c0       	rjmp	.+348    	; 0x3ac4 <vfprintf+0x3a8>
    3968:	0b c0       	rjmp	.+22     	; 0x3980 <vfprintf+0x264>
    396a:	80 37       	cpi	r24, 0x70	; 112
    396c:	21 f0       	breq	.+8      	; 0x3976 <vfprintf+0x25a>
    396e:	88 37       	cpi	r24, 0x78	; 120
    3970:	09 f0       	breq	.+2      	; 0x3974 <vfprintf+0x258>
    3972:	a8 c0       	rjmp	.+336    	; 0x3ac4 <vfprintf+0x3a8>
    3974:	01 c0       	rjmp	.+2      	; 0x3978 <vfprintf+0x25c>
    3976:	10 61       	ori	r17, 0x10	; 16
    3978:	14 ff       	sbrs	r17, 4
    397a:	09 c0       	rjmp	.+18     	; 0x398e <vfprintf+0x272>
    397c:	14 60       	ori	r17, 0x04	; 4
    397e:	07 c0       	rjmp	.+14     	; 0x398e <vfprintf+0x272>
    3980:	14 ff       	sbrs	r17, 4
    3982:	08 c0       	rjmp	.+16     	; 0x3994 <vfprintf+0x278>
    3984:	16 60       	ori	r17, 0x06	; 6
    3986:	06 c0       	rjmp	.+12     	; 0x3994 <vfprintf+0x278>
    3988:	28 e0       	ldi	r18, 0x08	; 8
    398a:	30 e0       	ldi	r19, 0x00	; 0
    398c:	05 c0       	rjmp	.+10     	; 0x3998 <vfprintf+0x27c>
    398e:	20 e1       	ldi	r18, 0x10	; 16
    3990:	30 e0       	ldi	r19, 0x00	; 0
    3992:	02 c0       	rjmp	.+4      	; 0x3998 <vfprintf+0x27c>
    3994:	20 e1       	ldi	r18, 0x10	; 16
    3996:	32 e0       	ldi	r19, 0x02	; 2
    3998:	f5 01       	movw	r30, r10
    399a:	17 ff       	sbrs	r17, 7
    399c:	07 c0       	rjmp	.+14     	; 0x39ac <vfprintf+0x290>
    399e:	60 81       	ld	r22, Z
    39a0:	71 81       	ldd	r23, Z+1	; 0x01
    39a2:	82 81       	ldd	r24, Z+2	; 0x02
    39a4:	93 81       	ldd	r25, Z+3	; 0x03
    39a6:	44 e0       	ldi	r20, 0x04	; 4
    39a8:	50 e0       	ldi	r21, 0x00	; 0
    39aa:	06 c0       	rjmp	.+12     	; 0x39b8 <vfprintf+0x29c>
    39ac:	60 81       	ld	r22, Z
    39ae:	71 81       	ldd	r23, Z+1	; 0x01
    39b0:	80 e0       	ldi	r24, 0x00	; 0
    39b2:	90 e0       	ldi	r25, 0x00	; 0
    39b4:	42 e0       	ldi	r20, 0x02	; 2
    39b6:	50 e0       	ldi	r21, 0x00	; 0
    39b8:	a4 0e       	add	r10, r20
    39ba:	b5 1e       	adc	r11, r21
    39bc:	a2 01       	movw	r20, r4
    39be:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <__ultoa_invert>
    39c2:	d8 2e       	mov	r13, r24
    39c4:	d4 18       	sub	r13, r4
    39c6:	01 2f       	mov	r16, r17
    39c8:	0f 77       	andi	r16, 0x7F	; 127
    39ca:	06 ff       	sbrs	r16, 6
    39cc:	09 c0       	rjmp	.+18     	; 0x39e0 <vfprintf+0x2c4>
    39ce:	0e 7f       	andi	r16, 0xFE	; 254
    39d0:	df 14       	cp	r13, r15
    39d2:	30 f4       	brcc	.+12     	; 0x39e0 <vfprintf+0x2c4>
    39d4:	04 ff       	sbrs	r16, 4
    39d6:	06 c0       	rjmp	.+12     	; 0x39e4 <vfprintf+0x2c8>
    39d8:	02 fd       	sbrc	r16, 2
    39da:	04 c0       	rjmp	.+8      	; 0x39e4 <vfprintf+0x2c8>
    39dc:	0f 7e       	andi	r16, 0xEF	; 239
    39de:	02 c0       	rjmp	.+4      	; 0x39e4 <vfprintf+0x2c8>
    39e0:	1d 2d       	mov	r17, r13
    39e2:	01 c0       	rjmp	.+2      	; 0x39e6 <vfprintf+0x2ca>
    39e4:	1f 2d       	mov	r17, r15
    39e6:	80 2f       	mov	r24, r16
    39e8:	90 e0       	ldi	r25, 0x00	; 0
    39ea:	04 ff       	sbrs	r16, 4
    39ec:	0c c0       	rjmp	.+24     	; 0x3a06 <vfprintf+0x2ea>
    39ee:	fe 01       	movw	r30, r28
    39f0:	ed 0d       	add	r30, r13
    39f2:	f1 1d       	adc	r31, r1
    39f4:	20 81       	ld	r18, Z
    39f6:	20 33       	cpi	r18, 0x30	; 48
    39f8:	11 f4       	brne	.+4      	; 0x39fe <vfprintf+0x2e2>
    39fa:	09 7e       	andi	r16, 0xE9	; 233
    39fc:	09 c0       	rjmp	.+18     	; 0x3a10 <vfprintf+0x2f4>
    39fe:	02 ff       	sbrs	r16, 2
    3a00:	06 c0       	rjmp	.+12     	; 0x3a0e <vfprintf+0x2f2>
    3a02:	1e 5f       	subi	r17, 0xFE	; 254
    3a04:	05 c0       	rjmp	.+10     	; 0x3a10 <vfprintf+0x2f4>
    3a06:	86 78       	andi	r24, 0x86	; 134
    3a08:	90 70       	andi	r25, 0x00	; 0
    3a0a:	00 97       	sbiw	r24, 0x00	; 0
    3a0c:	09 f0       	breq	.+2      	; 0x3a10 <vfprintf+0x2f4>
    3a0e:	1f 5f       	subi	r17, 0xFF	; 255
    3a10:	80 2e       	mov	r8, r16
    3a12:	99 24       	eor	r9, r9
    3a14:	03 fd       	sbrc	r16, 3
    3a16:	12 c0       	rjmp	.+36     	; 0x3a3c <vfprintf+0x320>
    3a18:	00 ff       	sbrs	r16, 0
    3a1a:	0d c0       	rjmp	.+26     	; 0x3a36 <vfprintf+0x31a>
    3a1c:	fd 2c       	mov	r15, r13
    3a1e:	1e 15       	cp	r17, r14
    3a20:	50 f4       	brcc	.+20     	; 0x3a36 <vfprintf+0x31a>
    3a22:	fe 0c       	add	r15, r14
    3a24:	f1 1a       	sub	r15, r17
    3a26:	1e 2d       	mov	r17, r14
    3a28:	06 c0       	rjmp	.+12     	; 0x3a36 <vfprintf+0x31a>
    3a2a:	80 e2       	ldi	r24, 0x20	; 32
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	b3 01       	movw	r22, r6
    3a30:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    3a34:	1f 5f       	subi	r17, 0xFF	; 255
    3a36:	1e 15       	cp	r17, r14
    3a38:	c0 f3       	brcs	.-16     	; 0x3a2a <vfprintf+0x30e>
    3a3a:	04 c0       	rjmp	.+8      	; 0x3a44 <vfprintf+0x328>
    3a3c:	1e 15       	cp	r17, r14
    3a3e:	10 f4       	brcc	.+4      	; 0x3a44 <vfprintf+0x328>
    3a40:	e1 1a       	sub	r14, r17
    3a42:	01 c0       	rjmp	.+2      	; 0x3a46 <vfprintf+0x32a>
    3a44:	ee 24       	eor	r14, r14
    3a46:	84 fe       	sbrs	r8, 4
    3a48:	0f c0       	rjmp	.+30     	; 0x3a68 <vfprintf+0x34c>
    3a4a:	80 e3       	ldi	r24, 0x30	; 48
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	b3 01       	movw	r22, r6
    3a50:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    3a54:	82 fe       	sbrs	r8, 2
    3a56:	1f c0       	rjmp	.+62     	; 0x3a96 <vfprintf+0x37a>
    3a58:	81 fe       	sbrs	r8, 1
    3a5a:	03 c0       	rjmp	.+6      	; 0x3a62 <vfprintf+0x346>
    3a5c:	88 e5       	ldi	r24, 0x58	; 88
    3a5e:	90 e0       	ldi	r25, 0x00	; 0
    3a60:	10 c0       	rjmp	.+32     	; 0x3a82 <vfprintf+0x366>
    3a62:	88 e7       	ldi	r24, 0x78	; 120
    3a64:	90 e0       	ldi	r25, 0x00	; 0
    3a66:	0d c0       	rjmp	.+26     	; 0x3a82 <vfprintf+0x366>
    3a68:	c4 01       	movw	r24, r8
    3a6a:	86 78       	andi	r24, 0x86	; 134
    3a6c:	90 70       	andi	r25, 0x00	; 0
    3a6e:	00 97       	sbiw	r24, 0x00	; 0
    3a70:	91 f0       	breq	.+36     	; 0x3a96 <vfprintf+0x37a>
    3a72:	81 fc       	sbrc	r8, 1
    3a74:	02 c0       	rjmp	.+4      	; 0x3a7a <vfprintf+0x35e>
    3a76:	80 e2       	ldi	r24, 0x20	; 32
    3a78:	01 c0       	rjmp	.+2      	; 0x3a7c <vfprintf+0x360>
    3a7a:	8b e2       	ldi	r24, 0x2B	; 43
    3a7c:	07 fd       	sbrc	r16, 7
    3a7e:	8d e2       	ldi	r24, 0x2D	; 45
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	b3 01       	movw	r22, r6
    3a84:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    3a88:	06 c0       	rjmp	.+12     	; 0x3a96 <vfprintf+0x37a>
    3a8a:	80 e3       	ldi	r24, 0x30	; 48
    3a8c:	90 e0       	ldi	r25, 0x00	; 0
    3a8e:	b3 01       	movw	r22, r6
    3a90:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    3a94:	fa 94       	dec	r15
    3a96:	df 14       	cp	r13, r15
    3a98:	c0 f3       	brcs	.-16     	; 0x3a8a <vfprintf+0x36e>
    3a9a:	da 94       	dec	r13
    3a9c:	f2 01       	movw	r30, r4
    3a9e:	ed 0d       	add	r30, r13
    3aa0:	f1 1d       	adc	r31, r1
    3aa2:	80 81       	ld	r24, Z
    3aa4:	90 e0       	ldi	r25, 0x00	; 0
    3aa6:	b3 01       	movw	r22, r6
    3aa8:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    3aac:	dd 20       	and	r13, r13
    3aae:	a9 f7       	brne	.-22     	; 0x3a9a <vfprintf+0x37e>
    3ab0:	06 c0       	rjmp	.+12     	; 0x3abe <vfprintf+0x3a2>
    3ab2:	80 e2       	ldi	r24, 0x20	; 32
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	b3 01       	movw	r22, r6
    3ab8:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <fputc>
    3abc:	ea 94       	dec	r14
    3abe:	ee 20       	and	r14, r14
    3ac0:	c1 f7       	brne	.-16     	; 0x3ab2 <vfprintf+0x396>
    3ac2:	40 ce       	rjmp	.-896    	; 0x3744 <vfprintf+0x28>
    3ac4:	f3 01       	movw	r30, r6
    3ac6:	86 81       	ldd	r24, Z+6	; 0x06
    3ac8:	97 81       	ldd	r25, Z+7	; 0x07
    3aca:	02 c0       	rjmp	.+4      	; 0x3ad0 <vfprintf+0x3b4>
    3acc:	8f ef       	ldi	r24, 0xFF	; 255
    3ace:	9f ef       	ldi	r25, 0xFF	; 255
    3ad0:	2d 96       	adiw	r28, 0x0d	; 13
    3ad2:	e2 e1       	ldi	r30, 0x12	; 18
    3ad4:	0c 94 28 1e 	jmp	0x3c50	; 0x3c50 <__epilogue_restores__>

00003ad8 <strnlen_P>:
    3ad8:	fc 01       	movw	r30, r24
    3ada:	05 90       	lpm	r0, Z+
    3adc:	61 50       	subi	r22, 0x01	; 1
    3ade:	70 40       	sbci	r23, 0x00	; 0
    3ae0:	01 10       	cpse	r0, r1
    3ae2:	d8 f7       	brcc	.-10     	; 0x3ada <strnlen_P+0x2>
    3ae4:	80 95       	com	r24
    3ae6:	90 95       	com	r25
    3ae8:	8e 0f       	add	r24, r30
    3aea:	9f 1f       	adc	r25, r31
    3aec:	08 95       	ret

00003aee <strnlen>:
    3aee:	fc 01       	movw	r30, r24
    3af0:	61 50       	subi	r22, 0x01	; 1
    3af2:	70 40       	sbci	r23, 0x00	; 0
    3af4:	01 90       	ld	r0, Z+
    3af6:	01 10       	cpse	r0, r1
    3af8:	d8 f7       	brcc	.-10     	; 0x3af0 <strnlen+0x2>
    3afa:	80 95       	com	r24
    3afc:	90 95       	com	r25
    3afe:	8e 0f       	add	r24, r30
    3b00:	9f 1f       	adc	r25, r31
    3b02:	08 95       	ret

00003b04 <fputc>:
    3b04:	0f 93       	push	r16
    3b06:	1f 93       	push	r17
    3b08:	cf 93       	push	r28
    3b0a:	df 93       	push	r29
    3b0c:	8c 01       	movw	r16, r24
    3b0e:	eb 01       	movw	r28, r22
    3b10:	8b 81       	ldd	r24, Y+3	; 0x03
    3b12:	81 ff       	sbrs	r24, 1
    3b14:	1b c0       	rjmp	.+54     	; 0x3b4c <fputc+0x48>
    3b16:	82 ff       	sbrs	r24, 2
    3b18:	0d c0       	rjmp	.+26     	; 0x3b34 <fputc+0x30>
    3b1a:	2e 81       	ldd	r18, Y+6	; 0x06
    3b1c:	3f 81       	ldd	r19, Y+7	; 0x07
    3b1e:	8c 81       	ldd	r24, Y+4	; 0x04
    3b20:	9d 81       	ldd	r25, Y+5	; 0x05
    3b22:	28 17       	cp	r18, r24
    3b24:	39 07       	cpc	r19, r25
    3b26:	64 f4       	brge	.+24     	; 0x3b40 <fputc+0x3c>
    3b28:	e8 81       	ld	r30, Y
    3b2a:	f9 81       	ldd	r31, Y+1	; 0x01
    3b2c:	01 93       	st	Z+, r16
    3b2e:	f9 83       	std	Y+1, r31	; 0x01
    3b30:	e8 83       	st	Y, r30
    3b32:	06 c0       	rjmp	.+12     	; 0x3b40 <fputc+0x3c>
    3b34:	e8 85       	ldd	r30, Y+8	; 0x08
    3b36:	f9 85       	ldd	r31, Y+9	; 0x09
    3b38:	80 2f       	mov	r24, r16
    3b3a:	09 95       	icall
    3b3c:	00 97       	sbiw	r24, 0x00	; 0
    3b3e:	31 f4       	brne	.+12     	; 0x3b4c <fputc+0x48>
    3b40:	8e 81       	ldd	r24, Y+6	; 0x06
    3b42:	9f 81       	ldd	r25, Y+7	; 0x07
    3b44:	01 96       	adiw	r24, 0x01	; 1
    3b46:	9f 83       	std	Y+7, r25	; 0x07
    3b48:	8e 83       	std	Y+6, r24	; 0x06
    3b4a:	02 c0       	rjmp	.+4      	; 0x3b50 <fputc+0x4c>
    3b4c:	0f ef       	ldi	r16, 0xFF	; 255
    3b4e:	1f ef       	ldi	r17, 0xFF	; 255
    3b50:	c8 01       	movw	r24, r16
    3b52:	df 91       	pop	r29
    3b54:	cf 91       	pop	r28
    3b56:	1f 91       	pop	r17
    3b58:	0f 91       	pop	r16
    3b5a:	08 95       	ret

00003b5c <__ultoa_invert>:
    3b5c:	fa 01       	movw	r30, r20
    3b5e:	aa 27       	eor	r26, r26
    3b60:	28 30       	cpi	r18, 0x08	; 8
    3b62:	51 f1       	breq	.+84     	; 0x3bb8 <__ultoa_invert+0x5c>
    3b64:	20 31       	cpi	r18, 0x10	; 16
    3b66:	81 f1       	breq	.+96     	; 0x3bc8 <__ultoa_invert+0x6c>
    3b68:	e8 94       	clt
    3b6a:	6f 93       	push	r22
    3b6c:	6e 7f       	andi	r22, 0xFE	; 254
    3b6e:	6e 5f       	subi	r22, 0xFE	; 254
    3b70:	7f 4f       	sbci	r23, 0xFF	; 255
    3b72:	8f 4f       	sbci	r24, 0xFF	; 255
    3b74:	9f 4f       	sbci	r25, 0xFF	; 255
    3b76:	af 4f       	sbci	r26, 0xFF	; 255
    3b78:	b1 e0       	ldi	r27, 0x01	; 1
    3b7a:	3e d0       	rcall	.+124    	; 0x3bf8 <__ultoa_invert+0x9c>
    3b7c:	b4 e0       	ldi	r27, 0x04	; 4
    3b7e:	3c d0       	rcall	.+120    	; 0x3bf8 <__ultoa_invert+0x9c>
    3b80:	67 0f       	add	r22, r23
    3b82:	78 1f       	adc	r23, r24
    3b84:	89 1f       	adc	r24, r25
    3b86:	9a 1f       	adc	r25, r26
    3b88:	a1 1d       	adc	r26, r1
    3b8a:	68 0f       	add	r22, r24
    3b8c:	79 1f       	adc	r23, r25
    3b8e:	8a 1f       	adc	r24, r26
    3b90:	91 1d       	adc	r25, r1
    3b92:	a1 1d       	adc	r26, r1
    3b94:	6a 0f       	add	r22, r26
    3b96:	71 1d       	adc	r23, r1
    3b98:	81 1d       	adc	r24, r1
    3b9a:	91 1d       	adc	r25, r1
    3b9c:	a1 1d       	adc	r26, r1
    3b9e:	20 d0       	rcall	.+64     	; 0x3be0 <__ultoa_invert+0x84>
    3ba0:	09 f4       	brne	.+2      	; 0x3ba4 <__ultoa_invert+0x48>
    3ba2:	68 94       	set
    3ba4:	3f 91       	pop	r19
    3ba6:	2a e0       	ldi	r18, 0x0A	; 10
    3ba8:	26 9f       	mul	r18, r22
    3baa:	11 24       	eor	r1, r1
    3bac:	30 19       	sub	r19, r0
    3bae:	30 5d       	subi	r19, 0xD0	; 208
    3bb0:	31 93       	st	Z+, r19
    3bb2:	de f6       	brtc	.-74     	; 0x3b6a <__ultoa_invert+0xe>
    3bb4:	cf 01       	movw	r24, r30
    3bb6:	08 95       	ret
    3bb8:	46 2f       	mov	r20, r22
    3bba:	47 70       	andi	r20, 0x07	; 7
    3bbc:	40 5d       	subi	r20, 0xD0	; 208
    3bbe:	41 93       	st	Z+, r20
    3bc0:	b3 e0       	ldi	r27, 0x03	; 3
    3bc2:	0f d0       	rcall	.+30     	; 0x3be2 <__ultoa_invert+0x86>
    3bc4:	c9 f7       	brne	.-14     	; 0x3bb8 <__ultoa_invert+0x5c>
    3bc6:	f6 cf       	rjmp	.-20     	; 0x3bb4 <__ultoa_invert+0x58>
    3bc8:	46 2f       	mov	r20, r22
    3bca:	4f 70       	andi	r20, 0x0F	; 15
    3bcc:	40 5d       	subi	r20, 0xD0	; 208
    3bce:	4a 33       	cpi	r20, 0x3A	; 58
    3bd0:	18 f0       	brcs	.+6      	; 0x3bd8 <__ultoa_invert+0x7c>
    3bd2:	49 5d       	subi	r20, 0xD9	; 217
    3bd4:	31 fd       	sbrc	r19, 1
    3bd6:	40 52       	subi	r20, 0x20	; 32
    3bd8:	41 93       	st	Z+, r20
    3bda:	02 d0       	rcall	.+4      	; 0x3be0 <__ultoa_invert+0x84>
    3bdc:	a9 f7       	brne	.-22     	; 0x3bc8 <__ultoa_invert+0x6c>
    3bde:	ea cf       	rjmp	.-44     	; 0x3bb4 <__ultoa_invert+0x58>
    3be0:	b4 e0       	ldi	r27, 0x04	; 4
    3be2:	a6 95       	lsr	r26
    3be4:	97 95       	ror	r25
    3be6:	87 95       	ror	r24
    3be8:	77 95       	ror	r23
    3bea:	67 95       	ror	r22
    3bec:	ba 95       	dec	r27
    3bee:	c9 f7       	brne	.-14     	; 0x3be2 <__ultoa_invert+0x86>
    3bf0:	00 97       	sbiw	r24, 0x00	; 0
    3bf2:	61 05       	cpc	r22, r1
    3bf4:	71 05       	cpc	r23, r1
    3bf6:	08 95       	ret
    3bf8:	9b 01       	movw	r18, r22
    3bfa:	ac 01       	movw	r20, r24
    3bfc:	0a 2e       	mov	r0, r26
    3bfe:	06 94       	lsr	r0
    3c00:	57 95       	ror	r21
    3c02:	47 95       	ror	r20
    3c04:	37 95       	ror	r19
    3c06:	27 95       	ror	r18
    3c08:	ba 95       	dec	r27
    3c0a:	c9 f7       	brne	.-14     	; 0x3bfe <__ultoa_invert+0xa2>
    3c0c:	62 0f       	add	r22, r18
    3c0e:	73 1f       	adc	r23, r19
    3c10:	84 1f       	adc	r24, r20
    3c12:	95 1f       	adc	r25, r21
    3c14:	a0 1d       	adc	r26, r0
    3c16:	08 95       	ret

00003c18 <__prologue_saves__>:
    3c18:	2f 92       	push	r2
    3c1a:	3f 92       	push	r3
    3c1c:	4f 92       	push	r4
    3c1e:	5f 92       	push	r5
    3c20:	6f 92       	push	r6
    3c22:	7f 92       	push	r7
    3c24:	8f 92       	push	r8
    3c26:	9f 92       	push	r9
    3c28:	af 92       	push	r10
    3c2a:	bf 92       	push	r11
    3c2c:	cf 92       	push	r12
    3c2e:	df 92       	push	r13
    3c30:	ef 92       	push	r14
    3c32:	ff 92       	push	r15
    3c34:	0f 93       	push	r16
    3c36:	1f 93       	push	r17
    3c38:	cf 93       	push	r28
    3c3a:	df 93       	push	r29
    3c3c:	cd b7       	in	r28, 0x3d	; 61
    3c3e:	de b7       	in	r29, 0x3e	; 62
    3c40:	ca 1b       	sub	r28, r26
    3c42:	db 0b       	sbc	r29, r27
    3c44:	0f b6       	in	r0, 0x3f	; 63
    3c46:	f8 94       	cli
    3c48:	de bf       	out	0x3e, r29	; 62
    3c4a:	0f be       	out	0x3f, r0	; 63
    3c4c:	cd bf       	out	0x3d, r28	; 61
    3c4e:	09 94       	ijmp

00003c50 <__epilogue_restores__>:
    3c50:	2a 88       	ldd	r2, Y+18	; 0x12
    3c52:	39 88       	ldd	r3, Y+17	; 0x11
    3c54:	48 88       	ldd	r4, Y+16	; 0x10
    3c56:	5f 84       	ldd	r5, Y+15	; 0x0f
    3c58:	6e 84       	ldd	r6, Y+14	; 0x0e
    3c5a:	7d 84       	ldd	r7, Y+13	; 0x0d
    3c5c:	8c 84       	ldd	r8, Y+12	; 0x0c
    3c5e:	9b 84       	ldd	r9, Y+11	; 0x0b
    3c60:	aa 84       	ldd	r10, Y+10	; 0x0a
    3c62:	b9 84       	ldd	r11, Y+9	; 0x09
    3c64:	c8 84       	ldd	r12, Y+8	; 0x08
    3c66:	df 80       	ldd	r13, Y+7	; 0x07
    3c68:	ee 80       	ldd	r14, Y+6	; 0x06
    3c6a:	fd 80       	ldd	r15, Y+5	; 0x05
    3c6c:	0c 81       	ldd	r16, Y+4	; 0x04
    3c6e:	1b 81       	ldd	r17, Y+3	; 0x03
    3c70:	aa 81       	ldd	r26, Y+2	; 0x02
    3c72:	b9 81       	ldd	r27, Y+1	; 0x01
    3c74:	ce 0f       	add	r28, r30
    3c76:	d1 1d       	adc	r29, r1
    3c78:	0f b6       	in	r0, 0x3f	; 63
    3c7a:	f8 94       	cli
    3c7c:	de bf       	out	0x3e, r29	; 62
    3c7e:	0f be       	out	0x3f, r0	; 63
    3c80:	cd bf       	out	0x3d, r28	; 61
    3c82:	ed 01       	movw	r28, r26
    3c84:	08 95       	ret

00003c86 <_exit>:
    3c86:	f8 94       	cli

00003c88 <__stop_program>:
    3c88:	ff cf       	rjmp	.-2      	; 0x3c88 <__stop_program>
